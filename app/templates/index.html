<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Netops Toolkit</title>
    <style>
        .tabs {
            display: flex;
            border-bottom: 1px solid #ccc;
            margin-bottom: 20px;
        }
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border: 1px solid #ccc;
            border-bottom: none;
            background: #f0f0f0;
            margin-right: 5px;
        }
        .tab.active {
            background: white;
            border-bottom: 1px solid white;
            margin-bottom: -1px;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .device-list, .command-list {
            border: 1px solid #ccc;
            min-height: 100px;
            padding: 10px;
            margin: 10px 0;
            font-family: monospace;
        }
        .add-item {
            margin: 5px 0;
        }
        .remove-btn {
            color: red;
            cursor: pointer;
            margin-left: 10px;
        }
        .run-section {
            background: #f9f9f9;
            padding: 15px;
            border: 1px solid #ddd;
            margin: 20px 0;
        }
        .output-section {
            margin-top: 20px;
        }
        .device-output {
            border: 1px solid #ccc;
            margin: 10px 0;
            padding: 10px;
        }
        .device-output h4 {
            margin: 0 0 10px 0;
            color: #333;
        }
        .command-output {
            background: #f5f5f5;
            border: 1px solid #ddd;
            padding: 10px;
            margin: 5px 0;
            font-family: monospace;
            white-space: pre-wrap;
            overflow-x: auto;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }
        .modal-content {
            background-color: white;
            margin: 15% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 400px;
            border-radius: 5px;
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .close {
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        .close:hover {
            color: black;
        }
        .saved-item {
            padding: 8px;
            margin: 5px 0;
            background: #f9f9f9;
            border: 1px solid #ddd;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .saved-item:hover {
            background: #e9e9e9;
        }
        .saved-item-name {
            font-weight: bold;
        }
        .saved-item-count {
            color: #666;
            font-size: 12px;
        }
        .delete-saved {
            color: red;
            cursor: pointer;
            padding: 2px 6px;
        }
        .command-input-valid {
            border: 2px solid #28a745 !important;
            background-color: #f8fff8 !important;
        }
        .command-input-invalid {
            border: 2px solid #dc3545 !important;
            background-color: #fff5f5 !important;
        }
        .command-help-text {
            font-size: 11px;
            color: #666;
            margin-top: 2px;
            line-height: 1.2;
        }
    </style>
</head>
<body>
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 style="margin: 0;">Netops Toolkit</h2>
        <a href="{{ url_for('main.admin') }}" style="color: #0000EE; text-decoration: underline;">Admin Dashboard â†’</a>
    </div>

    <div class="tabs">
        <div class="tab active" onclick="showTab('ip-translator')">IP Translator</div>
        <div class="tab" onclick="showTab('command-runner')">Command Run Tool</div>
        <div class="tab" onclick="showTab('dns-lookup')">DNS Lookup</div>
        <div class="tab" onclick="showTab('traceroute')">Traceroute</div>
    </div>

    <!-- IP Translator Tab -->
    <div id="ip-translator" class="tab-content active">
        <p>Network IP Address Translator</p>

        <label for="inputText">
            <strong>Enter text with IP addresses:</strong>
        </label>
        <br>
        <textarea
            id="inputText"
            rows="6"
            cols="80"
            placeholder="Paste your text here... IP addresses like 192.168.1.1 will be automatically translated to show hostname and interface information."></textarea>
        <div id="loadingIndicator" style="display: none;">
            Translating...
        </div>

        <br><br>

        <label>
            <strong>Translated Output:</strong>
            <button id="copyButton" style="margin-left: 10px; padding: 4px 8px; cursor: pointer;" onclick="copyTranslatedOutput()">Copy</button>
        </label>
        <br>
        <div id="outputArea" style="border: 0px solid #ccc; padding: 10px; min-height: 100px; font-family: 'Consolas', monospace; line-height: 1.2;">
            <em>Your translated text will appear here...</em>
        </div>
    </div>

    <!-- Command Run Tool Tab -->
    <div id="command-runner" class="tab-content">
        <p>Network Device Command Runner</p>

        <div style="display: flex; gap: 20px;">
            <div style="flex: 1;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <label><strong>Devices:</strong></label>
                    <div>
                        <button onclick="saveDeviceList()" style="padding: 4px 8px; margin-right: 5px; background: #28a745; color: white; border: none; cursor: pointer; font-size: 12px;">Save</button>
                        <button onclick="loadDeviceList()" style="padding: 4px 8px; background: #007cba; color: white; border: none; cursor: pointer; font-size: 12px;">Load</button>
                    </div>
                </div>
                <div class="add-item">
                    <input type="text" id="deviceInput" placeholder="Enter device IP/hostname" style="width: 200px;">
                    <button onclick="addDevice()">Add Device</button>
                </div>
                <div id="deviceList" class="device-list">
                    <em>No devices added...</em>
                </div>
            </div>

            <div style="flex: 1;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <label><strong>Commands:</strong></label>
                    <div>
                        <button onclick="saveCommandList()" style="padding: 4px 8px; margin-right: 5px; background: #28a745; color: white; border: none; cursor: pointer; font-size: 12px;">Save</button>
                        <button onclick="loadCommandList()" style="padding: 4px 8px; background: #007cba; color: white; border: none; cursor: pointer; font-size: 12px;">Load</button>
                    </div>
                </div>
                <div class="add-item">
                    <input type="text" id="commandInput" placeholder="Enter safe command (e.g., show version)" style="width: 200px;">
                    <button onclick="addCommand()">Add Command</button>
                    <div class="command-help-text">
                         Allowed: show, ping, traceroute, get, diagnose, execute<br>
                    </div>
                </div>
                <div id="commandList" class="command-list">
                    <em>No commands added...</em>
                </div>
            </div>
        </div>

        <div class="run-section">
            <label><strong>Credentials:</strong></label><br>
            <label>Username: <input type="text" id="username" style="margin: 5px;"></label><br>
            <label>Password: <input type="password" id="password" style="margin: 5px;"></label><br><br>

            <button onclick="runCommands()" style="padding: 10px 20px; background: #007cba; color: white; border: none; cursor: pointer;">Run Commands</button>
            <div id="runProgress" style="display: none; margin-top: 10px;">
                <div>Running commands... Please wait.</div>
            </div>
        </div>

        <div class="output-section">
            <div id="commandResults"></div>
            <div id="downloadSection" style="display: none; margin-top: 20px;">
                <button onclick="downloadResults()" style="padding: 10px 20px; background: #28a745; color: white; border: none; cursor: pointer;">Download All Results (ZIP)</button>
            </div>
        </div>
    </div>

    <!-- DNS Lookup Tab -->
    <div id="dns-lookup" class="tab-content">
        <p>Bulk DNS Lookup Tool</p>

        <div>
            <label><strong>Domains/IP Addresses (one per line):</strong></label>
            <br>
            <textarea
                id="dnsInput"
                rows="10"
                cols="50"
                placeholder="Enter domains or IP addresses, one per line:&#10;"
                oninput="validateDnsInput()"
                style="width: 50%; font-family: monospace;"></textarea>

            <div id="dnsValidation" style="margin-top: 5px; min-height: 20px;"></div>

            <div style="margin-top: 15px;">
                <!-- DNS Servers Section -->
                <div style="display: flex; align-items: center; gap: 10px;">
                    <label><strong>DNS Servers (optional):</strong></label>
                    <span style="font-size: 12px; color: #666;">Leave empty for system default</span>
                    <button onclick="saveDnsServerList()" style="padding: 4px 8px; background: #28a745; color: white; border: none; cursor: pointer; font-size: 12px;">Save</button>
                    <button onclick="loadDnsServerList()" style="padding: 4px 8px; background: #007cba; color: white; border: none; cursor: pointer; font-size: 12px;">Load</button>
                </div>

                <textarea
                    id="dnsServers"
                    rows="3"
                    cols="30"
                    placeholder=""
                    oninput="validateDnsInput()"
                    style="width: 50%; font-family: monospace; margin-top: 5px;"></textarea>

                <div id="dnsServersValidation" style="margin-top: 5px; min-height: 20px;"></div>

                <!-- Lookup Type on same line as button -->
                <div style="margin-top: 15px;">
                    <label style="display: inline-block; margin-right: 10px;">
                        <strong>Lookup Type:</strong>
                        <select id="lookupType" style="padding: 5px; margin-left: 5px;" onchange="validateDnsInput()">
                            <option value="A">A Record (IPv4)</option>
                            <option value="AAAA">AAAA Record (IPv6)</option>
                            <option value="CNAME">CNAME Record</option>
                            <option value="MX">MX Record</option>
                            <option value="NS">NS Record</option>
                            <option value="PTR">PTR Record (Reverse)</option>
                            <option value="TXT">TXT Record</option>
                            <option value="ALL">All Records</option>
                        </select>
                    </label>
                    <button onclick="performDnsLookup()" style="padding: 10px 20px; background: #007cba; color: white; border: none; cursor: pointer;">Perform DNS Lookup</button>
                    <div id="dnsProgress" style="display: none; margin-top: 10px;">
                        <div>Performing DNS lookups... Please wait.</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="output-section">
            <div style="margin-top: 20px;">
                <label>
                    <strong>DNS Lookup Results:</strong>
                    <button id="copyDnsButton" style="margin-left: 10px; padding: 4px 8px; cursor: pointer;" onclick="copyDnsResults()">Copy</button>
                </label>
                <br>
                <div id="dnsResults" style="border: 1px solid #ccc; padding: 10px; min-height: 200px; font-family: 'Consolas', monospace; line-height: 1.2; background: white; margin-top: 10px; white-space: pre-wrap;">
                    <em>DNS lookup results will appear here...</em>
                </div>
            </div>
        </div>
    </div>

    <!-- Traceroute Tab -->
    <div id="traceroute" class="tab-content">
        <p>Parallel Traceroute Tool</p>

        <div>
            <div style="display: flex; align-items: center; gap: 10px;">
                <label><strong>Target Hosts (one per line):</strong></label>
                <button onclick="saveTracerouteTargets()" style="padding: 4px 8px; background: #28a745; color: white; border: none; cursor: pointer; font-size: 12px;">Save</button>
                <button onclick="loadTracerouteTargets()" style="padding: 4px 8px; background: #007cba; color: white; border: none; cursor: pointer; font-size: 12px;">Load</button>
            </div>
            <br>
            <textarea
                id="tracerouteTargets"
                rows="10"
                cols="50"
                placeholder="Enter IP addresses or hostnames, one per line:&#10;"
                oninput="validateTracerouteInput()"
                style="width: 50%; font-family: monospace;"></textarea>

            <div id="tracerouteValidation" style="margin-top: 5px; min-height: 20px;"></div>

            <div style="margin-top: 15px;">
                <label><strong>Traceroute Options:</strong></label>

                <!-- Compact options in a single line -->
                <div style="margin: 10px 0;">
                    <label style="display: inline-block; margin-right: 15px;">
                        Max Hops: <input type="number" id="maxHops" min="1" max="255" value="30" style="width: 50px; padding: 2px;">
                    </label>
                    <label style="display: inline-block; margin-right: 15px;">
                        Timeout (s): <input type="number" id="traceTimeout" min="1" max="60" value="1" style="width: 50px; padding: 2px;">
                    </label>
                    <label style="display: inline-block; margin-right: 15px;">
                        Probes/hop: <input type="number" id="probesPerHop" min="1" max="10" value="1" style="width: 50px; padding: 2px;">
                    </label>
                    <label style="display: inline-block;">
                        Packet size: <input type="number" id="packetSize" min="28" max="65000" value="60" style="width: 60px; padding: 2px;"> bytes
                    </label>
                </div>

                <div style="margin: 10px 0;">
                    <label style="margin-right: 20px;">
                        <input type="checkbox" id="translateIPs" checked>
                        Translate IP addresses
                    </label>
                    <label>
                        <input type="checkbox" id="resolveHostnames" checked>
                        Resolve hostnames
                    </label>
                </div>

                <div style="margin-top: 15px;">
                    <button onclick="performTraceroute()" style="padding: 10px 20px; background: #007cba; color: white; border: none; cursor: pointer;">Run Traceroute</button>
                    <div id="tracerouteProgress" style="display: none; margin-top: 10px;">
                        <div id="tracerouteProgressText">Running traceroutes... Please wait.</div>
                        <div id="tracerouteProgressDetail" style="margin-top: 5px; font-size: 12px; color: #666;"></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="output-section">
            <div style="margin-top: 20px;">
                <label>
                    <strong>Traceroute Results:</strong>
                    <button id="copyTracerouteButton" style="margin-left: 10px; padding: 4px 8px; cursor: pointer;" onclick="copyTracerouteResults()">Copy</button>
                    <button id="downloadTracerouteButton" style="margin-left: 10px; padding: 4px 8px; cursor: pointer; background: #28a745; color: white; border: none;" onclick="downloadTracerouteResults()">Download</button>
                </label>
                <br>
                <div id="tracerouteResults" style="border: 0px solid #ccc; padding: 10px; min-height: 200px; font-family: 'Consolas', monospace; line-height: 1.4; background: white; margin-top: 10px; white-space: pre-wrap; overflow-x: auto;">
                    <em>Traceroute results will appear here...</em>
                </div>
            </div>
        </div>
    </div>



    <!-- Tooltip container -->
    <div id="tooltip" style="position: absolute; background: #333; color: white; padding: 10px; border-radius: 5px; display: none; z-index: 1000;"></div>

    <!-- Save Device List Modal -->
    <div id="saveDeviceModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Save Device List</h3>
                <span class="close" onclick="closeSaveDeviceModal()">&times;</span>
            </div>
            <div>
                <label for="deviceListName"><strong>List Name:</strong></label><br>
                <input type="text" id="deviceListName" placeholder="Enter list name" style="width: 100%; margin: 10px 0; padding: 5px;">
                <div style="margin-top: 15px;">
                    <button onclick="confirmSaveDeviceList()" style="padding: 8px 16px; background: #28a745; color: white; border: none; cursor: pointer; margin-right: 10px;">Save</button>
                    <button onclick="closeSaveDeviceModal()" style="padding: 8px 16px; background: #6c757d; color: white; border: none; cursor: pointer;">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Load Device List Modal -->
    <div id="loadDeviceModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Load Device List</h3>
                <span class="close" onclick="closeLoadDeviceModal()">&times;</span>
            </div>
            <div id="savedDeviceLists">
                <em>No saved device lists found...</em>
            </div>
        </div>
    </div>

    <!-- Save Command List Modal -->
    <div id="saveCommandModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Save Command List</h3>
                <span class="close" onclick="closeSaveCommandModal()">&times;</span>
            </div>
            <div>
                <label for="commandListName"><strong>List Name:</strong></label><br>
                <input type="text" id="commandListName" placeholder="Enter list name" style="width: 100%; margin: 10px 0; padding: 5px;">
                <div style="margin-top: 15px;">
                    <button onclick="confirmSaveCommandList()" style="padding: 8px 16px; background: #28a745; color: white; border: none; cursor: pointer; margin-right: 10px;">Save</button>
                    <button onclick="closeSaveCommandModal()" style="padding: 8px 16px; background: #6c757d; color: white; border: none; cursor: pointer;">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Load Command List Modal -->
    <div id="loadCommandModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Load Command List</h3>
                <span class="close" onclick="closeLoadCommandModal()">&times;</span>
            </div>
            <div id="savedCommandLists">
                <em>No saved command lists found...</em>
            </div>
        </div>
    </div>

    <!-- Save DNS Server List Modal -->
    <div id="saveDnsServerModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Save DNS Server List</h3>
                <span class="close" onclick="closeSaveDnsServerModal()">&times;</span>
            </div>
            <div>
                <label for="dnsServerListName"><strong>List Name:</strong></label><br>
                <input type="text" id="dnsServerListName" placeholder="Enter list name (e.g., Public DNS, Corporate DNS)" style="width: 100%; margin: 10px 0; padding: 5px;">
                <div style="margin-top: 15px;">
                    <button onclick="confirmSaveDnsServerList()" style="padding: 8px 16px; background: #28a745; color: white; border: none; cursor: pointer; margin-right: 10px;">Save</button>
                    <button onclick="closeSaveDnsServerModal()" style="padding: 8px 16px; background: #6c757d; color: white; border: none; cursor: pointer;">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Load DNS Server List Modal -->
    <div id="loadDnsServerModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Load DNS Server List</h3>
                <span class="close" onclick="closeLoadDnsServerModal()">&times;</span>
            </div>
            <div id="savedDnsServerLists">
                <em>No saved DNS server lists found...</em>
            </div>
        </div>
    </div>

    <!-- Save Traceroute Targets Modal -->
    <div id="saveTracerouteTargetsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Save Traceroute Targets</h3>
                <span class="close" onclick="closeSaveTracerouteTargetsModal()">&times;</span>
            </div>
            <div>
                <label for="tracerouteTargetsListName"><strong>List Name:</strong></label><br>
                <input type="text" id="tracerouteTargetsListName" placeholder="Enter list name (e.g., Core Networks, Remote Sites)" style="width: 100%; margin: 10px 0; padding: 5px;">
                <div style="margin-top: 15px;">
                    <button onclick="confirmSaveTracerouteTargets()" style="padding: 8px 16px; background: #28a745; color: white; border: none; cursor: pointer; margin-right: 10px;">Save</button>
                    <button onclick="closeSaveTracerouteTargetsModal()" style="padding: 8px 16px; background: #6c757d; color: white; border: none; cursor: pointer;">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Load Traceroute Targets Modal -->
    <div id="loadTracerouteTargetsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Load Traceroute Targets</h3>
                <span class="close" onclick="closeLoadTracerouteTargetsModal()">&times;</span>
            </div>
            <div id="savedTracerouteTargetLists">
                <em>No saved traceroute target lists found...</em>
            </div>
        </div>
    </div>
    <script>
        // Global variables
        let timeoutId;
        const inputText = document.getElementById('inputText');
        const outputArea = document.getElementById('outputArea');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const tooltip = document.getElementById('tooltip');

        // Command runner variables
        let devices = [];
        let commands = [];
        let commandResults = {};

        // Command validation rules (loaded from database)
        let commandRules = {
            safePrefixes: [],
            dangerousPatterns: [],
            standaloneCommands: []
        };

        // Tab switching function
        function showTab(tabName) {
            // Hide all tab contents
            const tabContents = document.querySelectorAll('.tab-content');
            tabContents.forEach(tab => tab.classList.remove('active'));

            // Remove active class from all tabs
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => tab.classList.remove('active'));

            // Show selected tab
            document.getElementById(tabName).classList.add('active');

            // Add active class to clicked tab
            event.target.classList.add('active');
        }

        // Load command validation rules from server
        function loadCommandRules() {
            fetch('/settings/api/command-rules')
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        commandRules = data.rules;
                    }
                })
                .catch(error => {
                    console.error('Error loading command rules:', error);
                    // Use default rules if server request fails
                    commandRules = {
                        safePrefixes: [
                            'show ',
                            'execute ping ',
                            'execute traceroute ',
                            'ping ',
                            'traceroute ',
                            'trace ',
                            'get system ',
                            'diagnose '
                        ],
                        dangerousPatterns: [
                            'delete',
                            'remove',
                            'erase',
                            'format',
                            'reload',
                            'reboot',
                            'shutdown',
                            'clear',
                            'reset',
                            'write',
                            'copy',
                            'configure',
                            'config',
                            'exit',
                            'quit',
                            'end',
                            'commit',
                            'save'
                        ],
                        standaloneCommands: [
                            'uptime',
                            'version',
                            'date',
                            'clock',
                            'whoami',
                            'pwd'
                        ]
                    };
                });
        }

        // Initialize page
        document.addEventListener('DOMContentLoaded', function() {
            loadCommandRules();
        });

        // Command safety validation function (client-side) - uses database rules
        function validateCommandSafety(command) {
            if (!command || typeof command !== 'string') {
                return { isValid: false, message: "Invalid command format" };
            }

            const cleanCommand = command.trim().toLowerCase();

            // Step 1: Check for dangerous patterns first (blocklist approach)
            for (const pattern of commandRules.dangerousPatterns) {
                if (cleanCommand.includes(pattern.toLowerCase())) {
                    return {
                        isValid: false,
                        message: `Dangerous command pattern detected: '${pattern}'. Only read-only troubleshooting commands are allowed.`
                    };
                }
            }

            // Step 2: Check for safe prefixes (allowlist approach)
            for (const prefix of commandRules.safePrefixes) {
                if (cleanCommand.startsWith(prefix.toLowerCase())) {
                    return { isValid: true, message: null };
                }
            }

            // Step 3: Check standalone commands
            if (commandRules.standaloneCommands.some(cmd => cleanCommand === cmd.toLowerCase())) {
                return { isValid: true, message: null };
            }

            return {
                isValid: false,
                message: `Command '${command}' is not in the list of allowed safe commands. Use the Settings page to manage allowed commands.`
            };
        }

        // Command runner functions
        function addDevice() {
            const deviceInput = document.getElementById('deviceInput');
            const device = deviceInput.value.trim();

            if (device && !devices.includes(device)) {
                devices.push(device);
                updateDeviceList();
                deviceInput.value = '';
            }
        }

        function addCommand() {
            const commandInput = document.getElementById('commandInput');
            const command = commandInput.value.trim();

            if (!command) {
                return;
            }

            // Validate command safety
            const validation = validateCommandSafety(command);
            if (!validation.isValid) {
                alert(`âŒ Command Blocked\n\n${validation.message}\n\nOnly safe, read-only troubleshooting commands are allowed.`);
                commandInput.value = '';
                commandInput.focus();
                return;
            }

            if (!commands.includes(command)) {
                commands.push(command);
                updateCommandList();
                commandInput.value = '';
                // Visual feedback for successful addition
                const addButton = event.target;
                const originalText = addButton.textContent;
                addButton.textContent = 'âœ“ Added';
                addButton.style.backgroundColor = '#28a745';
                addButton.style.color = 'white';
                setTimeout(() => {
                    addButton.textContent = originalText;
                    addButton.style.backgroundColor = '';
                    addButton.style.color = '';
                }, 1000);
            } else {
                alert('Command already exists in the list');
                commandInput.value = '';
            }
        }

        function removeDevice(device) {
            devices = devices.filter(d => d !== device);
            updateDeviceList();
        }

        function removeCommand(command) {
            commands = commands.filter(c => c !== command);
            updateCommandList();
        }

        function updateDeviceList() {
            const deviceList = document.getElementById('deviceList');
            if (devices.length === 0) {
                deviceList.innerHTML = '<em>No devices added...</em>';
            } else {
                deviceList.innerHTML = devices.map(device =>
                    `<div>${device} <span class="remove-btn" onclick="removeDevice('${device}')">âœ—</span></div>`
                ).join('');
            }
        }

        function updateCommandList() {
            const commandList = document.getElementById('commandList');
            if (commands.length === 0) {
                commandList.innerHTML = '<em>No commands added...</em>';
            } else {
                commandList.innerHTML = commands.map(command =>
                    `<div>${command} <span class="remove-btn" onclick="removeCommand('${command}')">âœ—</span></div>`
                ).join('');
            }
        }

        async function runCommands() {
            const username = document.getElementById('username').value.trim();
            const password = document.getElementById('password').value.trim();

            if (!username || !password) {
                alert('Please enter username and password');
                return;
            }

            if (devices.length === 0) {
                alert('Please add at least one device');
                return;
            }

            if (commands.length === 0) {
                alert('Please add at least one command');
                return;
            }

            // Final safety check - validate all commands before execution
            const invalidCommands = [];
            for (const command of commands) {
                const validation = validateCommandSafety(command);
                if (!validation.isValid) {
                    invalidCommands.push({
                        command: command,
                        reason: validation.message
                    });
                }
            }

            if (invalidCommands.length > 0) {
                let errorMessage = `ðŸš« Execution Blocked - Unsafe Commands Detected\n\n`;
                invalidCommands.forEach(item => {
                    errorMessage += `â€¢ "${item.command}"\n  Reason: ${item.reason}\n\n`;
                });
                errorMessage += `Please remove these commands and try again.`;
                alert(errorMessage);
                return;
            }

            const runProgress = document.getElementById('runProgress');
            const commandResults = document.getElementById('commandResults');

            runProgress.style.display = 'block';
            commandResults.innerHTML = '';

            try {
                const response = await fetch('/api/run-commands', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        devices: devices,
                        commands: commands,
                        username: username,
                        password: password
                    })
                });

                const data = await response.json();

                if (data.success) {
                    displayResults(data.results);
                    document.getElementById('downloadSection').style.display = 'block';
                } else {
                    alert('Error: ' + data.error);
                }
            } catch (error) {
                console.error('Error running commands:', error);
                alert('Error running commands: ' + error.message);
            } finally {
                runProgress.style.display = 'none';
            }
        }

        function displayResults(results) {
            const commandResults = document.getElementById('commandResults');
            commandResults.innerHTML = '';

            console.log('Displaying results:', results); // Debug log

            for (const [device, deviceData] of Object.entries(results)) {
                const deviceDiv = document.createElement('div');
                deviceDiv.className = 'device-output';

                const deviceHeader = document.createElement('h4');
                deviceHeader.textContent = `${device} (${deviceData.status})`;
                deviceDiv.appendChild(deviceHeader);

                if (deviceData.status === 'success') {
                    for (const [command, commandData] of Object.entries(deviceData.commands)) {
                        const commandDiv = document.createElement('div');
                        commandDiv.innerHTML = `<strong>Command:</strong> ${command}`;
                        deviceDiv.appendChild(commandDiv);

                        const outputDiv = document.createElement('div');
                        outputDiv.className = 'command-output';

                        // Debug logging
                        console.log(`Command: ${command}`);
                        console.log(`CommandData:`, commandData);
                        console.log(`Raw output length: ${commandData.output ? commandData.output.length : 0}`);
                        console.log(`Translated output length: ${commandData.translated_output ? commandData.translated_output.length : 0}`);

                        let outputText = 'No output received';
                        if (commandData.translated_output && commandData.translated_output.trim()) {
                            outputText = commandData.translated_output;
                        } else if (commandData.output && commandData.output.trim()) {
                            outputText = commandData.output;
                        }

                        // Use innerHTML instead of textContent to preserve formatting
                        outputDiv.innerHTML = outputText.replace(/\n/g, '<br>');
                        deviceDiv.appendChild(outputDiv);
                    }
                } else {
                    const errorDiv = document.createElement('div');
                    errorDiv.className = 'command-output';
                    errorDiv.style.color = 'red';
                    errorDiv.textContent = deviceData.error;
                    deviceDiv.appendChild(errorDiv);
                }

                commandResults.appendChild(deviceDiv);
            }

            // Store results for download
            window.lastResults = results;
        }

        async function downloadResults() {
            if (!window.lastResults) {
                alert('No results to download');
                return;
            }

            try {
                const response = await fetch('/api/download-results', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        results: window.lastResults
                    })
                });

                if (response.ok) {
                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `command_results_${new Date().toISOString().slice(0,19).replace(/:/g, '-')}.zip`;
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(url);
                    a.remove();
                } else {
                    alert('Error downloading results');
                }
            } catch (error) {
                console.error('Error downloading results:', error);
                alert('Error downloading results: ' + error.message);
            }
        }

        // Add event listeners for Enter key
        document.getElementById('deviceInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                addDevice();
            }
        });

        document.getElementById('commandInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                addCommand();
            }
        });

        // Add real-time command validation
        document.getElementById('commandInput').addEventListener('input', function(e) {
            const command = e.target.value.trim();
            const addButton = document.querySelector('button[onclick="addCommand()"]');

            // Remove existing validation classes
            e.target.classList.remove('command-input-valid', 'command-input-invalid');

            if (command) {
                const validation = validateCommandSafety(command);
                if (!validation.isValid) {
                    // Show visual feedback for invalid command
                    e.target.classList.add('command-input-invalid');
                    e.target.title = validation.message;
                    addButton.disabled = true;
                    addButton.style.opacity = '0.6';
                    addButton.title = 'Command not allowed - ' + validation.message;
                } else {
                    // Command is valid
                    e.target.classList.add('command-input-valid');
                    e.target.title = 'Valid command - ready to add';
                    addButton.disabled = false;
                    addButton.style.opacity = '1';
                    addButton.title = 'Add this command';
                }
            } else {
                // Reset to default state when empty
                e.target.title = '';
                addButton.disabled = false;
                addButton.style.opacity = '1';
                addButton.title = '';
            }
        });

        // Save/Load functionality for device lists
        function saveDeviceList() {
            if (devices.length === 0) {
                alert('No devices to save');
                return;
            }
            document.getElementById('saveDeviceModal').style.display = 'block';
            document.getElementById('deviceListName').focus();
        }

        function closeSaveDeviceModal() {
            document.getElementById('saveDeviceModal').style.display = 'none';
            document.getElementById('deviceListName').value = '';
        }

        function confirmSaveDeviceList() {
            const listName = document.getElementById('deviceListName').value.trim();
            if (!listName) {
                alert('Please enter a list name');
                return;
            }

            // Save to localStorage
            let savedDeviceLists = JSON.parse(localStorage.getItem('savedDeviceLists') || '{}');
            savedDeviceLists[listName] = {
                devices: [...devices],
                savedAt: new Date().toISOString()
            };
            localStorage.setItem('savedDeviceLists', JSON.stringify(savedDeviceLists));

            alert(`Device list "${listName}" saved successfully!`);
            closeSaveDeviceModal();
        }

        function loadDeviceList() {
            const savedDeviceLists = JSON.parse(localStorage.getItem('savedDeviceLists') || '{}');
            const savedListsDiv = document.getElementById('savedDeviceLists');

            if (Object.keys(savedDeviceLists).length === 0) {
                savedListsDiv.innerHTML = '<em>No saved device lists found...</em>';
            } else {
                savedListsDiv.innerHTML = '';
                for (const [listName, listData] of Object.entries(savedDeviceLists)) {
                    const savedItem = document.createElement('div');
                    savedItem.className = 'saved-item';

                    const itemInfo = document.createElement('div');
                    itemInfo.innerHTML = `
                        <div class="saved-item-name">${listName}</div>
                        <div class="saved-item-count">${listData.devices.length} devices - Saved: ${new Date(listData.savedAt).toLocaleDateString()}</div>
                    `;

                    const deleteBtn = document.createElement('span');
                    deleteBtn.className = 'delete-saved';
                    deleteBtn.innerHTML = 'âœ—';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        deleteDeviceList(listName);
                    };

                    savedItem.appendChild(itemInfo);
                    savedItem.appendChild(deleteBtn);

                    savedItem.onclick = () => confirmLoadDeviceList(listName, listData.devices);
                    savedListsDiv.appendChild(savedItem);
                }
            }

            document.getElementById('loadDeviceModal').style.display = 'block';
        }

        function closeLoadDeviceModal() {
            document.getElementById('loadDeviceModal').style.display = 'none';
        }

        function confirmLoadDeviceList(listName, deviceList) {
            if (devices.length > 0) {
                if (!confirm(`This will replace your current device list (${devices.length} devices). Continue?`)) {
                    return;
                }
            }

            devices = [...deviceList];
            updateDeviceList();
            closeLoadDeviceModal();
            alert(`Device list "${listName}" loaded successfully!`);
        }

        function deleteDeviceList(listName) {
            if (confirm(`Delete device list "${listName}"?`)) {
                let savedDeviceLists = JSON.parse(localStorage.getItem('savedDeviceLists') || '{}');
                delete savedDeviceLists[listName];
                localStorage.setItem('savedDeviceLists', JSON.stringify(savedDeviceLists));
                loadDeviceList(); // Refresh the modal
            }
        }

        // Save/Load functionality for command lists
        function saveCommandList() {
            if (commands.length === 0) {
                alert('No commands to save');
                return;
            }
            document.getElementById('saveCommandModal').style.display = 'block';
            document.getElementById('commandListName').focus();
        }

        function closeSaveCommandModal() {
            document.getElementById('saveCommandModal').style.display = 'none';
            document.getElementById('commandListName').value = '';
        }

        function confirmSaveCommandList() {
            const listName = document.getElementById('commandListName').value.trim();
            if (!listName) {
                alert('Please enter a list name');
                return;
            }

            // Save to localStorage
            let savedCommandLists = JSON.parse(localStorage.getItem('savedCommandLists') || '{}');
            savedCommandLists[listName] = {
                commands: [...commands],
                savedAt: new Date().toISOString()
            };
            localStorage.setItem('savedCommandLists', JSON.stringify(savedCommandLists));

            alert(`Command list "${listName}" saved successfully!`);
            closeSaveCommandModal();
        }

        function loadCommandList() {
            const savedCommandLists = JSON.parse(localStorage.getItem('savedCommandLists') || '{}');
            const savedListsDiv = document.getElementById('savedCommandLists');

            if (Object.keys(savedCommandLists).length === 0) {
                savedListsDiv.innerHTML = '<em>No saved command lists found...</em>';
            } else {
                savedListsDiv.innerHTML = '';
                for (const [listName, listData] of Object.entries(savedCommandLists)) {
                    const savedItem = document.createElement('div');
                    savedItem.className = 'saved-item';

                    const itemInfo = document.createElement('div');
                    itemInfo.innerHTML = `
                        <div class="saved-item-name">${listName}</div>
                        <div class="saved-item-count">${listData.commands.length} commands - Saved: ${new Date(listData.savedAt).toLocaleDateString()}</div>
                    `;

                    const deleteBtn = document.createElement('span');
                    deleteBtn.className = 'delete-saved';
                    deleteBtn.innerHTML = 'âœ—';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        deleteCommandList(listName);
                    };

                    savedItem.appendChild(itemInfo);
                    savedItem.appendChild(deleteBtn);

                    savedItem.onclick = () => confirmLoadCommandList(listName, listData.commands);
                    savedListsDiv.appendChild(savedItem);
                }
            }

            document.getElementById('loadCommandModal').style.display = 'block';
        }

        function closeLoadCommandModal() {
            document.getElementById('loadCommandModal').style.display = 'none';
        }

        function confirmLoadCommandList(listName, commandList) {
            if (commands.length > 0) {
                if (!confirm(`This will replace your current command list (${commands.length} commands). Continue?`)) {
                    return;
                }
            }

            // Validate all commands being loaded
            const validCommands = [];
            const invalidCommands = [];

            for (const command of commandList) {
                const validation = validateCommandSafety(command);
                if (validation.isValid) {
                    validCommands.push(command);
                } else {
                    invalidCommands.push({
                        command: command,
                        reason: validation.message
                    });
                }
            }

            if (invalidCommands.length > 0) {
                let warningMessage = `âš ï¸ Security Warning\n\n${invalidCommands.length} unsafe command(s) were blocked from loading:\n\n`;
                invalidCommands.forEach(item => {
                    warningMessage += `â€¢ "${item.command}"\n  Reason: ${item.reason}\n\n`;
                });

                if (validCommands.length > 0) {
                    warningMessage += `${validCommands.length} safe command(s) will be loaded.`;
                } else {
                    warningMessage += `No safe commands found in this list.`;
                }

                alert(warningMessage);
            }

            commands = validCommands;
            updateCommandList();
            closeLoadCommandModal();

            if (validCommands.length > 0) {
                alert(`Command list "${listName}" loaded with ${validCommands.length} safe command(s)!`);
            } else {
                alert(`Command list "${listName}" contained no safe commands.`);
            }
        }

        function deleteCommandList(listName) {
            if (confirm(`Delete command list "${listName}"?`)) {
                let savedCommandLists = JSON.parse(localStorage.getItem('savedCommandLists') || '{}');
                delete savedCommandLists[listName];
                localStorage.setItem('savedCommandLists', JSON.stringify(savedCommandLists));
                loadCommandList(); // Refresh the modal
            }
        }

        // Save/Load functionality for traceroute targets
        function saveTracerouteTargets() {
            const tracerouteTargets = document.getElementById('tracerouteTargets').value.trim();

            if (!tracerouteTargets) {
                alert('No traceroute targets to save');
                return;
            }

            document.getElementById('saveTracerouteTargetsModal').style.display = 'block';
            document.getElementById('tracerouteTargetsListName').focus();
        }

        function closeSaveTracerouteTargetsModal() {
            document.getElementById('saveTracerouteTargetsModal').style.display = 'none';
            document.getElementById('tracerouteTargetsListName').value = '';
        }

        function confirmSaveTracerouteTargets() {
            const listName = document.getElementById('tracerouteTargetsListName').value.trim();
            if (!listName) {
                alert('Please enter a list name');
                return;
            }

            const tracerouteTargets = document.getElementById('tracerouteTargets').value.trim();
            const targetList = tracerouteTargets.split('\n').map(t => t.trim()).filter(t => t.length > 0);

            // Save to localStorage
            let savedTracerouteTargetLists = JSON.parse(localStorage.getItem('savedTracerouteTargetLists') || '{}');
            savedTracerouteTargetLists[listName] = {
                targets: targetList,
                savedAt: new Date().toISOString()
            };
            localStorage.setItem('savedTracerouteTargetLists', JSON.stringify(savedTracerouteTargetLists));

            alert(`Traceroute target list "${listName}" saved successfully!`);
            closeSaveTracerouteTargetsModal();
        }

        function loadTracerouteTargets() {
            const savedTracerouteTargetLists = JSON.parse(localStorage.getItem('savedTracerouteTargetLists') || '{}');
            const savedListsDiv = document.getElementById('savedTracerouteTargetLists');

            if (Object.keys(savedTracerouteTargetLists).length === 0) {
                savedListsDiv.innerHTML = '<em>No saved traceroute target lists found...</em>';
            } else {
                savedListsDiv.innerHTML = '';

                // Add predefined common target lists
                const commonTargetLists = {
                    'Public DNS Servers': ['8.8.8.8', '1.1.1.1', '208.67.222.222', '9.9.9.9'],
                    'Internet Destinations': ['google.com', 'cloudflare.com', 'github.com', 'stackoverflow.com'],
                    'Network Test Sites': ['test-ipv6.com', 'ipv6-test.com', 'whatismyipaddress.com'],
                    'RFC3330 Test IPs': ['192.0.2.1', '198.51.100.1', '203.0.113.1']
                };

                // Add common target lists section
                const commonHeader = document.createElement('div');
                commonHeader.innerHTML = '<strong style="color: #007cba;">Common Target Lists:</strong>';
                commonHeader.style.marginBottom = '10px';
                savedListsDiv.appendChild(commonHeader);

                for (const [listName, targets] of Object.entries(commonTargetLists)) {
                    const savedItem = document.createElement('div');
                    savedItem.className = 'saved-item';
                    savedItem.style.borderColor = '#007cba';

                    const itemInfo = document.createElement('div');
                    itemInfo.innerHTML = `
                        <div class="saved-item-name">${listName}</div>
                        <div class="saved-item-count">${targets.length} targets</div>
                    `;

                    savedItem.appendChild(itemInfo);
                    savedItem.onclick = () => confirmLoadTracerouteTargets(listName, targets);
                    savedListsDiv.appendChild(savedItem);
                }

                // Add separator
                const separator = document.createElement('div');
                separator.innerHTML = '<hr style="margin: 15px 0;"><strong style="color: #28a745;">Saved Lists:</strong>';
                separator.style.marginBottom = '10px';
                savedListsDiv.appendChild(separator);

                // Add saved target lists
                for (const [listName, listData] of Object.entries(savedTracerouteTargetLists)) {
                    const savedItem = document.createElement('div');
                    savedItem.className = 'saved-item';

                    const itemInfo = document.createElement('div');
                    itemInfo.innerHTML = `
                        <div class="saved-item-name">${listName}</div>
                        <div class="saved-item-count">${listData.targets.length} targets - Saved: ${new Date(listData.savedAt).toLocaleDateString()}</div>
                    `;

                    const deleteBtn = document.createElement('span');
                    deleteBtn.className = 'delete-saved';
                    deleteBtn.innerHTML = 'âœ—';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        deleteTracerouteTargetList(listName);
                    };

                    savedItem.appendChild(itemInfo);
                    savedItem.appendChild(deleteBtn);

                    savedItem.onclick = () => confirmLoadTracerouteTargets(listName, listData.targets);
                    savedListsDiv.appendChild(savedItem);
                }
            }

            document.getElementById('loadTracerouteTargetsModal').style.display = 'block';
        }

        function closeLoadTracerouteTargetsModal() {
            document.getElementById('loadTracerouteTargetsModal').style.display = 'none';
        }

        function confirmLoadTracerouteTargets(listName, targetList) {
            const tracerouteTargetsTextarea = document.getElementById('tracerouteTargets');
            const currentTargets = tracerouteTargetsTextarea.value.trim();

            if (currentTargets) {
                if (!confirm(`This will replace your current target list. Continue?`)) {
                    return;
                }
            }

            tracerouteTargetsTextarea.value = targetList.join('\n');
            closeLoadTracerouteTargetsModal();
            alert(`Traceroute target list "${listName}" loaded successfully!`);
        }

        function deleteTracerouteTargetList(listName) {
            if (confirm(`Delete traceroute target list "${listName}"?`)) {
                let savedTracerouteTargetLists = JSON.parse(localStorage.getItem('savedTracerouteTargetLists') || '{}');
                delete savedTracerouteTargetLists[listName];
                localStorage.setItem('savedTracerouteTargetLists', JSON.stringify(savedTracerouteTargetLists));
                loadTracerouteTargets(); // Refresh the modal
            }
        }

        // Close modals when clicking outside
        window.onclick = function(event) {
            const modals = ['saveDeviceModal', 'loadDeviceModal', 'saveCommandModal', 'loadCommandModal', 'saveDnsServerModal', 'loadDnsServerModal', 'saveTracerouteTargetsModal', 'loadTracerouteTargetsModal'];
            modals.forEach(modalId => {
                const modal = document.getElementById(modalId);
                if (event.target === modal) {
                    modal.style.display = 'none';
                }
            });
        };

        // Add Enter key support for save modals
        document.getElementById('deviceListName').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                confirmSaveDeviceList();
            }
        });

        document.getElementById('commandListName').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                confirmSaveCommandList();
            }
        });

        // DNS Lookup functionality
        async function performDnsLookup() {
            const dnsInput = document.getElementById('dnsInput').value.trim();
            const dnsServers = document.getElementById('dnsServers').value.trim();
            const lookupType = document.getElementById('lookupType').value;
            const dnsResults = document.getElementById('dnsResults');
            const dnsProgress = document.getElementById('dnsProgress');

            if (!dnsInput) {
                alert('Please enter at least one domain or IP address');
                return;
            }

            // Parse input - split by lines and filter empty lines
            const targets = dnsInput.split('\n').map(line => line.trim()).filter(line => line.length > 0);
            const servers = dnsServers ? dnsServers.split('\n').map(line => line.trim()).filter(line => line.length > 0) : [];

            // Validate all targets
            const invalidTargets = [];
            for (const target of targets) {
                const validation = validateDnsTarget(target, lookupType);
                if (!validation.isValid) {
                    invalidTargets.push(`${target}: ${validation.message}`);
                }
            }

            // Validate all DNS servers
            const invalidServers = [];
            for (const server of servers) {
                const validation = validateDnsServer(server);
                if (!validation.isValid) {
                    invalidServers.push(`${server}: ${validation.message}`);
                }
            }

            // Check for validation errors
            const allErrors = [...invalidTargets, ...invalidServers];
            if (allErrors.length > 0) {
                alert('Invalid input(s) detected:\n\n' + allErrors.join('\n') + '\n\nPlease correct these entries and try again.');
                return;
            }

            dnsProgress.style.display = 'block';
            dnsResults.innerHTML = 'Performing DNS lookups...';

            try {
                const response = await fetch('/api/dns-lookup', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        targets: targets,
                        servers: servers,
                        lookup_type: lookupType
                    })
                });

                const data = await response.json();

                if (data.success) {
                    displayDnsResults(data.results);
                } else {
                    dnsResults.innerHTML = `Error: ${data.error}`;
                }
            } catch (error) {
                console.error('DNS lookup error:', error);
                dnsResults.innerHTML = `Error performing DNS lookup: ${error.message}`;
            } finally {
                dnsProgress.style.display = 'none';
            }
        }

        function displayDnsResults(results) {
            const dnsResults = document.getElementById('dnsResults');
            let output = [];

            output.push('DNS LOOKUP RESULTS');
            output.push('==================');
            output.push('');

            for (const [target, targetData] of Object.entries(results)) {
                if (targetData.error) {
                    output.push(`${target} - ERROR: ${targetData.error}`);
                    output.push('');
                    continue;
                }

                // Process results from each DNS server
                for (const [server, serverResults] of Object.entries(targetData.servers)) {
                    const serverName = server === 'system_default' ? 'System DNS' : server;

                    if (serverResults.error) {
                        output.push(`${target} - ERROR: ${serverResults.error} - DNS Server: ${serverName}`);
                    } else if (serverResults.records && serverResults.records.length > 0) {
                        serverResults.records.forEach(record => {
                            // Simplified single-line format for A and PTR records
                            if (record.type === 'A' || record.type === 'PTR') {
                                const ttlInfo = record.ttl ? ` - TTL: ${record.ttl}` : '';
                                output.push(`${target} ${record.value} - DNS Server: ${serverName}${ttlInfo}`);
                            } else {
                                // Keep more detailed format for other record types
                                const ttlInfo = record.ttl ? ` - TTL: ${record.ttl}` : '';
                                output.push(`${target} - ${record.type}: ${record.value} - DNS Server: ${serverName}${ttlInfo}`);
                            }
                        });
                    } else {
                        output.push(`${target} - No records found - DNS Server: ${serverName}`);
                    }
                }
                output.push('');
            }

            dnsResults.textContent = output.join('\n');
        }

        function copyDnsResults() {
            const dnsResults = document.getElementById('dnsResults');
            const textToCopy = dnsResults.textContent;

            navigator.clipboard.writeText(textToCopy).then(() => {
                // Visual feedback on the copy button
                const copyButton = document.getElementById('copyDnsButton');
                const originalText = copyButton.textContent;
                copyButton.textContent = 'Copied!';
                copyButton.style.backgroundColor = '#4caf50';
                copyButton.style.color = 'white';

                setTimeout(() => {
                    copyButton.textContent = originalText;
                    copyButton.style.backgroundColor = '';
                    copyButton.style.color = '';
                }, 1000);
            }).catch(err => {
                console.error('Failed to copy text: ', err);
                alert('Failed to copy to clipboard');
            });
        }

        // Save/Load functionality for DNS server lists
        function saveDnsServerList() {
            const dnsServers = document.getElementById('dnsServers').value.trim();

            if (!dnsServers) {
                alert('No DNS servers to save');
                return;
            }

            document.getElementById('saveDnsServerModal').style.display = 'block';
            document.getElementById('dnsServerListName').focus();
        }

        function closeSaveDnsServerModal() {
            document.getElementById('saveDnsServerModal').style.display = 'none';
            document.getElementById('dnsServerListName').value = '';
        }

        function confirmSaveDnsServerList() {
            const listName = document.getElementById('dnsServerListName').value.trim();
            if (!listName) {
                alert('Please enter a list name');
                return;
            }

            const dnsServers = document.getElementById('dnsServers').value.trim();
            const serverList = dnsServers.split('\n').map(s => s.trim()).filter(s => s.length > 0);

            // Save to localStorage
            let savedDnsServerLists = JSON.parse(localStorage.getItem('savedDnsServerLists') || '{}');
            savedDnsServerLists[listName] = {
                servers: serverList,
                savedAt: new Date().toISOString()
            };
            localStorage.setItem('savedDnsServerLists', JSON.stringify(savedDnsServerLists));

            alert(`DNS server list "${listName}" saved successfully!`);
            closeSaveDnsServerModal();
        }

        function loadDnsServerList() {
            const savedDnsServerLists = JSON.parse(localStorage.getItem('savedDnsServerLists') || '{}');
            const savedListsDiv = document.getElementById('savedDnsServerLists');

            if (Object.keys(savedDnsServerLists).length === 0) {
                savedListsDiv.innerHTML = '<em>No saved DNS server lists found...</em>';
            } else {
                savedListsDiv.innerHTML = '';

                // Add predefined common DNS server lists
                const commonDnsLists = {
                    'Public DNS - Google': ['8.8.8.8', '8.8.4.4'],
                    'Public DNS - Cloudflare': ['1.1.1.1', '1.0.0.1'],
                    'Public DNS - OpenDNS': ['208.67.222.222', '208.67.220.220'],
                    'Public DNS - Quad9': ['9.9.9.9', '149.112.112.112'],
                    'Public DNS - All Combined': ['8.8.8.8', '1.1.1.1', '208.67.222.222', '9.9.9.9']
                };

                // Add common DNS lists section
                const commonHeader = document.createElement('div');
                commonHeader.innerHTML = '<strong style="color: #007cba;">Common DNS Servers:</strong>';
                commonHeader.style.marginBottom = '10px';
                savedListsDiv.appendChild(commonHeader);

                for (const [listName, servers] of Object.entries(commonDnsLists)) {
                    const savedItem = document.createElement('div');
                    savedItem.className = 'saved-item';
                    savedItem.style.borderColor = '#007cba';

                    const itemInfo = document.createElement('div');
                    itemInfo.innerHTML = `
                        <div class="saved-item-name">${listName}</div>
                        <div class="saved-item-count">${servers.length} servers</div>
                    `;

                    savedItem.appendChild(itemInfo);
                    savedItem.onclick = () => confirmLoadDnsServerList(listName, servers);
                    savedListsDiv.appendChild(savedItem);
                }

                // Add separator
                const separator = document.createElement('div');
                separator.innerHTML = '<hr style="margin: 15px 0;"><strong style="color: #28a745;">Saved Lists:</strong>';
                separator.style.marginBottom = '10px';
                savedListsDiv.appendChild(separator);

                // Add saved DNS lists
                for (const [listName, listData] of Object.entries(savedDnsServerLists)) {
                    const savedItem = document.createElement('div');
                    savedItem.className = 'saved-item';

                    const itemInfo = document.createElement('div');
                    itemInfo.innerHTML = `
                        <div class="saved-item-name">${listName}</div>
                        <div class="saved-item-count">${listData.servers.length} servers - Saved: ${new Date(listData.savedAt).toLocaleDateString()}</div>
                    `;

                    const deleteBtn = document.createElement('span');
                    deleteBtn.className = 'delete-saved';
                    deleteBtn.innerHTML = 'âœ—';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        deleteDnsServerList(listName);
                    };

                    savedItem.appendChild(itemInfo);
                    savedItem.appendChild(deleteBtn);

                    savedItem.onclick = () => confirmLoadDnsServerList(listName, listData.servers);
                    savedListsDiv.appendChild(savedItem);
                }
            }

            document.getElementById('loadDnsServerModal').style.display = 'block';
        }

        function closeLoadDnsServerModal() {
            document.getElementById('loadDnsServerModal').style.display = 'none';
        }

        function confirmLoadDnsServerList(listName, serverList) {
            const dnsServersTextarea = document.getElementById('dnsServers');
            const currentServers = dnsServersTextarea.value.trim();

            if (currentServers) {
                if (!confirm(`This will replace your current DNS server list. Continue?`)) {
                    return;
                }
            }

            dnsServersTextarea.value = serverList.join('\n');
            closeLoadDnsServerModal();
            alert(`DNS server list "${listName}" loaded successfully!`);
        }

        function deleteDnsServerList(listName) {
            if (confirm(`Delete DNS server list "${listName}"?`)) {
                let savedDnsServerLists = JSON.parse(localStorage.getItem('savedDnsServerLists') || '{}');
                delete savedDnsServerLists[listName];
                localStorage.setItem('savedDnsServerLists', JSON.stringify(savedDnsServerLists));
                loadDnsServerList(); // Refresh the modal
            }
        }

        // Add Enter key support for DNS server save modal
        document.getElementById('dnsServerListName').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                confirmSaveDnsServerList();
            }
        });

        // Add Enter key support for traceroute targets save modal
        document.getElementById('tracerouteTargetsListName').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                confirmSaveTracerouteTargets();
            }
        });

        // Traceroute functionality
        let tracerouteResultsData = {};
        let tracerouteEventSource = null;
        let currentTracerouteData = {};

        // Function to validate hostname or IP address for traceroute
        function validateTracerouteTarget(target) {
            // Remove any whitespace
            target = target.trim();

            // Check for spaces or invalid characters
            if (target.includes(' ')) {
                return { isValid: false, message: 'Spaces are not allowed' };
            }

            // IPv4 address pattern
            const ipv4Pattern = /^(\d{1,3}\.){3}\d{1,3}$/;

            // IPv6 address pattern (simplified)
            const ipv6Pattern = /^([0-9a-fA-F]{0,4}:){2,7}[0-9a-fA-F]{0,4}$/;

            // Hostname/domain pattern - only allows letters, numbers, dots, and hyphens
            // Must start and end with alphanumeric, can contain dots and hyphens in the middle
            const hostnamePattern = /^[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?)*$/;

            // Check if it's an IPv4 address
            if (ipv4Pattern.test(target)) {
                // Validate IPv4 octets are in range 0-255
                const octets = target.split('.');
                for (const octet of octets) {
                    const num = parseInt(octet);
                    if (num < 0 || num > 255) {
                        return { isValid: false, message: 'Invalid IPv4 address (octets must be 0-255)' };
                    }
                }
                return { isValid: true, type: 'ipv4' };
            }

            // Check if it's an IPv6 address
            if (ipv6Pattern.test(target) || target.includes(':')) {
                // Basic IPv6 validation
                if (target.match(/[^0-9a-fA-F:]/)) {
                    return { isValid: false, message: 'Invalid IPv6 address (contains invalid characters)' };
                }
                return { isValid: true, type: 'ipv6' };
            }

            // Check if it's a valid hostname/domain
            if (hostnamePattern.test(target)) {
                // Additional hostname validations
                if (target.length > 253) {
                    return { isValid: false, message: 'Hostname too long (max 253 characters)' };
                }

                // Check each label (part between dots)
                const labels = target.split('.');
                for (const label of labels) {
                    if (label.length > 63) {
                        return { isValid: false, message: 'Domain label too long (max 63 characters per label)' };
                    }
                    if (label.startsWith('-') || label.endsWith('-')) {
                        return { isValid: false, message: 'Domain labels cannot start or end with hyphens' };
                    }
                }

                return { isValid: true, type: 'hostname' };
            }

            // Check for common invalid characters
            const invalidChars = target.match(/[^a-zA-Z0-9.\-:]/);
            if (invalidChars) {
                return {
                    isValid: false,
                    message: `Invalid character(s) found: ${invalidChars.join(', ')}. Only letters, numbers, dots, hyphens, and colons (for IPv6) are allowed.`
                };
            }

            return { isValid: false, message: 'Invalid format. Please enter a valid IP address or hostname.' };
        }

        // Function to validate DNS lookup target (hostname, IP, or domain)
        function validateDnsTarget(target, lookupType) {
            // Remove any whitespace
            target = target.trim();

            // Check for spaces or invalid characters
            if (target.includes(' ')) {
                return { isValid: false, message: 'Spaces are not allowed' };
            }

            // IPv4 address pattern
            const ipv4Pattern = /^(\d{1,3}\.){3}\d{1,3}$/;

            // IPv6 address pattern (simplified)
            const ipv6Pattern = /^([0-9a-fA-F]{0,4}:){2,7}[0-9a-fA-F]{0,4}$/;

            // Hostname/domain pattern - only allows letters, numbers, dots, and hyphens
            const hostnamePattern = /^[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?)*$/;

            // Check if it's an IPv4 address
            if (ipv4Pattern.test(target)) {
                // Validate IPv4 octets are in range 0-255
                const octets = target.split('.');
                for (const octet of octets) {
                    const num = parseInt(octet);
                    if (num < 0 || num > 255) {
                        return { isValid: false, message: 'Invalid IPv4 address (octets must be 0-255)' };
                    }
                }

                // IP addresses are valid for all lookup types
                return { isValid: true, type: 'ipv4' };
            }

            // Check if it's an IPv6 address
            if (ipv6Pattern.test(target) || target.includes(':')) {
                // Basic IPv6 validation
                if (target.match(/[^0-9a-fA-F:]/)) {
                    return { isValid: false, message: 'Invalid IPv6 address (contains invalid characters)' };
                }

                // IPv6 addresses are valid for all lookup types
                return { isValid: true, type: 'ipv6' };
            }

            // Check if it's a valid hostname/domain
            if (hostnamePattern.test(target)) {
                // Additional hostname validations
                if (target.length > 253) {
                    return { isValid: false, message: 'Hostname too long (max 253 characters)' };
                }

                // Check each label (part between dots)
                const labels = target.split('.');
                for (const label of labels) {
                    if (label.length > 63) {
                        return { isValid: false, message: 'Domain label too long (max 63 characters per label)' };
                    }
                    if (label.startsWith('-') || label.endsWith('-')) {
                        return { isValid: false, message: 'Domain labels cannot start or end with hyphens' };
                    }
                }

                // Hostnames are valid for all lookup types
                return { isValid: true, type: 'hostname' };
            }

            // Check for common invalid characters
            const invalidChars = target.match(/[^a-zA-Z0-9.\-:]/);
            if (invalidChars) {
                return {
                    isValid: false,
                    message: `Invalid character(s) found: ${invalidChars.join(', ')}. Only letters, numbers, dots, hyphens, and colons (for IPv6) are allowed.`
                };
            }

            return { isValid: false, message: 'Invalid format. Please enter a valid IP address or hostname.' };
        }

        // Function to validate DNS server address
        function validateDnsServer(server) {
            server = server.trim();

            // Check for spaces
            if (server.includes(' ')) {
                return { isValid: false, message: 'Spaces are not allowed in DNS server addresses' };
            }

            // IPv4 address pattern
            const ipv4Pattern = /^(\d{1,3}\.){3}\d{1,3}$/;

            // IPv6 address pattern (simplified)
            const ipv6Pattern = /^([0-9a-fA-F]{0,4}:){2,7}[0-9a-fA-F]{0,4}$/;

            // Check if it's an IPv4 address
            if (ipv4Pattern.test(server)) {
                const octets = server.split('.');
                for (const octet of octets) {
                    const num = parseInt(octet);
                    if (num < 0 || num > 255) {
                        return { isValid: false, message: 'Invalid IPv4 address (octets must be 0-255)' };
                    }
                }
                return { isValid: true, type: 'ipv4' };
            }

            // Check if it's an IPv6 address
            if (ipv6Pattern.test(server) || server.includes(':')) {
                if (server.match(/[^0-9a-fA-F:]/)) {
                    return { isValid: false, message: 'Invalid IPv6 address (contains invalid characters)' };
                }
                return { isValid: true, type: 'ipv6' };
            }

            return { isValid: false, message: 'DNS servers must be valid IP addresses' };
        }

        // Function to validate DNS input in real-time
        function validateDnsInput() {
            const textarea = document.getElementById('dnsInput');
            const serversTextarea = document.getElementById('dnsServers');
            const lookupType = document.getElementById('lookupType').value;
            const validationDiv = document.getElementById('dnsValidation');
            const serversValidationDiv = document.getElementById('dnsServersValidation');

            const input = textarea.value.trim();
            const serversInput = serversTextarea.value.trim();

            // Validate targets
            if (!input) {
                validationDiv.innerHTML = '';
                textarea.style.borderColor = '';
            } else {
                const targets = input.split('\n').map(line => line.trim()).filter(line => line.length > 0);
                const invalidTargets = [];
                const validTargets = [];

                for (const target of targets) {
                    const validation = validateDnsTarget(target, lookupType);
                    if (!validation.isValid) {
                        invalidTargets.push(`${target}: ${validation.message}`);
                    } else {
                        validTargets.push(`${target} (${validation.type})`);
                    }
                }

                if (invalidTargets.length > 0) {
                    textarea.style.borderColor = '#dc3545';
                    validationDiv.innerHTML = `
                        <div style="color: #dc3545; font-size: 12px; font-family: monospace;">
                            <strong>âŒ ${invalidTargets.length} invalid target(s):</strong><br>
                            ${invalidTargets.slice(0, 3).join('<br>')}
                            ${invalidTargets.length > 3 ? `<br>... and ${invalidTargets.length - 3} more` : ''}
                        </div>
                    `;
                } else {
                    textarea.style.borderColor = '#28a745';
                    validationDiv.innerHTML = `
                        <div style="color: #28a745; font-size: 12px; font-family: monospace;">
                            <strong>âœ… ${validTargets.length} valid target(s)</strong>
                            ${validTargets.length <= 3 ? '<br>' + validTargets.join('<br>') : ''}
                        </div>
                    `;
                }
            }

            // Validate DNS servers
            if (!serversInput) {
                serversValidationDiv.innerHTML = '<div style="color: #6c757d; font-size: 12px;">Using system default DNS servers</div>';
                serversTextarea.style.borderColor = '';
            } else {
                const servers = serversInput.split('\n').map(line => line.trim()).filter(line => line.length > 0);
                const invalidServers = [];
                const validServers = [];

                for (const server of servers) {
                    const validation = validateDnsServer(server);
                    if (!validation.isValid) {
                        invalidServers.push(`${server}: ${validation.message}`);
                    } else {
                        validServers.push(`${server} (${validation.type})`);
                    }
                }

                if (invalidServers.length > 0) {
                    serversTextarea.style.borderColor = '#dc3545';
                    serversValidationDiv.innerHTML = `
                        <div style="color: #dc3545; font-size: 12px; font-family: monospace;">
                            <strong>âŒ ${invalidServers.length} invalid DNS server(s):</strong><br>
                            ${invalidServers.slice(0, 2).join('<br>')}
                            ${invalidServers.length > 2 ? `<br>... and ${invalidServers.length - 2} more` : ''}
                        </div>
                    `;
                } else {
                    serversTextarea.style.borderColor = '#28a745';
                    serversValidationDiv.innerHTML = `
                        <div style="color: #28a745; font-size: 12px; font-family: monospace;">
                            <strong>âœ… ${validServers.length} valid DNS server(s)</strong>
                            ${validServers.length <= 3 ? '<br>' + validServers.join('<br>') : ''}
                        </div>
                    `;
                }
            }
        }

        // Function to validate traceroute input in real-time
        function validateTracerouteInput() {
            const textarea = document.getElementById('tracerouteTargets');
            const validationDiv = document.getElementById('tracerouteValidation');
            const input = textarea.value.trim();

            if (!input) {
                validationDiv.innerHTML = '';
                textarea.style.borderColor = '';
                return;
            }

            const targets = input.split('\n').map(line => line.trim()).filter(line => line.length > 0);
            const invalidTargets = [];
            const validTargets = [];

            for (const target of targets) {
                const validation = validateTracerouteTarget(target);
                if (!validation.isValid) {
                    invalidTargets.push(`${target}: ${validation.message}`);
                } else {
                    validTargets.push(`${target} (${validation.type})`);
                }
            }

            if (invalidTargets.length > 0) {
                textarea.style.borderColor = '#dc3545';
                validationDiv.innerHTML = `
                    <div style="color: #dc3545; font-size: 12px; font-family: monospace;">
                        <strong>âŒ ${invalidTargets.length} invalid target(s):</strong><br>
                        ${invalidTargets.slice(0, 3).join('<br>')}
                        ${invalidTargets.length > 3 ? `<br>... and ${invalidTargets.length - 3} more` : ''}
                    </div>
                `;
            } else {
                textarea.style.borderColor = '#28a745';
                validationDiv.innerHTML = `
                    <div style="color: #28a745; font-size: 12px; font-family: monospace;">
                        <strong>âœ… ${validTargets.length} valid target(s)</strong>
                        ${validTargets.length <= 5 ? ': ' + validTargets.join(', ') : ''}
                    </div>
                `;
            }
        }

        async function performTraceroute() {
            const targetsInput = document.getElementById('tracerouteTargets').value.trim();
            const maxHops = parseInt(document.getElementById('maxHops').value);
            const timeout = parseInt(document.getElementById('traceTimeout').value);
            const probesPerHop = parseInt(document.getElementById('probesPerHop').value);
            const packetSize = parseInt(document.getElementById('packetSize').value);
            const translateIPs = document.getElementById('translateIPs').checked;
            const resolveHostnames = document.getElementById('resolveHostnames').checked;

            const tracerouteResults = document.getElementById('tracerouteResults');
            const tracerouteProgress = document.getElementById('tracerouteProgress');
            const tracerouteProgressDetail = document.getElementById('tracerouteProgressDetail');

            if (!targetsInput) {
                alert('Please enter at least one target host');
                return;
            }

            // Parse input - split by lines and filter empty lines
            const targets = targetsInput.split('\n').map(line => line.trim()).filter(line => line.length > 0);

            // Validate all targets
            const invalidTargets = [];
            for (const target of targets) {
                const validation = validateTracerouteTarget(target);
                if (!validation.isValid) {
                    invalidTargets.push(`${target}: ${validation.message}`);
                }
            }

            if (invalidTargets.length > 0) {
                alert('Invalid target(s) detected:\n\n' + invalidTargets.join('\n') + '\n\nPlease correct these entries and try again.');
                return;
            }

            // Close any existing SSE connection
            if (tracerouteEventSource) {
                tracerouteEventSource.close();
            }

            // Reset data
            currentTracerouteData = {};
            tracerouteResultsData = {};

            tracerouteProgress.style.display = 'block';
            tracerouteProgressDetail.textContent = `Starting traceroutes to ${targets.length} targets...`;
            tracerouteResults.innerHTML = '';

            // Initialize display for each target
            targets.forEach(target => {
                currentTracerouteData[target] = { hops: [] };
            });

            // Build query parameters
            const params = new URLSearchParams({
                targets: targets.join(','),
                max_hops: maxHops,
                timeout: timeout,
                probes_per_hop: probesPerHop,
                packet_size: packetSize,
                translate_ips: translateIPs,
                resolve_hostnames: resolveHostnames
            });

            // Create SSE connection for real-time updates
            tracerouteEventSource = new EventSource(`/api/traceroute-stream?${params}`);

            tracerouteEventSource.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    handleTracerouteUpdate(data, translateIPs);
                } catch (error) {
                    console.error('Error parsing SSE data:', error);
                }
            };

            tracerouteEventSource.onerror = function(error) {
                console.error('SSE error:', error);
                tracerouteEventSource.close();
                tracerouteProgress.style.display = 'none';
            };
        }

        function handleTracerouteUpdate(data, translateIPs) {
            const tracerouteResults = document.getElementById('tracerouteResults');
            const tracerouteProgressDetail = document.getElementById('tracerouteProgressDetail');

            switch(data.type) {
                case 'init':
                    tracerouteResults.innerHTML = '<div style="font-weight: bold; margin-bottom: 10px;">TRACEROUTE RESULTS (Real-time)</div>';
                    break;

                case 'start':
                    tracerouteProgressDetail.textContent = data.message;
                    // Use display_target if available (includes resolved IP), otherwise use original target
                    const displayTarget = data.display_target || data.target;
                    // Create separate div for this target if it doesn't exist
                    let targetDiv = document.getElementById(`traceroute-${data.target.replace(/[^a-zA-Z0-9]/g, '-')}`);
                    if (!targetDiv) {
                        targetDiv = document.createElement('div');
                        targetDiv.id = `traceroute-${data.target.replace(/[^a-zA-Z0-9]/g, '-')}`;
                        targetDiv.style.cssText = 'margin-bottom: 20px; padding: 10px; border: 1px solid #ccc; background-color: #f9f9f9; font-family: monospace;';

                        const targetHeader = document.createElement('div');
                        targetHeader.style.cssText = 'font-weight: bold; color: #333; margin-bottom: 5px; border-bottom: 1px solid #ddd; padding-bottom: 5px;';
                        targetHeader.textContent = `Target: ${displayTarget}`;
                        targetDiv.appendChild(targetHeader);

                        const hopsContainer = document.createElement('pre');
                        hopsContainer.id = `hops-${data.target.replace(/[^a-zA-Z0-9]/g, '-')}`;
                        hopsContainer.style.cssText = 'margin: 0; white-space: pre-wrap; font-family: monospace;';
                        targetDiv.appendChild(hopsContainer);

                        tracerouteResults.appendChild(targetDiv);
                    }
                    break;

                case 'hop':
                    // Find the target's div and add hop
                    const targetId = `hops-${data.target.replace(/[^a-zA-Z0-9]/g, '-')}`;
                    const hopsContainer = document.getElementById(targetId);

                    if (hopsContainer) {
                        const hop = data.hop;
                        let hopLine = `${hop.hop_num.toString().padStart(2)}  `;

                        if (hop.probes && hop.probes.length > 0) {
                            hop.probes.forEach(probe => {
                                if (probe.success) {
                                    let probeInfo = '';

                                    // Show IP or hostname
                                    if (probe.hostname && probe.hostname !== probe.ip) {
                                        probeInfo += `${probe.hostname} (${probe.ip})`;
                                    } else {
                                        probeInfo += probe.ip;
                                    }

                                    // Add translated info if available and enabled
                                    if (translateIPs && probe.translated_info) {
                                        probeInfo += ` [${probe.translated_info}]`;
                                    }

                                    // Add RTT
                                    probeInfo += `  ${probe.rtt} ms`;

                                    hopLine += probeInfo + '  ';
                                } else {
                                    hopLine += '*  ';
                                }
                            });
                        } else {
                            hopLine += '* * *';
                        }

                        // Append hop line to target-specific container
                        hopsContainer.textContent += hopLine + '\n';
                    }

                    // Store hop data
                    if (!currentTracerouteData[data.target]) {
                        currentTracerouteData[data.target] = { hops: [] };
                    }
                    currentTracerouteData[data.target].hops.push(hop);
                    break;

                case 'complete':
                    tracerouteProgressDetail.textContent = data.message;
                    // Add completion message to target's div
                    const completedTargetId = `hops-${data.target.replace(/[^a-zA-Z0-9]/g, '-')}`;
                    const completedHopsContainer = document.getElementById(completedTargetId);
                    if (completedHopsContainer) {
                        completedHopsContainer.textContent += '\nTraceroute completed.\n';
                    }
                    // Store completed data
                    tracerouteResultsData[data.target] = currentTracerouteData[data.target];
                    break;

                case 'error':
                    // Add error to target's div or general results if no specific target
                    if (data.target) {
                        const errorTargetId = `hops-${data.target.replace(/[^a-zA-Z0-9]/g, '-')}`;
                        const errorHopsContainer = document.getElementById(errorTargetId);
                        if (errorHopsContainer) {
                            errorHopsContainer.textContent += `Error: ${data.error}\n`;
                        }
                    } else {
                        const errorDiv = document.createElement('div');
                        errorDiv.style.cssText = 'color: red; margin-bottom: 10px; padding: 5px; background-color: #ffe6e6; border: 1px solid #ff9999;';
                        errorDiv.textContent = `Error: ${data.error}`;
                        tracerouteResults.appendChild(errorDiv);
                    }
                    break;

                case 'debug':
                    console.log(`DEBUG [${data.target}]: Raw line: "${data.raw_line}"`);
                    break;

                case 'parse_fail':
                    console.log(`PARSE FAIL [${data.target}]: Could not parse line: "${data.line}"`);
                    // Display the unparsed line as a fallback in target's div
                    const parseFailTargetId = `hops-${data.target.replace(/[^a-zA-Z0-9]/g, '-')}`;
                    const parseFailHopsContainer = document.getElementById(parseFailTargetId);
                    if (parseFailHopsContainer && data.line.match(/^\s*\d+/)) {
                        parseFailHopsContainer.textContent += `${data.line}\n`;
                    }
                    break;

                case 'all_complete':
                    document.getElementById('tracerouteProgress').style.display = 'none';
                    tracerouteEventSource.close();
                    break;
            }

            // Auto-scroll to bottom
            const resultsDiv = document.getElementById('tracerouteResults');
            resultsDiv.scrollTop = resultsDiv.scrollHeight;
        }

        function displayTracerouteResults(results, translateIPs) {
            const tracerouteResults = document.getElementById('tracerouteResults');
            let output = [];

            output.push('TRACEROUTE RESULTS');
            output.push('=' .repeat(80));
            output.push('');

            for (const [target, targetData] of Object.entries(results)) {
                // Use display_target if available (includes resolved IP), otherwise use original target
                const displayTarget = targetData.display_target || target;
                output.push(`Target: ${displayTarget}`);
                output.push('-'.repeat(40));

                if (targetData.error) {
                    output.push(`Error: ${targetData.error}`);
                    output.push('');
                    continue;
                }

                if (targetData.hops && targetData.hops.length > 0) {
                    targetData.hops.forEach(hop => {
                        let hopLine = `${hop.hop_num.toString().padStart(2)}  `;

                        if (hop.probes && hop.probes.length > 0) {
                            hop.probes.forEach(probe => {
                                if (probe.success) {
                                    let probeInfo = '';

                                    // Show IP or hostname
                                    if (probe.hostname && probe.hostname !== probe.ip) {
                                        probeInfo += `${probe.hostname} (${probe.ip})`;
                                    } else {
                                        probeInfo += probe.ip;
                                    }

                                    // Add translated info if available and enabled
                                    if (translateIPs && probe.translated_info) {
                                        probeInfo += ` [${probe.translated_info}]`;
                                    }

                                    // Add RTT
                                    probeInfo += `  ${probe.rtt} ms`;

                                    hopLine += probeInfo + '  ';
                                } else {
                                    hopLine += '*  ';
                                }
                            });
                        } else {
                            hopLine += '* * *';
                        }

                        output.push(hopLine);
                    });
                } else {
                    output.push('No hops found or traceroute failed');
                }

                output.push('');
                output.push('');
            }

            tracerouteResults.textContent = output.join('\n');
        }

        function copyTracerouteResults() {
            const tracerouteResults = document.getElementById('tracerouteResults');
            const textToCopy = tracerouteResults.textContent;

            navigator.clipboard.writeText(textToCopy).then(() => {
                // Visual feedback on the copy button
                const copyButton = document.getElementById('copyTracerouteButton');
                const originalText = copyButton.textContent;
                copyButton.textContent = 'Copied!';
                copyButton.style.backgroundColor = '#4caf50';
                copyButton.style.color = 'white';

                setTimeout(() => {
                    copyButton.textContent = originalText;
                    copyButton.style.backgroundColor = '';
                    copyButton.style.color = '';
                }, 1000);
            }).catch(err => {
                console.error('Failed to copy text: ', err);
                alert('Failed to copy to clipboard');
            });
        }

        function downloadTracerouteResults() {
            const tracerouteResults = document.getElementById('tracerouteResults').textContent;
            const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
            const filename = `traceroute_results_${timestamp}.txt`;

            const blob = new Blob([tracerouteResults], { type: 'text/plain' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            a.remove();
        }

        // Toggle IP translation in real-time
        document.getElementById('translateIPs').addEventListener('change', function() {
            if (tracerouteResultsData && Object.keys(tracerouteResultsData).length > 0) {
                // Regenerate display with current data
                const translateIPs = this.checked;
                const tracerouteResults = document.getElementById('tracerouteResults');
                let output = [];

                output.push('TRACEROUTE RESULTS');
                output.push('='.repeat(80));
                output.push('');

                for (const [target, targetData] of Object.entries(tracerouteResultsData)) {
                    output.push(`Target: ${target}`);
                    output.push('-'.repeat(40));

                    if (targetData.hops && targetData.hops.length > 0) {
                        targetData.hops.forEach(hop => {
                            let hopLine = `${hop.hop_num.toString().padStart(2)}  `;

                            if (hop.probes && hop.probes.length > 0) {
                                hop.probes.forEach(probe => {
                                    if (probe.success) {
                                        let probeInfo = '';

                                        // Show IP or hostname
                                        if (probe.hostname && probe.hostname !== probe.ip) {
                                            probeInfo += `${probe.hostname} (${probe.ip})`;
                                        } else {
                                            probeInfo += probe.ip;
                                        }

                                        // Add translated info if available and enabled
                                        if (translateIPs && probe.translated_info) {
                                            probeInfo += ` [${probe.translated_info}]`;
                                        }

                                        // Add RTT
                                        probeInfo += `  ${probe.rtt} ms`;

                                        hopLine += probeInfo + '  ';
                                    } else {
                                        hopLine += '*  ';
                                    }
                                });
                            } else {
                                hopLine += '* * *';
                            }

                            output.push(hopLine);
                        });
                    } else {
                        output.push('No hops found or traceroute failed');
                    }

                    output.push('');
                    output.push('');
                }

                tracerouteResults.textContent = output.join('\n');
            }
        });

        // Debounced translation function
        function scheduleTranslation() {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(translateText, 500); // Wait 500ms after user stops typing
        }

        async function translateText() {
            const text = inputText.value.trim();

            if (!text) {
                outputArea.innerHTML = '<em>Your translated text will appear here...</em>';
                return;
            }

            loadingIndicator.style.display = 'block';

            try {
                const response = await fetch(`/api/translate-ip?text=${encodeURIComponent(text)}`);
                const data = await response.json();

                outputArea.innerHTML = data.translated_text || text;

                // Attach event listeners to enhanced IPs
                attachTooltipHandlers();

            } catch (error) {
                console.error('Translation error:', error);
                outputArea.innerHTML = text;
            } finally {
                loadingIndicator.style.display = 'none';
            }
        }

        function attachTooltipHandlers() {
            const enhancedIPs = document.querySelectorAll('.ip-enhanced');

            enhancedIPs.forEach(element => {
                element.addEventListener('mouseenter', showTooltip);
                element.addEventListener('mouseleave', hideTooltip);
                element.addEventListener('click', handleIPClick);
            });
        }

        function showTooltip(event) {
            const element = event.target;
            const tooltipDataStr = element.getAttribute('data-tooltip').replace(/&quot;/g, '"');
            const tooltipData = JSON.parse(tooltipDataStr);
            const mgmtIP = element.getAttribute('data-mgmt-ip');

            const tooltipContent = `
                <div>
                    <strong>${tooltipData.hostname}</strong><br>
                    <strong>Interface:</strong> ${tooltipData.interface_name}<br>
                    <strong>Description:</strong> ${tooltipData.interface_description}<br>
                    <strong>Management IP:</strong> ${mgmtIP}<br>
                    <strong>Vendor:</strong> ${tooltipData.device_vendor}<br>
                    <strong>Status:</strong> ${tooltipData.interface_status}<br>
                    <a href="ssh://${mgmtIP}" onclick="event.stopPropagation();">SSH to ${mgmtIP}</a>
                </div>
            `;

            tooltip.innerHTML = tooltipContent;
            tooltip.style.display = 'block';

            // Position tooltip
            const rect = element.getBoundingClientRect();
            tooltip.style.left = rect.left + 'px';
            tooltip.style.top = (rect.bottom + 10) + 'px';
        }

        function hideTooltip() {
            tooltip.style.display = 'none';
        }

        function handleIPClick(event) {
            const element = event.target;
            const mgmtIP = element.getAttribute('data-mgmt-ip');

            // Copy management IP to clipboard
            navigator.clipboard.writeText(mgmtIP).then(() => {
                // Brief visual feedback
                element.style.backgroundColor = 'yellow';
                setTimeout(() => {
                    element.style.backgroundColor = '';
                }, 200);
            });
        }

        function copyTranslatedOutput() {
            const outputArea = document.getElementById('outputArea');
            // Get the text content without HTML tags
            const textToCopy = outputArea.innerText || outputArea.textContent;

            navigator.clipboard.writeText(textToCopy).then(() => {
                // Visual feedback on the copy button
                const copyButton = document.getElementById('copyButton');
                const originalText = copyButton.textContent;
                copyButton.textContent = 'Copied!';
                copyButton.style.backgroundColor = '#4caf50';
                copyButton.style.color = 'white';

                setTimeout(() => {
                    copyButton.textContent = originalText;
                    copyButton.style.backgroundColor = '';
                    copyButton.style.color = '';
                }, 1000);
            }).catch(err => {
                console.error('Failed to copy text: ', err);
                alert('Failed to copy to clipboard');
            });
        }

        // Event listeners
        inputText.addEventListener('input', scheduleTranslation);
        inputText.addEventListener('paste', () => {
            setTimeout(scheduleTranslation, 10); // Small delay to let paste complete
        });

        // Hide tooltip when clicking elsewhere
        document.addEventListener('click', (event) => {
            if (!event.target.closest('.ip-enhanced')) {
                hideTooltip();
            }
        });

        // Sample text for demonstration
        inputText.addEventListener('focus', function() {
            if (this.value === '') {
                this.placeholder = 'insert command output here..';
            }
        });

        inputText.addEventListener('blur', function() {
            this.placeholder = 'Paste your text here... IP addresses will be automatically translated to show hostname and interface information.';
        });
    </script>
</body>
</html>