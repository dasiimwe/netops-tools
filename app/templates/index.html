<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>netops Toolkit</title>
    <style>
        .tabs {
            display: flex;
            border-bottom: 1px solid #ccc;
            margin-bottom: 20px;
        }
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border: 1px solid #ccc;
            border-bottom: none;
            background: #f0f0f0;
            margin-right: 5px;
        }
        .tab.active {
            background: white;
            border-bottom: 1px solid white;
            margin-bottom: -1px;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .device-list, .command-list {
            border: 1px solid #ccc;
            min-height: 100px;
            padding: 10px;
            margin: 10px 0;
            font-family: monospace;
        }
        .add-item {
            margin: 5px 0;
        }
        .remove-btn {
            color: red;
            cursor: pointer;
            margin-left: 10px;
        }
        .run-section {
            background: #f9f9f9;
            padding: 15px;
            border: 1px solid #ddd;
            margin: 20px 0;
        }
        .output-section {
            margin-top: 20px;
        }
        .device-output {
            border: 1px solid #ccc;
            margin: 10px 0;
            padding: 10px;
        }
        .device-output h4 {
            margin: 0 0 10px 0;
            color: #333;
        }
        .command-output {
            background: #f5f5f5;
            border: 1px solid #ddd;
            padding: 10px;
            margin: 5px 0;
            font-family: monospace;
            white-space: pre-wrap;
            overflow-x: auto;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }
        .modal-content {
            background-color: white;
            margin: 15% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 400px;
            border-radius: 5px;
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .close {
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        .close:hover {
            color: black;
        }
        .saved-item {
            padding: 8px;
            margin: 5px 0;
            background: #f9f9f9;
            border: 1px solid #ddd;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .saved-item:hover {
            background: #e9e9e9;
        }
        .saved-item-name {
            font-weight: bold;
        }
        .saved-item-count {
            color: #666;
            font-size: 12px;
        }
        .delete-saved {
            color: red;
            cursor: pointer;
            padding: 2px 6px;
        }
        .command-input-valid {
            border: 2px solid #28a745 !important;
            background-color: #f8fff8 !important;
        }
        .command-input-invalid {
            border: 2px solid #dc3545 !important;
            background-color: #fff5f5 !important;
        }
        .command-help-text {
            font-size: 11px;
            color: #666;
            margin-top: 2px;
            line-height: 1.2;
        }
        .insights-tab {
            display: inline-block;
            padding: 6px 12px;
            margin-right: 4px;
            background: #f8f9fa;
            border: 1px solid #ddd;
            cursor: pointer;
            font-size: 12px;
            border-radius: 3px;
        }
        .insights-tab.active {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }
        .insights-tab-content {
            display: none;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 3px;
            background: #fff;
            margin-top: 5px;
        }
        .insights-tab-content.active {
            display: block;
        }
        .insights-stat {
            text-align: center;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 3px;
        }
        .insights-stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #007bff;
        }
        .insights-stat-label {
            font-size: 11px;
            color: #666;
            margin-top: 2px;
        }
        .manage-modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 700px;
            max-height: 80vh;
            overflow-y: auto;
            border-radius: 5px;
        }
        .manage-item {
            padding: 10px;
            margin: 10px 0;
            background: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 3px;
        }
        .manage-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .manage-item-title {
            font-weight: bold;
            font-size: 14px;
            flex: 1;
        }
        .manage-item-actions {
            display: flex;
            gap: 5px;
        }
        .manage-item-content {
            margin-top: 10px;
        }
        .manage-item-content textarea {
            width: 100%;
            min-height: 80px;
            font-family: monospace;
            font-size: 12px;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }
        .manage-item-content input[type="text"] {
            width: 100%;
            padding: 5px;
            margin-bottom: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }
        .btn-sm {
            padding: 3px 8px;
            font-size: 11px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        .btn-edit {
            background: #007cba;
            color: white;
        }
        .btn-save {
            background: #28a745;
            color: white;
        }
        .btn-cancel {
            background: #6c757d;
            color: white;
        }
        .btn-delete {
            background: #dc3545;
            color: white;
        }
        .manage-source-label {
            font-size: 10px;
            color: #666;
            background: #e9ecef;
            padding: 2px 6px;
            border-radius: 3px;
            margin-left: 10px;
        }
        .manage-item.editing {
            background: #fff8e1;
            border-color: #ffc107;
        }
    </style>
</head>
<body>
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 style="margin: 0;">netops Toolkit</h2>
        <a href="{{ url_for('main.admin') }}" style="color: #0000EE; text-decoration: underline;">Admin Dashboard ‚Üí</a>
    </div>

    <div class="tabs">
        {% if tool_visibility.ip_translator %}
        <div class="tab active" onclick="showTab('ip-translator')">IP Translator</div>
        {% endif %}
        {% if tool_visibility.command_runner %}
        <div class="tab{% if not tool_visibility.ip_translator %} active{% endif %}" onclick="showTab('command-runner')">Command Run Tool</div>
        {% endif %}
        {% if tool_visibility.dns_lookup %}
        <div class="tab{% if not tool_visibility.ip_translator and not tool_visibility.command_runner %} active{% endif %}" onclick="showTab('dns-lookup')">DNS Lookup</div>
        {% endif %}
        {% if tool_visibility.bgp_looking_glass %}
        <div class="tab{% if not tool_visibility.ip_translator and not tool_visibility.command_runner and not tool_visibility.dns_lookup %} active{% endif %}" onclick="showTab('bgp-looking-glass')">BGP Looking Glass</div>
        {% endif %}
        {% if tool_visibility.traceroute %}
        <div class="tab{% if not tool_visibility.ip_translator and not tool_visibility.command_runner and not tool_visibility.dns_lookup and not tool_visibility.bgp_looking_glass %} active{% endif %}" onclick="showTab('traceroute')">Traceroute</div>
        {% endif %}
        {% if tool_visibility.url_insights %}
        <div class="tab{% if not tool_visibility.ip_translator and not tool_visibility.command_runner and not tool_visibility.dns_lookup and not tool_visibility.bgp_looking_glass and not tool_visibility.traceroute %} active{% endif %}" onclick="showTab('url-insights')">URL/App Insights</div>
        {% endif %}
        {% if tool_visibility.tcp_handshake %}
        <div class="tab{% if not tool_visibility.ip_translator and not tool_visibility.command_runner and not tool_visibility.dns_lookup and not tool_visibility.bgp_looking_glass and not tool_visibility.traceroute and not tool_visibility.url_insights %} active{% endif %}" onclick="showTab('tcp-handshake')">TCP Handshake</div>
        {% endif %}
        {% if tool_visibility.whoami %}
        <div class="tab{% if not tool_visibility.ip_translator and not tool_visibility.command_runner and not tool_visibility.dns_lookup and not tool_visibility.bgp_looking_glass and not tool_visibility.traceroute and not tool_visibility.url_insights and not tool_visibility.tcp_handshake %} active{% endif %}" onclick="showTab('whoami')">WhoAmI</div>
        {% endif %}
    </div>

    <!-- IP Translator Tab -->
    {% if tool_visibility.ip_translator %}
    <div id="ip-translator" class="tab-content active">
        <p>Network IP Address Translator</p>

        <label for="inputText">
            <strong>Enter text with IP addresses:</strong>
        </label>
        <br>
        <textarea
            id="inputText"
            rows="6"
            cols="80"
            placeholder="Paste your text here... IP addresses like 192.168.1.1 will be automatically translated to show hostname and interface information."></textarea>
        <div id="loadingIndicator" style="display: none;">
            Translating...
        </div>

        <br><br>

        <label>
            <strong>Translated Output:</strong>
            <button id="copyButton" style="margin-left: 10px; padding: 4px 8px; cursor: pointer;" onclick="copyTranslatedOutput()">Copy</button>
        </label>
        <br>
        <div id="outputArea" style="border: 0px solid #ccc; padding: 10px; min-height: 100px; font-family: 'Consolas', monospace; line-height: 1.2;">
            <em>Your translated text will appear here...</em>
        </div>
    </div>
    {% endif %}

    <!-- Command Run Tool Tab -->
    {% if tool_visibility.command_runner %}
    <div id="command-runner" class="tab-content{% if not tool_visibility.ip_translator %} active{% endif %}">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <p style="margin: 0;">Network Device Command Runner</p>
            <button onclick="showSavedResults()" style="padding: 8px 16px; background: #6c757d; color: white; border: none; cursor: pointer; border-radius: 4px; font-size: 14px;">
                View Saved Results
            </button>
        </div>

        <div style="display: flex; gap: 20px;">
            <div style="flex: 1;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <label><strong>Devices:</strong></label>
                    <div>
                        <button onclick="saveDeviceList()" style="padding: 4px 8px; margin-right: 5px; background: #28a745; color: white; border: none; cursor: pointer; font-size: 12px;">Save</button>
                        <button onclick="loadDeviceList()" style="padding: 4px 8px; margin-right: 5px; background: #007cba; color: white; border: none; cursor: pointer; font-size: 12px;">Load</button>
                        <button onclick="manageDeviceLists()" style="padding: 4px 8px; background: #6c757d; color: white; border: none; cursor: pointer; font-size: 12px;">Manage</button>
                    </div>
                </div>
                <div class="add-item">
                    <input type="text" id="deviceInput" placeholder="Enter device IP/hostname" style="width: 200px;">
                    <button onclick="addDevice()">Add Device</button>
                </div>
                <div id="deviceList" class="device-list">
                    <em>No devices added...</em>
                </div>
            </div>

            <div style="flex: 1;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <label><strong>Commands:</strong></label>
                    <div>
                        <button onclick="saveCommandList()" style="padding: 4px 8px; margin-right: 5px; background: #28a745; color: white; border: none; cursor: pointer; font-size: 12px;">Save</button>
                        <button onclick="loadCommandList()" style="padding: 4px 8px; margin-right: 5px; background: #007cba; color: white; border: none; cursor: pointer; font-size: 12px;">Load</button>
                        <button onclick="manageCommandLists()" style="padding: 4px 8px; background: #6c757d; color: white; border: none; cursor: pointer; font-size: 12px;">Manage</button>
                    </div>
                </div>
                <div class="add-item">
                    <input type="text" id="commandInput" placeholder="Enter safe command (e.g., show version)" style="width: 200px;">
                    <button onclick="addCommand()">Add Command</button>
                    <div class="command-help-text">
                         Allowed: show, ping, traceroute, get, diagnose, execute<br>
                    </div>
                </div>
                <div id="commandList" class="command-list">
                    <em>No commands added...</em>
                </div>
            </div>
        </div>

        <div class="run-section">
            <label><strong>Credentials:</strong></label><br>
            <label>Username: <input type="text" id="username" style="margin: 5px;"></label><br>
            <label>Password: <input type="password" id="password" style="margin: 5px;"></label><br>

            {% if show_connector_dropdown %}
            <label style="margin-top: 10px; display: block;"><strong>Preferred Device Connector (optional):</strong></label>
            <select id="preferredConnector" style="margin: 5px; padding: 5px; width: 250px;">
                <option value="">Auto-detect (try all)</option>
                <option value="cisco_ios">Cisco IOS/IOS-XE</option>
                <option value="cisco_nxos">Cisco NX-OS</option>
                <option value="cisco_iosxr">Cisco IOS-XR</option>
                <option value="cisco_asa">Cisco ASA</option>
                <option value="paloalto_panos">Palo Alto PAN-OS</option>
                <option value="fortinet">FortiGate</option>
                <option value="arista_eos">Arista EOS</option>
                <option value="juniper_junos">Juniper Junos</option>
            </select>
            <div style="font-size: 11px; color: #666; margin-left: 5px; margin-top: 2px;">
                If specified, this connector will be tried first before auto-detection
            </div>
            <br>
            {% endif %}

            <label style="display: block; margin-top: 10px;"><strong>Session Name (optional):</strong></label>
            <input type="text" id="sessionName" placeholder="e.g., maintenance-session" style="margin: 5px; padding: 5px; width: 250px;">
            <div style="font-size: 11px; color: #666; margin-left: 5px; margin-top: 2px;">
                Used in the results filename: sessionname_YYYYMMDD_HHMMSS.zip
            </div>
            <br>

            <button onclick="runCommands()" style="padding: 10px 20px; background: #007cba; color: white; border: none; cursor: pointer;">Run Commands</button>
            <div id="runProgress" style="display: none; margin-top: 10px;">
                <div>Running commands... Please wait.</div>
            </div>
        </div>

        <div class="output-section">
            <div id="commandResults"></div>
            <div id="downloadSection" style="display: none; margin-top: 20px;">
                <button onclick="downloadResults()" style="padding: 10px 20px; background: #28a745; color: white; border: none; cursor: pointer; border-radius: 4px;">üíæ Download Results (ZIP)</button>
            </div>
        </div>
    </div>
    {% endif %}

    <!-- DNS Lookup Tab -->
    {% if tool_visibility.dns_lookup %}
    <div id="dns-lookup" class="tab-content{% if not tool_visibility.ip_translator and not tool_visibility.command_runner %} active{% endif %}">
        <p>Bulk DNS Lookup Tool</p>

        <div>
            <label><strong>Domains/IP Addresses (one per line):</strong></label>
            <br>
            <textarea
                id="dnsInput"
                rows="10"
                cols="50"
                placeholder="Enter domains or IP addresses, one per line:&#10;"
                oninput="validateDnsInput()"
                style="width: 50%; font-family: monospace;"></textarea>

            <div id="dnsValidation" style="margin-top: 5px; min-height: 20px;"></div>

            <div style="margin-top: 15px;">
                <!-- DNS Servers Section -->
                <div style="display: flex; align-items: center; gap: 10px;">
                    <label><strong>DNS Servers (optional):</strong></label>
                    <span style="font-size: 12px; color: #666;">Leave empty for system default</span>
                    <button onclick="saveDnsServerList()" style="padding: 4px 8px; background: #28a745; color: white; border: none; cursor: pointer; font-size: 12px;">Save</button>
                    <button onclick="loadDnsServerList()" style="padding: 4px 8px; background: #007cba; color: white; border: none; cursor: pointer; font-size: 12px;">Load</button>
                </div>

                <textarea
                    id="dnsServers"
                    rows="3"
                    cols="30"
                    placeholder=""
                    oninput="validateDnsInput()"
                    style="width: 50%; font-family: monospace; margin-top: 5px;"></textarea>

                <div id="dnsServersValidation" style="margin-top: 5px; min-height: 20px;"></div>

                <!-- Lookup Type on same line as button -->
                <div style="margin-top: 15px;">
                    <label style="display: inline-block; margin-right: 10px;">
                        <strong>Lookup Type:</strong>
                        <select id="lookupType" style="padding: 5px; margin-left: 5px;" onchange="validateDnsInput()">
                            <option value="A">A Record (IPv4)</option>
                            <option value="AAAA">AAAA Record (IPv6)</option>
                            <option value="CNAME">CNAME Record</option>
                            <option value="MX">MX Record</option>
                            <option value="NS">NS Record</option>
                            <option value="PTR">PTR Record (Reverse)</option>
                            <option value="TXT">TXT Record</option>
                            <option value="ALL">All Records</option>
                        </select>
                    </label>
                    <button onclick="performDnsLookup()" style="padding: 10px 20px; background: #007cba; color: white; border: none; cursor: pointer;">Perform DNS Lookup</button>
                    <div id="dnsProgress" style="display: none; margin-top: 10px;">
                        <div>Performing DNS lookups... Please wait.</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="output-section">
            <div style="margin-top: 20px;">
                <label>
                    <strong>DNS Lookup Results:</strong>
                    <button id="copyDnsButton" style="margin-left: 10px; padding: 4px 8px; cursor: pointer;" onclick="copyDnsResults()">Copy</button>
                </label>
                <br>
                <div id="dnsResults" style="border: 1px solid #ccc; padding: 10px; min-height: 200px; font-family: 'Consolas', monospace; line-height: 1.2; background: white; margin-top: 10px; white-space: pre-wrap;">
                    <em>DNS lookup results will appear here...</em>
                </div>
            </div>
        </div>
    </div>
    {% endif %}

    <!-- BGP Looking Glass Tab -->
    {% if tool_visibility.bgp_looking_glass %}
    <div id="bgp-looking-glass" class="tab-content{% if not tool_visibility.ip_translator and not tool_visibility.command_runner and not tool_visibility.dns_lookup %} active{% endif %}">
        <p>BGP Looking Glass Tool</p>

        <div>
            <!-- Credentials Section -->
            <div style="margin-bottom: 20px;">
                <label><strong>Credentials:</strong></label><br>
                <input type="text" id="bgpUsername" placeholder="Username" style="margin: 5px; padding: 5px; width: 200px;">
                <input type="password" id="bgpPassword" placeholder="Password" style="margin: 5px; padding: 5px; width: 200px;">
            </div>

            <!-- Prefix Input -->
            <div style="margin-bottom: 20px;">
                <label><strong>Prefix:</strong></label><br>
                <input type="text" id="bgpPrefix" placeholder="e.g., 10.0.0.0/24 or 192.168.1.0/24" style="margin: 5px; padding: 5px; width: 400px;">
            </div>

            <!-- Query Options -->
            <div style="margin-bottom: 20px;">
                <label><strong>Query Options:</strong></label><br>
                <div style="margin: 5px;">
                    <input type="checkbox" id="optShowIpRoute" checked>
                    <label for="optShowIpRoute">show ip route</label>
                </div>
                <div style="margin: 5px;">
                    <input type="checkbox" id="optShowIpBgp" checked>
                    <label for="optShowIpBgp">show ip bgp</label>
                </div>
                <div style="margin: 5px;">
                    <input type="checkbox" id="optTranslateIps" checked>
                    <label for="optTranslateIps">Translate IP addresses</label>
                </div>
            </div>

            <!-- Device Selection -->
            <div style="margin-bottom: 20px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <label><strong>Looking Glass Devices:</strong></label>
                    <div>
                        <button onclick="selectAllBgpDevices()" style="padding: 5px 10px; margin-right: 5px; background: #6c757d; color: white; border: none; cursor: pointer; border-radius: 4px; font-size: 12px;">
                            Select All
                        </button>
                        <button onclick="deselectAllBgpDevices()" style="padding: 5px 10px; background: #6c757d; color: white; border: none; cursor: pointer; border-radius: 4px; font-size: 12px;">
                            Deselect All
                        </button>
                    </div>
                </div>
                <div id="bgpDevicesList" style="border: 1px solid #ccc; padding: 15px; background: #f8f9fa; max-height: 400px; overflow-y: auto; border-radius: 4px;">
                    <p style="color: #666; font-style: italic;">Loading devices...</p>
                </div>
            </div>

            <!-- Action Buttons -->
            <div style="margin-bottom: 20px;">
                <button onclick="runBgpLookup()" style="padding: 10px 20px; background: #007cba; color: white; border: none; cursor: pointer; border-radius: 4px;">
                    Run BGP Lookup
                </button>
            </div>

            <!-- Progress Section -->
            <div id="bgpProgress" style="display: none; margin-top: 20px; padding: 10px; background: #f0f0f0; border: 1px solid #ccc;"></div>

            <!-- Results Section -->
            <div style="margin-top: 20px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                    <label><strong>Results:</strong></label>
                    <button id="bgpCopyButton" onclick="copyBgpResults()" style="padding: 5px 15px; background: #28a745; color: white; border: none; cursor: pointer; border-radius: 4px; display: none;">
                        <i class="bi bi-clipboard"></i> Copy to Clipboard
                    </button>
                </div>
                <div id="bgpResults" style="border: 1px solid #ccc; padding: 10px; min-height: 200px; font-family: 'Consolas', monospace; line-height: 1.2; background: white; margin-top: 10px; white-space: pre-wrap;">
                    <em>BGP lookup results will appear here...</em>
                </div>
            </div>
        </div>
    </div>
    {% endif %}

    <!-- Traceroute Tab -->
    {% if tool_visibility.traceroute %}
    <div id="traceroute" class="tab-content{% if not tool_visibility.ip_translator and not tool_visibility.command_runner and not tool_visibility.dns_lookup and not tool_visibility.bgp_looking_glass %} active{% endif %}">
        <p>Parallel Traceroute Tool</p>

        <div>
            <div style="display: flex; align-items: center; gap: 10px;">
                <label><strong>Target Hosts (one per line):</strong></label>
                <button onclick="saveTracerouteTargets()" style="padding: 4px 8px; background: #28a745; color: white; border: none; cursor: pointer; font-size: 12px;">Save</button>
                <button onclick="loadTracerouteTargets()" style="padding: 4px 8px; background: #007cba; color: white; border: none; cursor: pointer; font-size: 12px;">Load</button>
            </div>
            <br>
            <textarea
                id="tracerouteTargets"
                rows="10"
                cols="50"
                placeholder="Enter IP addresses or hostnames, one per line:&#10;"
                oninput="validateTracerouteInput()"
                style="width: 50%; font-family: monospace;"></textarea>

            <div id="tracerouteValidation" style="margin-top: 5px; min-height: 20px;"></div>

            <div style="margin-top: 15px;">
                <label><strong>Traceroute Options:</strong></label>

                <!-- Compact options in a single line -->
                <div style="margin: 10px 0;">
                    <label style="display: inline-block; margin-right: 15px;">
                        Max Hops: <input type="number" id="maxHops" min="1" max="255" value="30" style="width: 50px; padding: 2px;">
                    </label>
                    <label style="display: inline-block; margin-right: 15px;">
                        Timeout (s): <input type="number" id="traceTimeout" min="1" max="60" value="1" style="width: 50px; padding: 2px;">
                    </label>
                    <label style="display: inline-block; margin-right: 15px;">
                        Probes/hop: <input type="number" id="probesPerHop" min="1" max="10" value="1" style="width: 50px; padding: 2px;">
                    </label>
                    <label style="display: inline-block;">
                        Packet size: <input type="number" id="packetSize" min="28" max="65000" value="60" style="width: 60px; padding: 2px;"> bytes
                    </label>
                </div>

                <div style="margin: 10px 0;">
                    <label style="margin-right: 20px;">
                        <input type="checkbox" id="translateIPs" checked>
                        Translate IP addresses
                    </label>
                    <label>
                        <input type="checkbox" id="resolveHostnames" checked>
                        Resolve hostnames
                    </label>
                </div>

                <div style="margin-top: 15px;">
                    <button id="runTracerouteButton" onclick="performTraceroute()" style="padding: 10px 20px; background: #007cba; color: white; border: none; cursor: pointer;">Run Traceroute</button>
                    <button id="stopTracerouteButton" onclick="stopTraceroute()" style="padding: 10px 20px; background: #dc3545; color: white; border: none; cursor: pointer; display: none;">Stop</button>
                    <div id="tracerouteProgress" style="display: none; margin-top: 10px;">
                        <div id="tracerouteProgressText">Running traceroutes... Please wait.</div>
                        <div id="tracerouteProgressDetail" style="margin-top: 5px; font-size: 12px; color: #666;"></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="output-section">
            <div style="margin-top: 20px;">
                <label>
                    <strong>Traceroute Results:</strong>
                    <button id="copyTracerouteButton" style="margin-left: 10px; padding: 4px 8px; cursor: pointer;" onclick="copyTracerouteResults()">Copy</button>
                    <button id="translateTracerouteButton" style="margin-left: 10px; padding: 4px 8px; cursor: pointer; background: #007bff; color: white; border: none;" onclick="translateTracerouteResults()">Translate</button>
                    <button id="downloadTracerouteButton" style="margin-left: 10px; padding: 4px 8px; cursor: pointer; background: #28a745; color: white; border: none;" onclick="downloadTracerouteResults()">Download</button>
                </label>
                <br>
                <div id="tracerouteResults" style="border: 0px solid #ccc; padding: 10px; min-height: 200px; font-family: 'Consolas', monospace; line-height: 1.4; background: white; margin-top: 10px; white-space: pre-wrap; overflow-x: auto;">
                    <em>Traceroute results will appear here...</em>
                </div>
            </div>
        </div>
    </div>
    {% endif %}

    <!-- URL/App Insights Tab -->
    {% if tool_visibility.url_insights %}
    <div id="url-insights" class="tab-content{% if not tool_visibility.ip_translator and not tool_visibility.command_runner and not tool_visibility.dns_lookup and not tool_visibility.bgp_looking_glass and not tool_visibility.traceroute %} active{% endif %}">
        <p>URL Insights - Server-side Curl Diagnostics</p>

        <div style="margin-bottom: 20px;">
            <div style="display: flex; gap: 10px; align-items: flex-start;">
                <div style="flex: 1;">
                    <label><strong>URL to Analyze:</strong></label><br>
                    <input type="url" id="urlInsightsInput" placeholder="https://example.com"
                           style="width: 100%; padding: 8px; font-family: monospace;">
                </div>
                <div style="padding-top: 24px;">
                    <button onclick="analyzeCurlURL()" style="padding: 8px 16px; background: #007cba; color: white; border: none; cursor: pointer;">Analyze</button>
                    <button onclick="clearCurlAnalysis()" style="padding: 8px 16px; background: #6c757d; color: white; border: none; cursor: pointer; margin-left: 5px;">Clear</button>
                </div>
            </div>

            <!-- Advanced Options Toggle -->
            <div style="margin-top: 10px;">
                <button onclick="toggleCurlOptions()" style="padding: 6px 12px; background: #f0f0f0; border: 1px solid #ccc; cursor: pointer;">
                    <span id="curlOptionsToggleIcon">‚ñ∂</span> Advanced Curl Options
                </button>
            </div>

            <!-- Advanced Curl Options Panel -->
            <div id="curlOptionsPanel" style="display: none; margin-top: 10px; padding: 15px; background: #f9f9f9; border: 1px solid #ddd; border-radius: 4px;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                    <!-- Left Column -->
                    <div>
                        <div style="margin-bottom: 10px;">
                            <label>
                                <input type="checkbox" id="curlFollowRedirects" checked>
                                Follow Redirects (-L)
                            </label>
                        </div>
                        <div style="margin-bottom: 10px;">
                            <label>
                                <input type="checkbox" id="curlIncludeHeaders" checked>
                                Include Headers (-i)
                            </label>
                        </div>
                        <div style="margin-bottom: 10px;">
                            <label>
                                <input type="checkbox" id="curlHeadersOnly" checked>
                                Headers Only (-I)
                            </label>
                        </div>
                        <div style="margin-bottom: 10px;">
                            <label>
                                <input type="checkbox" id="curlVerbose" checked>
                                Verbose Output (-v)
                            </label>
                        </div>
                        <div style="margin-bottom: 10px;">
                            <label><strong>Request Method:</strong></label><br>
                            <select id="curlMethod" style="width: 100%; padding: 6px;">
                                <option value="GET">GET</option>
                                <option value="POST">POST</option>
                                <option value="PUT">PUT</option>
                                <option value="DELETE">DELETE</option>
                                <option value="HEAD">HEAD</option>
                                <option value="OPTIONS">OPTIONS</option>
                            </select>
                        </div>
                    </div>

                    <!-- Right Column -->
                    <div>
                        <div style="margin-bottom: 10px;">
                            <label><strong>User Agent:</strong></label><br>
                            <select id="curlUserAgent" style="width: 100%; padding: 6px; font-size: 12px;">
                                <option value="">Default (curl)</option>
                                <option value="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36">Chrome (Windows)</option>
                                <option value="Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36">Chrome (macOS)</option>
                                <option value="Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0">Firefox (Windows)</option>
                                <option value="Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:121.0) Gecko/20100101 Firefox/121.0">Firefox (macOS)</option>
                                <option value="Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.1 Safari/605.1.15">Safari (macOS)</option>
                                <option value="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Edg/120.0.0.0">Edge (Windows)</option>
                                <option value="Mozilla/5.0 (iPhone; CPU iPhone OS 17_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.1 Mobile/15E148 Safari/604.1">Safari (iPhone)</option>
                                <option value="Mozilla/5.0 (Linux; Android 13) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.6099.43 Mobile Safari/537.36">Chrome (Android)</option>
                                <option value="curl/8.4.0">curl/8.4.0</option>
                                <option value="Googlebot/2.1 (+http://www.google.com/bot.html)">Googlebot</option>
                            </select>
                        </div>
                        <div style="margin-bottom: 10px;">
                            <label><strong>Max Time (seconds):</strong></label><br>
                            <input type="number" id="curlMaxTime" value="30" min="1" max="300" style="width: 100%; padding: 6px;">
                        </div>
                        <div style="margin-bottom: 10px;">
                            <label><strong>Custom Headers:</strong></label><br>
                            <div id="customHeadersList" style="margin-top: 5px;">
                                <!-- Headers will be added here dynamically -->
                            </div>
                            <button onclick="addCustomHeader()" style="padding: 4px 8px; font-size: 12px; margin-top: 5px;">+ Add Header</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Single pane layout for curl output -->
        <div style="border: 1px solid #ccc; background: white;">
            <div style="background: #f0f0f0; padding: 8px; border-bottom: 1px solid #ccc; display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <strong>Curl Output</strong>
                    <span id="curlStatus" style="margin-left: 15px; color: #666; font-size: 12px;">Ready</span>
                </div>
                <div>
                    <span id="curlCommand" style="font-family: monospace; font-size: 11px; color: #666; margin-right: 15px;"></span>
                    <button id="exportCurlBtn" onclick="exportCurlOutput()" style="display: none; padding: 4px 8px; font-size: 12px; cursor: pointer;">Export</button>
                </div>
            </div>
            <div id="curlOutputContainer" style="height: 600px; overflow: auto; padding: 15px; background: #1e1e1e; font-family: 'Consolas', 'Monaco', monospace; font-size: 13px; color: #d4d4d4;">
                <div id="curlPlaceholder" style="text-align: center; color: #888; padding-top: 200px;">
                    <div style="font-size: 48px; margin-bottom: 20px;">üì°</div>
                    <p style="font-size: 16px; margin-bottom: 10px;">Enter a URL and click "Analyze"</p>
                    <p style="font-size: 12px; color: #666;">Server-side curl will execute and stream output here in real-time</p>
                </div>
                <div id="curlOutput" style="display: none; white-space: pre-wrap; word-wrap: break-word;"></div>
            </div>
        </div>
    </div>
    {% endif %}

    <!-- TCP Handshake Tab -->
    {% if tool_visibility.tcp_handshake %}
    <div id="tcp-handshake" class="tab-content{% if not tool_visibility.ip_translator and not tool_visibility.command_runner and not tool_visibility.dns_lookup and not tool_visibility.bgp_looking_glass and not tool_visibility.traceroute and not tool_visibility.url_insights %} active{% endif %}">
        <p>TCP 3-Way Handshake Analyzer</p>

        <div style="margin-bottom: 20px;">
            <div style="display: flex; gap: 10px; align-items: flex-end;">
                <div style="flex: 1;">
                    <label><strong>Target IP or Domain:</strong></label><br>
                    <input type="text" id="tcpHandshakeTarget" placeholder="example.com or 192.168.1.1"
                           style="width: 100%; padding: 8px; font-family: monospace;">
                </div>
                <div style="width: 150px;">
                    <label><strong>Port:</strong></label><br>
                    <input type="number" id="tcpHandshakePort" value="80" min="1" max="65535"
                           style="width: 100%; padding: 8px; font-family: monospace;">
                </div>
                <div style="padding-top: 24px;">
                    <button onclick="captureTCPHandshake()" style="padding: 8px 16px; background: #007cba; color: white; border: none; cursor: pointer;">Capture</button>
                    <button onclick="clearTCPHandshake()" style="padding: 8px 16px; background: #6c757d; color: white; border: none; cursor: pointer; margin-left: 5px;">Clear</button>
                </div>
            </div>
            <small style="color: #666; display: block; margin-top: 5px;">
                ‚ö†Ô∏è Note: This tool requires tcpdump and may need elevated permissions (sudo/root)
            </small>
        </div>

        <!-- Output Display -->
        <div style="border: 1px solid #ccc; background: white;">
            <div style="background: #f0f0f0; padding: 8px; border-bottom: 1px solid #ccc; display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <strong>Packet Capture</strong>
                    <span id="tcpStatus" style="margin-left: 15px; color: #666; font-size: 12px;">Ready</span>
                </div>
                <div>
                    <span id="tcpCommand" style="font-family: monospace; font-size: 11px; color: #666; margin-right: 15px;"></span>
                    <button id="exportTCPBtn" onclick="exportTCPOutput()" style="display: none; padding: 4px 8px; font-size: 12px; cursor: pointer;">Export</button>
                </div>
            </div>
            <div id="tcpOutputContainer" style="height: 600px; overflow: auto; padding: 15px; background: #1e1e1e; font-family: 'Consolas', 'Monaco', monospace; font-size: 13px; color: #d4d4d4;">
                <div id="tcpPlaceholder" style="text-align: center; color: #888; padding-top: 200px;">
                    <div style="font-size: 48px; margin-bottom: 20px;">üîå</div>
                    <p style="font-size: 16px; margin-bottom: 10px;">Enter a target and port, then click "Capture"</p>
                    <p style="font-size: 12px; color: #666;">View the TCP 3-way handshake (SYN, SYN-ACK, ACK) in real-time</p>
                </div>
                <div id="tcpOutput" style="display: none; white-space: pre-wrap; word-wrap: break-word;"></div>
            </div>
        </div>
    </div>
    {% endif %}

    <!-- WhoAmI Tab -->
    {% if tool_visibility.whoami %}
    <div id="whoami" class="tab-content{% if not tool_visibility.ip_translator and not tool_visibility.command_runner and not tool_visibility.dns_lookup and not tool_visibility.bgp_looking_glass and not tool_visibility.traceroute and not tool_visibility.url_insights and not tool_visibility.tcp_handshake %} active{% endif %}">
        <p></p>

        <div style="max-width: 50%; margin: 0 auto;">
            <label><strong>Your IP Address:</strong></label><br>
            <div id="userIpAddress" style="border: 1px solid #ccc; padding: 20px; background: white; font-family: 'Consolas', monospace; font-size: 24px; font-weight: bold; text-align: center; margin: 10px 0;">
                <span style="color: #999;">Loading...</span>
            </div>

            <div id="ipDetails" style="margin-top: 10px; display: none;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                    <div>
                        <label><strong>IP Version:</strong></label><br>
                        <div id="ipVersion" style="border: 1px solid #ccc; padding: 8px; background: white; font-family: 'Consolas', monospace;">-</div>
                    </div>
                    <div>
                        <label><strong>Type:</strong></label><br>
                        <div id="ipType" style="border: 1px solid #ccc; padding: 8px; background: white; font-family: 'Consolas', monospace;">-</div>
                    </div>
                </div>
            </div>

            <div id="reverseDns" style="margin-top: 10px; display: none;">
                <label><strong>Reverse DNS:</strong></label><br>
                <div id="reverseDnsValue" style="border: 1px solid #ccc; padding: 8px; background: white; font-family: 'Consolas', monospace; word-break: break-all;">-</div>
            </div>

            <br>
            <div style="background: #f0f0f0; padding: 15px; border: 1px solid #ccc; margin-top: 10px;">
                <p style="margin: 0 0 10px 0;"><strong>About:</strong><br>
                This tool displays your public IP address as seen by the server.</p>
               
            </div>
        </div>
    </div>
    {% endif %}



    <!-- Tooltip container -->
    <div id="tooltip" style="position: absolute; display: none; z-index: 1000;"></div>

    <!-- Save Device List Modal -->
    <div id="saveDeviceModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Save Device List</h3>
                <span class="close" onclick="closeSaveDeviceModal()">&times;</span>
            </div>
            <div>
                <label for="deviceListName"><strong>List Name:</strong></label><br>
                <input type="text" id="deviceListName" placeholder="Enter list name" style="width: 100%; margin: 10px 0; padding: 5px;">
                <div style="margin-top: 15px;">
                    <button onclick="confirmSaveDeviceList()" style="padding: 8px 16px; background: #28a745; color: white; border: none; cursor: pointer; margin-right: 10px;">Save</button>
                    <button onclick="closeSaveDeviceModal()" style="padding: 8px 16px; background: #6c757d; color: white; border: none; cursor: pointer;">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Load Device List Modal -->
    <div id="loadDeviceModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Load Device List</h3>
                <span class="close" onclick="closeLoadDeviceModal()">&times;</span>
            </div>
            <div id="savedDeviceLists">
                <em>No saved device lists found...</em>
            </div>
        </div>
    </div>

    <!-- Save Command List Modal -->
    <div id="saveCommandModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Save Command List</h3>
                <span class="close" onclick="closeSaveCommandModal()">&times;</span>
            </div>
            <div>
                <label for="commandListName"><strong>List Name:</strong></label><br>
                <input type="text" id="commandListName" placeholder="Enter list name" style="width: 100%; margin: 10px 0; padding: 5px;">
                <div style="margin-top: 15px;">
                    <button onclick="confirmSaveCommandList()" style="padding: 8px 16px; background: #28a745; color: white; border: none; cursor: pointer; margin-right: 10px;">Save</button>
                    <button onclick="closeSaveCommandModal()" style="padding: 8px 16px; background: #6c757d; color: white; border: none; cursor: pointer;">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Load Command List Modal -->
    <div id="loadCommandModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Load Command List</h3>
                <span class="close" onclick="closeLoadCommandModal()">&times;</span>
            </div>
            <div id="savedCommandLists">
                <em>No saved command lists found...</em>
            </div>
        </div>
    </div>

    <!-- Manage Device Lists Modal -->
    <div id="manageDeviceListsModal" class="modal">
        <div class="manage-modal-content">
            <div class="modal-header">
                <h3>Manage Saved Device Lists</h3>
                <span class="close" onclick="closeManageDeviceListsModal()">&times;</span>
            </div>
            <div id="manageDeviceListsContent">
                <em>Loading...</em>
            </div>
        </div>
    </div>

    <!-- Manage Command Lists Modal -->
    <div id="manageCommandListsModal" class="modal">
        <div class="manage-modal-content">
            <div class="modal-header">
                <h3>Manage Saved Commands</h3>
                <span class="close" onclick="closeManageCommandListsModal()">&times;</span>
            </div>
            <div id="manageCommandListsContent">
                <em>Loading...</em>
            </div>
        </div>
    </div>

    <!-- Saved Results Browser Modal -->
    <div id="savedResultsModal" class="modal">
        <div class="manage-modal-content" style="max-width: 900px;">
            <div class="modal-header">
                <h3>Saved Command Results</h3>
                <span class="close" onclick="closeSavedResults()">&times;</span>
            </div>
            <div style="margin-bottom: 15px;">
                <input type="text" id="resultsSearch" placeholder="Search by session name or date..." style="width: 300px; padding: 8px; margin-right: 10px;" oninput="filterResults()">
                <select id="resultsSortBy" style="padding: 8px; margin-right: 10px;" onchange="sortResults()">
                    <option value="date_desc">Newest First</option>
                    <option value="date_asc">Oldest First</option>
                    <option value="name_asc">Name A-Z</option>
                    <option value="name_desc">Name Z-A</option>
                    <option value="size_desc">Largest First</option>
                    <option value="size_asc">Smallest First</option>
                </select>
            </div>
            <div id="savedResultsContent" style="max-height: 500px; overflow-y: auto;">
                <em>Loading...</em>
            </div>
            <div id="resultsPagination" style="margin-top: 15px; text-align: center;">
                <!-- Pagination controls will be inserted here -->
            </div>
        </div>
    </div>

    <!-- Save DNS Server List Modal -->
    <div id="saveDnsServerModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Save DNS Server List</h3>
                <span class="close" onclick="closeSaveDnsServerModal()">&times;</span>
            </div>
            <div>
                <label for="dnsServerListName"><strong>List Name:</strong></label><br>
                <input type="text" id="dnsServerListName" placeholder="Enter list name (e.g., Public DNS, Corporate DNS)" style="width: 100%; margin: 10px 0; padding: 5px;">
                <div style="margin-top: 15px;">
                    <button onclick="confirmSaveDnsServerList()" style="padding: 8px 16px; background: #28a745; color: white; border: none; cursor: pointer; margin-right: 10px;">Save</button>
                    <button onclick="closeSaveDnsServerModal()" style="padding: 8px 16px; background: #6c757d; color: white; border: none; cursor: pointer;">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Load DNS Server List Modal -->
    <div id="loadDnsServerModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Load DNS Server List</h3>
                <span class="close" onclick="closeLoadDnsServerModal()">&times;</span>
            </div>
            <div id="savedDnsServerLists">
                <em>No saved DNS server lists found...</em>
            </div>
        </div>
    </div>

    <!-- Save Traceroute Targets Modal -->
    <div id="saveTracerouteTargetsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Save Traceroute Targets</h3>
                <span class="close" onclick="closeSaveTracerouteTargetsModal()">&times;</span>
            </div>
            <div>
                <label for="tracerouteTargetsListName"><strong>List Name:</strong></label><br>
                <input type="text" id="tracerouteTargetsListName" placeholder="Enter list name (e.g., Core Networks, Remote Sites)" style="width: 100%; margin: 10px 0; padding: 5px;">
                <div style="margin-top: 15px;">
                    <button onclick="confirmSaveTracerouteTargets()" style="padding: 8px 16px; background: #28a745; color: white; border: none; cursor: pointer; margin-right: 10px;">Save</button>
                    <button onclick="closeSaveTracerouteTargetsModal()" style="padding: 8px 16px; background: #6c757d; color: white; border: none; cursor: pointer;">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Load Traceroute Targets Modal -->
    <div id="loadTracerouteTargetsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Load Traceroute Targets</h3>
                <span class="close" onclick="closeLoadTracerouteTargetsModal()">&times;</span>
            </div>
            <div id="savedTracerouteTargetLists">
                <em>No saved traceroute target lists found...</em>
            </div>
        </div>
    </div>
    <script>
        // Global variables
        let timeoutId;
        const inputText = document.getElementById('inputText');
        const outputArea = document.getElementById('outputArea');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const tooltip = document.getElementById('tooltip');

        // Command runner variables
        let devices = [];
        let commands = [];
        let commandResults = {};

        // Command validation rules (loaded from database)
        let commandRules = {
            safePrefixes: [],
            dangerousPatterns: [],
            standaloneCommands: []
        };

        // Tab switching function
        function showTab(tabName) {
            // Hide all tab contents
            const tabContents = document.querySelectorAll('.tab-content');
            tabContents.forEach(tab => tab.classList.remove('active'));

            // Remove active class from all tabs
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => tab.classList.remove('active'));

            // Show selected tab
            document.getElementById(tabName).classList.add('active');

            // Add active class to clicked tab
            event.target.classList.add('active');

            // Save current tab to localStorage
            localStorage.setItem('activeTab', tabName);
        }

        // Restore last active tab on page load
        document.addEventListener('DOMContentLoaded', function() {
            const savedTab = localStorage.getItem('activeTab');
            if (savedTab) {
                // Check if the saved tab element exists (in case it's been hidden by admin)
                const savedTabElement = document.getElementById(savedTab);
                if (savedTabElement) {
                    // Remove active class from all tabs
                    document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
                    document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));

                    // Activate saved tab
                    savedTabElement.classList.add('active');

                    // Find and activate the corresponding tab button
                    const tabButtons = document.querySelectorAll('.tab');
                    tabButtons.forEach(button => {
                        if (button.getAttribute('onclick').includes(savedTab)) {
                            button.classList.add('active');
                        }
                    });
                }
            }
        });

        // Load command validation rules from server
        function loadCommandRules() {
            fetch('/settings/api/command-rules')
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        commandRules = data.rules;
                    }
                })
                .catch(error => {
                    console.error('Error loading command rules:', error);
                    // Use default rules if server request fails
                    commandRules = {
                        safePrefixes: [
                            'show ',
                            'execute ping ',
                            'execute traceroute ',
                            'ping ',
                            'traceroute ',
                            'trace ',
                            'get system ',
                            'diagnose '
                        ],
                        dangerousPatterns: [
                            'delete',
                            'remove',
                            'erase',
                            'format',
                            'reload',
                            'reboot',
                            'shutdown',
                            'clear',
                            'reset',
                            'write',
                            'copy',
                            'configure',
                            'config',
                            'exit',
                            'quit',
                            'end',
                            'commit',
                            'save'
                        ],
                        standaloneCommands: [
                            'uptime',
                            'version',
                            'date',
                            'clock',
                            'whoami',
                            'pwd'
                        ]
                    };
                });
        }

        // Initialize page
        document.addEventListener('DOMContentLoaded', function() {
            loadCommandRules();
        });

        // Command safety validation function (client-side) - uses database rules
        function validateCommandSafety(command) {
            if (!command || typeof command !== 'string') {
                return { isValid: false, message: "Invalid command format" };
            }

            const cleanCommand = command.trim().toLowerCase();

            // Step 1: Check for dangerous patterns first (blocklist approach)
            for (const pattern of commandRules.dangerousPatterns) {
                if (cleanCommand.includes(pattern.toLowerCase())) {
                    return {
                        isValid: false,
                        message: `Dangerous command pattern detected: '${pattern}'. Only read-only troubleshooting commands are allowed.`
                    };
                }
            }

            // Step 2: Check for safe prefixes (allowlist approach)
            for (const prefix of commandRules.safePrefixes) {
                if (cleanCommand.startsWith(prefix.toLowerCase())) {
                    return { isValid: true, message: null };
                }
            }

            // Step 3: Check standalone commands
            if (commandRules.standaloneCommands.some(cmd => cleanCommand === cmd.toLowerCase())) {
                return { isValid: true, message: null };
            }

            return {
                isValid: false,
                message: `Command '${command}' is not in the list of allowed safe commands. Use the Settings page to manage allowed commands.`
            };
        }

        // Command runner functions
        async function addDevice() {
            const deviceInput = document.getElementById('deviceInput');
            const device = deviceInput.value.trim();

            if (!device) {
                return;
            }

            // Check if already exists (check both raw and display format)
            const alreadyExists = devices.some(d => {
                const parts = d.split(' | ');
                return d === device || parts[0] === device || (parts[1] && parts[1] === device);
            });

            if (alreadyExists) {
                alert('Device already exists in the list');
                deviceInput.value = '';
                return;
            }

            // Show loading indicator
            const originalPlaceholder = deviceInput.placeholder;
            deviceInput.placeholder = 'Resolving...';
            deviceInput.disabled = true;

            try {
                // Resolve hostname to IP
                const response = await fetch('/api/resolve-hostname', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        hostname: device
                    })
                });

                const data = await response.json();

                if (data.success) {
                    // Add the device with resolved format
                    devices.push(data.display);
                    updateDeviceList();
                    deviceInput.value = '';
                } else {
                    // Hostname resolution failed
                    alert(`Unable to add device: ${data.error}\n\nPlease check the hostname/IP and try again.`);
                }
            } catch (error) {
                console.error('Error resolving hostname:', error);
                alert('Error resolving hostname. Please try again.');
            } finally {
                // Restore input state
                deviceInput.placeholder = originalPlaceholder;
                deviceInput.disabled = false;
                deviceInput.focus();
            }
        }

        function addCommand() {
            const commandInput = document.getElementById('commandInput');
            const command = commandInput.value.trim();

            if (!command) {
                return;
            }

            // Validate command safety
            const validation = validateCommandSafety(command);
            if (!validation.isValid) {
                alert(`‚ùå Command Blocked\n\n${validation.message}\n\nOnly safe, read-only troubleshooting commands are allowed.`);
                commandInput.value = '';
                commandInput.focus();
                return;
            }

            if (!commands.includes(command)) {
                commands.push(command);
                updateCommandList();
                commandInput.value = '';
                // Visual feedback for successful addition
                const addButton = event.target;
                const originalText = addButton.textContent;
                addButton.textContent = '‚úì Added';
                addButton.style.backgroundColor = '#28a745';
                addButton.style.color = 'white';
                setTimeout(() => {
                    addButton.textContent = originalText;
                    addButton.style.backgroundColor = '';
                    addButton.style.color = '';
                }, 1000);
            } else {
                alert('Command already exists in the list');
                commandInput.value = '';
            }
        }

        function removeDevice(device) {
            devices = devices.filter(d => d !== device);
            updateDeviceList();
        }

        function removeCommand(command) {
            commands = commands.filter(c => c !== command);
            updateCommandList();
        }

        function updateDeviceList() {
            const deviceList = document.getElementById('deviceList');
            if (devices.length === 0) {
                deviceList.innerHTML = '<em>No devices added...</em>';
            } else {
                deviceList.innerHTML = devices.map(device =>
                    `<div>${device} <span class="remove-btn" onclick="removeDevice('${device}')">‚úó</span></div>`
                ).join('');
            }
        }

        function updateCommandList() {
            const commandList = document.getElementById('commandList');
            if (commands.length === 0) {
                commandList.innerHTML = '<em>No commands added...</em>';
            } else {
                commandList.innerHTML = commands.map(command =>
                    `<div>${command} <span class="remove-btn" onclick="removeCommand('${command}')">‚úó</span></div>`
                ).join('');
            }
        }

        // Store results globally for download
        let globalResults = {};

        async function runCommands() {
            const username = document.getElementById('username').value.trim();
            const password = document.getElementById('password').value.trim();

            if (!username || !password) {
                alert('Please enter username and password');
                return;
            }

            if (devices.length === 0) {
                alert('Please add at least one device');
                return;
            }

            if (commands.length === 0) {
                alert('Please add at least one command');
                return;
            }

            // Final safety check - validate all commands before execution
            const invalidCommands = [];
            for (const command of commands) {
                const validation = validateCommandSafety(command);
                if (!validation.isValid) {
                    invalidCommands.push({
                        command: command,
                        reason: validation.message
                    });
                }
            }

            if (invalidCommands.length > 0) {
                let errorMessage = `üö´ Execution Blocked - Unsafe Commands Detected\n\n`;
                invalidCommands.forEach(item => {
                    errorMessage += `‚Ä¢ "${item.command}"\n  Reason: ${item.reason}\n\n`;
                });
                errorMessage += `Please remove these commands and try again.`;
                alert(errorMessage);
                return;
            }

            const runProgress = document.getElementById('runProgress');
            const commandResults = document.getElementById('commandResults');

            runProgress.style.display = 'block';
            runProgress.innerHTML = '<div>Running commands... Results will appear as they are received.</div>';
            commandResults.innerHTML = '';
            globalResults = {};
            savedResultsFilename = null; // Reset for new run

            // Get preferred connector (if dropdown exists)
            const connectorDropdown = document.getElementById('preferredConnector');
            const preferredConnector = connectorDropdown ? connectorDropdown.value.trim() : '';

            // Use EventSource for SSE streaming
            try {
                // First make a POST request to get validation
                const validateResponse = await fetch('/api/run-commands-stream', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        devices: devices,
                        commands: commands,
                        username: username,
                        password: password,
                        preferred_connector: preferredConnector
                    })
                });

                // Check if response is JSON (error) or SSE stream
                const contentType = validateResponse.headers.get('content-type');
                if (contentType && contentType.includes('application/json')) {
                    const data = await validateResponse.json();
                    alert('Error: ' + data.error);
                    runProgress.style.display = 'none';
                    return;
                }

                // Read the SSE stream
                const reader = validateResponse.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                let devicesCompleted = 0;
                let totalDevices = devices.length;

                while (true) {
                    const {done, value} = await reader.read();

                    if (done) break;

                    buffer += decoder.decode(value, {stream: true});

                    // Process complete messages
                    const lines = buffer.split('\n\n');
                    buffer = lines.pop(); // Keep incomplete message in buffer

                    for (const line of lines) {
                        if (!line.trim() || !line.startsWith('data: ')) continue;

                        try {
                            const eventData = JSON.parse(line.substring(6)); // Remove 'data: ' prefix

                            if (eventData.type === 'started') {
                                totalDevices = eventData.total_devices;
                                runProgress.innerHTML = `<div>Running commands on ${totalDevices} device(s)... 0/${totalDevices} completed</div>`;
                            } else if (eventData.type === 'device_complete') {
                                devicesCompleted++;
                                globalResults[eventData.device] = eventData.data;
                                displayDeviceResult(eventData.device, eventData.data);
                                runProgress.innerHTML = `<div>Running commands... ${devicesCompleted}/${totalDevices} devices completed</div>`;
                            } else if (eventData.type === 'complete') {
                                runProgress.innerHTML = `<div style="color: green;">‚úì All commands completed! (${devicesCompleted}/${totalDevices} devices) - Saving results...</div>`;

                                // Auto-save results to server immediately
                                await autoSaveResults();

                                runProgress.innerHTML = `<div style="color: green;">‚úì All commands completed and saved! (${devicesCompleted}/${totalDevices} devices)</div>`;
                                document.getElementById('downloadSection').style.display = 'block';
                                setTimeout(() => {
                                    runProgress.style.display = 'none';
                                }, 3000);
                            } else if (eventData.type === 'error') {
                                runProgress.innerHTML += `<div style="color: red;">Error: ${eventData.message}</div>`;
                            }
                        } catch (e) {
                            console.error('Error parsing SSE message:', e, line);
                        }
                    }
                }
            } catch (error) {
                console.error('Error running commands:', error);
                alert('Error running commands: ' + error.message);
                runProgress.style.display = 'none';
            }
        }

        function displayDeviceResult(device, deviceData) {
            const commandResults = document.getElementById('commandResults');

            const deviceDiv = document.createElement('div');
            deviceDiv.className = 'device-output';
            deviceDiv.id = `device-result-${device.replace(/[^a-zA-Z0-9]/g, '_')}`;

            const deviceHeader = document.createElement('h4');
            deviceHeader.textContent = `${device} (${deviceData.status})`;
            if (deviceData.status === 'success') {
                deviceHeader.style.color = '#28a745';
            } else {
                deviceHeader.style.color = '#dc3545';
            }
            deviceDiv.appendChild(deviceHeader);

            if (deviceData.status === 'success') {
                for (const [command, commandData] of Object.entries(deviceData.commands)) {
                    const commandDiv = document.createElement('div');
                    commandDiv.innerHTML = `<strong>Command:</strong> ${command}`;
                    deviceDiv.appendChild(commandDiv);

                    const outputDiv = document.createElement('div');
                    outputDiv.className = 'command-output';
                    outputDiv.textContent = commandData.output || 'No output';
                    deviceDiv.appendChild(outputDiv);
                }
            } else {
                const errorDiv = document.createElement('div');
                errorDiv.style.color = 'red';
                errorDiv.textContent = deviceData.error || 'Unknown error';
                deviceDiv.appendChild(errorDiv);
            }

            commandResults.appendChild(deviceDiv);

            // Scroll to the newly added result
            deviceDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        function displayResults(results) {
            const commandResults = document.getElementById('commandResults');
            commandResults.innerHTML = '';

            console.log('Displaying results:', results); // Debug log

            for (const [device, deviceData] of Object.entries(results)) {
                const deviceDiv = document.createElement('div');
                deviceDiv.className = 'device-output';

                const deviceHeader = document.createElement('h4');
                deviceHeader.textContent = `${device} (${deviceData.status})`;
                deviceDiv.appendChild(deviceHeader);

                if (deviceData.status === 'success') {
                    for (const [command, commandData] of Object.entries(deviceData.commands)) {
                        const commandDiv = document.createElement('div');
                        commandDiv.innerHTML = `<strong>Command:</strong> ${command}`;
                        deviceDiv.appendChild(commandDiv);

                        const outputDiv = document.createElement('div');
                        outputDiv.className = 'command-output';

                        // Debug logging
                        console.log(`Command: ${command}`);
                        console.log(`CommandData:`, commandData);
                        console.log(`Raw output length: ${commandData.output ? commandData.output.length : 0}`);
                        console.log(`Translated output length: ${commandData.translated_output ? commandData.translated_output.length : 0}`);

                        let outputText = 'No output received';
                        if (commandData.translated_output && commandData.translated_output.trim()) {
                            outputText = commandData.translated_output;
                        } else if (commandData.output && commandData.output.trim()) {
                            outputText = commandData.output;
                        }

                        // Use innerHTML instead of textContent to preserve formatting
                        outputDiv.innerHTML = outputText.replace(/\n/g, '<br>');
                        deviceDiv.appendChild(outputDiv);
                    }
                } else {
                    const errorDiv = document.createElement('div');
                    errorDiv.className = 'command-output';
                    errorDiv.style.color = 'red';
                    errorDiv.textContent = deviceData.error;
                    deviceDiv.appendChild(errorDiv);
                }

                commandResults.appendChild(deviceDiv);
            }

            // Store results for download
            window.lastResults = results;
        }

        // Store the saved filename globally
        let savedResultsFilename = null;

        async function autoSaveResults() {
            if (!globalResults || Object.keys(globalResults).length === 0) {
                return;
            }

            // Get session name
            const sessionName = document.getElementById('sessionName').value.trim();
            const timestamp = new Date().toISOString().slice(0,19).replace(/:/g, '-').replace('T', '_');
            const filename = sessionName ? `${sessionName}_${timestamp}.zip` : `command_results_${timestamp}.zip`;

            try {
                const response = await fetch('/api/save-results', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        results: globalResults,
                        session_name: sessionName,
                        filename: filename
                    })
                });

                if (response.ok) {
                    const data = await response.json();
                    if (data.success) {
                        savedResultsFilename = data.filename;
                        console.log('Results saved:', savedResultsFilename);
                    }
                } else {
                    console.error('Error saving results');
                }
            } catch (error) {
                console.error('Error saving results:', error);
            }
        }

        async function downloadResults() {
            if (!savedResultsFilename) {
                alert('No saved results available. Please run commands first.');
                return;
            }

            try {
                // Download the already-saved file
                const a = document.createElement('a');
                a.href = `/api/saved-results/${encodeURIComponent(savedResultsFilename)}`;
                a.download = savedResultsFilename;
                document.body.appendChild(a);
                a.click();
                a.remove();
            } catch (error) {
                console.error('Error downloading results:', error);
                alert('Error downloading results: ' + error.message);
            }
        }

        // Saved Results Browser
        let allSavedResults = [];
        let filteredResults = [];
        let currentPage = 1;
        const resultsPerPage = 10;

        async function showSavedResults() {
            document.getElementById('savedResultsModal').style.display = 'block';
            await loadSavedResults();
        }

        function closeSavedResults() {
            document.getElementById('savedResultsModal').style.display = 'none';
        }

        async function loadSavedResults() {
            try {
                const response = await fetch('/api/saved-results');
                if (response.ok) {
                    allSavedResults = await response.json();
                    filteredResults = [...allSavedResults];
                    sortResults();
                } else {
                    alert('Error loading saved results');
                }
            } catch (error) {
                console.error('Error loading saved results:', error);
                alert('Error loading saved results: ' + error.message);
            }
        }

        function filterResults() {
            const searchTerm = document.getElementById('resultsSearch').value.toLowerCase();
            filteredResults = allSavedResults.filter(result => {
                return result.filename.toLowerCase().includes(searchTerm) ||
                       new Date(result.created).toLocaleString().toLowerCase().includes(searchTerm);
            });
            currentPage = 1;
            displayResults();
        }

        function sortResults() {
            const sortBy = document.getElementById('resultsSortBy').value;

            filteredResults.sort((a, b) => {
                switch(sortBy) {
                    case 'date_desc':
                        return new Date(b.created) - new Date(a.created);
                    case 'date_asc':
                        return new Date(a.created) - new Date(b.created);
                    case 'name_asc':
                        return a.filename.localeCompare(b.filename);
                    case 'name_desc':
                        return b.filename.localeCompare(a.filename);
                    case 'size_desc':
                        return b.size - a.size;
                    case 'size_asc':
                        return a.size - b.size;
                    default:
                        return 0;
                }
            });

            displayResults();
        }

        function displayResults() {
            const contentDiv = document.getElementById('savedResultsContent');
            const totalPages = Math.ceil(filteredResults.length / resultsPerPage);
            const startIndex = (currentPage - 1) * resultsPerPage;
            const endIndex = Math.min(startIndex + resultsPerPage, filteredResults.length);

            if (filteredResults.length === 0) {
                contentDiv.innerHTML = '<p style="text-align: center; color: #666; padding: 20px;">No results found</p>';
                document.getElementById('resultsPagination').innerHTML = '';
                return;
            }

            let html = '<table style="width: 100%; border-collapse: collapse;">';
            html += '<thead><tr style="background: #f5f5f5; border-bottom: 2px solid #ddd;">';
            html += '<th style="padding: 10px; text-align: left;">Filename</th>';
            html += '<th style="padding: 10px; text-align: left;">Created</th>';
            html += '<th style="padding: 10px; text-align: right;">Size</th>';
            html += '<th style="padding: 10px; text-align: center;">Actions</th>';
            html += '</tr></thead><tbody>';

            for (let i = startIndex; i < endIndex; i++) {
                const result = filteredResults[i];
                const sizeKB = (result.size / 1024).toFixed(2);
                const createdDate = new Date(result.created).toLocaleString();

                html += '<tr style="border-bottom: 1px solid #eee;">';
                html += `<td style="padding: 10px;">${result.filename}</td>`;
                html += `<td style="padding: 10px;">${createdDate}</td>`;
                html += `<td style="padding: 10px; text-align: right;">${sizeKB} KB</td>`;
                html += `<td style="padding: 10px; text-align: center;">`;
                html += `<button onclick="downloadSavedResult('${result.filename}')" style="padding: 5px 10px; margin-right: 5px; background: #007cba; color: white; border: none; cursor: pointer; border-radius: 3px;">Download</button>`;
                html += `<button onclick="deleteSavedResult('${result.filename}')" style="padding: 5px 10px; background: #dc3545; color: white; border: none; cursor: pointer; border-radius: 3px;">Delete</button>`;
                html += `</td></tr>`;
            }

            html += '</tbody></table>';
            contentDiv.innerHTML = html;

            // Pagination controls
            let paginationHTML = '<div style="display: inline-block;">';
            paginationHTML += `<span style="margin-right: 15px;">Page ${currentPage} of ${totalPages} (${filteredResults.length} results)</span>`;

            if (currentPage > 1) {
                paginationHTML += `<button onclick="changePage(${currentPage - 1})" style="padding: 5px 10px; margin-right: 5px; cursor: pointer;">Previous</button>`;
            }

            // Show page numbers
            const maxPageButtons = 5;
            let startPage = Math.max(1, currentPage - Math.floor(maxPageButtons / 2));
            let endPage = Math.min(totalPages, startPage + maxPageButtons - 1);

            if (endPage - startPage < maxPageButtons - 1) {
                startPage = Math.max(1, endPage - maxPageButtons + 1);
            }

            for (let i = startPage; i <= endPage; i++) {
                const isActive = i === currentPage;
                paginationHTML += `<button onclick="changePage(${i})" style="padding: 5px 10px; margin-right: 5px; ${isActive ? 'background: #007cba; color: white;' : ''} cursor: pointer;">${i}</button>`;
            }

            if (currentPage < totalPages) {
                paginationHTML += `<button onclick="changePage(${currentPage + 1})" style="padding: 5px 10px; cursor: pointer;">Next</button>`;
            }

            paginationHTML += '</div>';
            document.getElementById('resultsPagination').innerHTML = paginationHTML;
        }

        function changePage(page) {
            currentPage = page;
            displayResults();
        }

        async function downloadSavedResult(filename) {
            try {
                const response = await fetch(`/api/saved-results/${encodeURIComponent(filename)}`);
                if (response.ok) {
                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(url);
                    a.remove();
                } else {
                    alert('Error downloading file');
                }
            } catch (error) {
                console.error('Error downloading file:', error);
                alert('Error downloading file: ' + error.message);
            }
        }

        async function deleteSavedResult(filename) {
            if (!confirm(`Are you sure you want to delete ${filename}?`)) {
                return;
            }

            try {
                const response = await fetch(`/api/saved-results/${encodeURIComponent(filename)}`, {
                    method: 'DELETE'
                });

                if (response.ok) {
                    await loadSavedResults();
                } else {
                    alert('Error deleting file');
                }
            } catch (error) {
                console.error('Error deleting file:', error);
                alert('Error deleting file: ' + error.message);
            }
        }

        // Add event listeners for Enter key
        document.getElementById('deviceInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                addDevice();
            }
        });

        document.getElementById('commandInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                addCommand();
            }
        });

        // Add real-time command validation
        document.getElementById('commandInput').addEventListener('input', function(e) {
            const command = e.target.value.trim();
            const addButton = document.querySelector('button[onclick="addCommand()"]');

            // Remove existing validation classes
            e.target.classList.remove('command-input-valid', 'command-input-invalid');

            if (command) {
                const validation = validateCommandSafety(command);
                if (!validation.isValid) {
                    // Show visual feedback for invalid command
                    e.target.classList.add('command-input-invalid');
                    e.target.title = validation.message;
                    addButton.disabled = true;
                    addButton.style.opacity = '0.6';
                    addButton.title = 'Command not allowed - ' + validation.message;
                } else {
                    // Command is valid
                    e.target.classList.add('command-input-valid');
                    e.target.title = 'Valid command - ready to add';
                    addButton.disabled = false;
                    addButton.style.opacity = '1';
                    addButton.title = 'Add this command';
                }
            } else {
                // Reset to default state when empty
                e.target.title = '';
                addButton.disabled = false;
                addButton.style.opacity = '1';
                addButton.title = '';
            }
        });

        // Check if user is authenticated (passed from Flask template)
        const userAuthenticated = {{ 'true' if user_authenticated else 'false' }};

        // Save/Load functionality for device lists
        function saveDeviceList() {
            if (devices.length === 0) {
                alert('No devices to save');
                return;
            }
            document.getElementById('saveDeviceModal').style.display = 'block';
            document.getElementById('deviceListName').focus();
        }

        function closeSaveDeviceModal() {
            document.getElementById('saveDeviceModal').style.display = 'none';
            document.getElementById('deviceListName').value = '';
        }

        async function confirmSaveDeviceList() {
            const listName = document.getElementById('deviceListName').value.trim();
            if (!listName) {
                alert('Please enter a list name');
                return;
            }

            // Save to database via API
            try {
                const response = await fetch('/saved-items/api/quick-save-devices', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        devices: devices,
                        name: listName
                    })
                });

                const data = await response.json();
                if (data.success) {
                    // alert(`Device list "${listName}" saved successfully!`);
                    closeSaveDeviceModal();
                } else {
                    alert(`Error saving: ${data.error}`);
                }
            } catch (error) {
                alert(`Error saving: ${error.message}`);
            }
        }

        async function loadDeviceList() {
            const savedListsDiv = document.getElementById('savedDeviceLists');
            savedListsDiv.innerHTML = '<em>Loading...</em>';

            // Get all lists from database
            try {
                const response = await fetch('/saved-items/api/device-lists');
                if (response.ok) {
                    const dbLists = await response.json();

                    if (dbLists.length === 0) {
                        savedListsDiv.innerHTML = '<em>No saved device lists found...</em>';
                    } else {
                        savedListsDiv.innerHTML = '';
                        for (const list of dbLists) {
                            const savedItem = document.createElement('div');
                            savedItem.className = 'saved-item';

                            const itemInfo = document.createElement('div');
                            itemInfo.innerHTML = `
                                <div class="saved-item-name">${list.name}</div>
                                <div class="saved-item-count">${list.devices.length} devices - Saved: ${new Date(list.updated_at).toLocaleDateString()}</div>
                            `;

                            const deleteBtn = document.createElement('span');
                            deleteBtn.className = 'delete-saved';
                            deleteBtn.innerHTML = '‚úó';
                            deleteBtn.onclick = (e) => {
                                e.stopPropagation();
                                deleteDeviceListItem(list);
                            };

                            savedItem.appendChild(itemInfo);
                            savedItem.appendChild(deleteBtn);

                            savedItem.onclick = () => confirmLoadDeviceList(list.name, list.devices);
                            savedListsDiv.appendChild(savedItem);
                        }
                    }
                } else {
                    savedListsDiv.innerHTML = '<em style="color: red;">Error loading device lists</em>';
                }
            } catch (error) {
                console.error('Error loading device lists:', error);
                savedListsDiv.innerHTML = '<em style="color: red;">Error loading device lists</em>';
            }

            document.getElementById('loadDeviceModal').style.display = 'block';
        }

        function closeLoadDeviceModal() {
            document.getElementById('loadDeviceModal').style.display = 'none';
        }

        function confirmLoadDeviceList(listName, deviceList) {
            if (devices.length > 0) {
                if (!confirm(`This will replace your current device list (${devices.length} devices). Continue?`)) {
                    return;
                }
            }

            // Load devices directly (they already contain hostname | IP format from when they were saved)
            devices = [...deviceList];
            updateDeviceList();
            closeLoadDeviceModal();
        }

        async function deleteDeviceListItem(list) {
            if (!confirm(`Delete device list "${list.name}"?`)) {
                return;
            }

            // Delete from database
            try {
                const response = await fetch(`/saved-items/api/device-lists/${list.id}/delete`, {
                    method: 'POST'
                });
                const data = await response.json();
                if (data.success) {
                    loadDeviceList(); // Refresh the modal
                } else {
                    alert(`Error deleting: ${data.error}`);
                }
            } catch (error) {
                alert(`Error deleting: ${error.message}`);
            }
        }

        // Save/Load functionality for command lists
        function saveCommandList() {
            if (commands.length === 0) {
                alert('No commands to save');
                return;
            }
            document.getElementById('saveCommandModal').style.display = 'block';
            document.getElementById('commandListName').focus();
        }

        function closeSaveCommandModal() {
            document.getElementById('saveCommandModal').style.display = 'none';
            document.getElementById('commandListName').value = '';
        }

        async function confirmSaveCommandList() {
            const listName = document.getElementById('commandListName').value.trim();
            if (!listName) {
                alert('Please enter a list name');
                return;
            }

            // Save to database via API
            try {
                const response = await fetch('/saved-items/api/quick-save-commands', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        commands: commands,
                        name: listName,
                        vendor: 'all'
                    })
                });

                const data = await response.json();
                if (data.success) {
                    alert(`Command list "${listName}" saved successfully!`);
                    closeSaveCommandModal();
                } else {
                    alert(`Error saving: ${data.error}`);
                }
            } catch (error) {
                alert(`Error saving: ${error.message}`);
            }
        }

        async function loadCommandList() {
            const savedListsDiv = document.getElementById('savedCommandLists');
            savedListsDiv.innerHTML = '<em>Loading...</em>';

            // Get all lists from database
            try {
                const response = await fetch('/saved-items/api/commands');
                if (response.ok) {
                    const dbLists = await response.json();

                    if (dbLists.length === 0) {
                        savedListsDiv.innerHTML = '<em>No saved command lists found...</em>';
                    } else {
                        savedListsDiv.innerHTML = '';
                        for (const list of dbLists) {
                            const savedItem = document.createElement('div');
                            savedItem.className = 'saved-item';

                            const itemInfo = document.createElement('div');
                            const vendorLabel = list.vendor ? ` [${list.vendor}]` : '';
                            itemInfo.innerHTML = `
                                <div class="saved-item-name">${list.name}${vendorLabel}</div>
                                <div class="saved-item-count">${list.commands.length} commands - Saved: ${new Date(list.updated_at).toLocaleDateString()}</div>
                            `;

                            const deleteBtn = document.createElement('span');
                            deleteBtn.className = 'delete-saved';
                            deleteBtn.innerHTML = '‚úó';
                            deleteBtn.onclick = (e) => {
                                e.stopPropagation();
                                deleteCommandListItem(list);
                            };

                            savedItem.appendChild(itemInfo);
                            savedItem.appendChild(deleteBtn);

                            savedItem.onclick = () => confirmLoadCommandList(list.name, list.commands, list.vendor);
                            savedListsDiv.appendChild(savedItem);
                        }
                    }
                } else {
                    savedListsDiv.innerHTML = '<em style="color: red;">Error loading command lists</em>';
                }
            } catch (error) {
                console.error('Error loading command lists:', error);
                savedListsDiv.innerHTML = '<em style="color: red;">Error loading command lists</em>';
            }

            document.getElementById('loadCommandModal').style.display = 'block';
        }

        function closeLoadCommandModal() {
            document.getElementById('loadCommandModal').style.display = 'none';
        }

        function confirmLoadCommandList(listName, commandList, vendor) {
            if (commands.length > 0) {
                if (!confirm(`This will replace your current command list (${commands.length} commands). Continue?`)) {
                    return;
                }
            }

            // Validate all commands being loaded
            const validCommands = [];
            const invalidCommands = [];

            for (const command of commandList) {
                const validation = validateCommandSafety(command);
                if (validation.isValid) {
                    validCommands.push(command);
                } else {
                    invalidCommands.push({
                        command: command,
                        reason: validation.message
                    });
                }
            }

            if (invalidCommands.length > 0) {
                let warningMessage = `‚ö†Ô∏è Security Warning\n\n${invalidCommands.length} unsafe command(s) were blocked from loading:\n\n`;
                invalidCommands.forEach(item => {
                    warningMessage += `‚Ä¢ "${item.command}"\n  Reason: ${item.reason}\n\n`;
                });

                if (validCommands.length > 0) {
                    warningMessage += `${validCommands.length} safe command(s) will be loaded.`;
                } else {
                    warningMessage += `No safe commands found in this list.`;
                }

                alert(warningMessage);
            }

            commands = validCommands;
            updateCommandList();
            closeLoadCommandModal();

            // Set preferred connector based on vendor if connector dropdown exists
            const connectorDropdown = document.getElementById('preferredConnector');
            if (connectorDropdown && vendor && vendor !== 'all') {
                // Map vendor values to connector values
                const vendorToConnector = {
                    'cisco_ios': 'cisco_ios',
                    'cisco_nxos': 'cisco_nxos',
                    'cisco_iosxr': 'cisco_iosxr',
                    'cisco_asa': 'cisco_asa',
                    'paloalto': 'paloalto_panos',
                    'fortigate': 'fortinet',
                    'arista': 'arista_eos',
                    'juniper': 'juniper_junos'
                };

                const connectorValue = vendorToConnector[vendor] || vendor;
                connectorDropdown.value = connectorValue;
            }

            if (validCommands.length > 0) {
                // alert(`Command list "${listName}" loaded with ${validCommands.length} safe command(s)!`);
            } else {
                alert(`Command list "${listName}" contained no safe commands.`);
            }
        }

        async function deleteCommandListItem(list) {
            if (!confirm(`Delete command list "${list.name}"?`)) {
                return;
            }

            // Delete from database
            try {
                const response = await fetch(`/saved-items/api/commands/${list.id}/delete`, {
                    method: 'POST'
                });
                const data = await response.json();
                if (data.success) {
                    loadCommandList(); // Refresh the modal
                } else {
                    alert(`Error deleting: ${data.error}`);
                }
            } catch (error) {
                alert(`Error deleting: ${error.message}`);
            }
        }

        // ===== Manage Device Lists =====
        async function manageDeviceLists() {
            const contentDiv = document.getElementById('manageDeviceListsContent');
            contentDiv.innerHTML = '<em>Loading...</em>';
            document.getElementById('manageDeviceListsModal').style.display = 'block';

            try {
                const response = await fetch('/saved-items/api/device-lists');
                if (!response.ok) throw new Error('Failed to load device lists');

                const lists = await response.json();

                if (lists.length === 0) {
                    contentDiv.innerHTML = '<p style="text-align: center; color: #666;">No saved device lists in database. Use "Save" button to create one.</p>';
                } else {
                    contentDiv.innerHTML = '';
                    lists.forEach(list => {
                        contentDiv.appendChild(createManageDeviceItem(list));
                    });
                }
            } catch (error) {
                contentDiv.innerHTML = `<p style="color: red;">Error loading device lists: ${error.message}</p>`;
            }
        }

        function createManageDeviceItem(list) {
            const container = document.createElement('div');
            container.className = 'manage-item';
            container.id = `device-item-${list.id}`;

            const header = document.createElement('div');
            header.className = 'manage-item-header';
            header.innerHTML = `
                <div class="manage-item-title">
                    ${list.name}
                    <span style="font-size: 11px; color: #999; margin-left: 10px;">${list.devices.length} device(s)</span>
                </div>
                <div class="manage-item-actions">
                    <button class="btn-sm btn-edit" onclick="editDeviceListItem(${list.id})">Edit</button>
                    <button class="btn-sm btn-delete" onclick="deleteDeviceListFromManage(${list.id})">Delete</button>
                </div>
            `;

            const content = document.createElement('div');
            content.className = 'manage-item-content';
            content.id = `device-content-${list.id}`;
            content.style.display = 'none';
            content.innerHTML = `
                <div style="color: #666; font-size: 12px; margin-bottom: 5px;">Devices (one per line):</div>
                <div style="font-family: monospace; background: white; padding: 8px; border: 1px solid #ddd; border-radius: 3px; max-height: 150px; overflow-y: auto;">
                    ${list.devices.join('<br>')}
                </div>
            `;

            container.appendChild(header);
            container.appendChild(content);
            return container;
        }

        function editDeviceListItem(listId) {
            const container = document.getElementById(`device-item-${listId}`);
            const content = document.getElementById(`device-content-${listId}`);

            // Find the list data
            fetch(`/saved-items/api/device-lists/${listId}`)
                .then(response => response.json())
                .then(list => {
                    container.classList.add('editing');
                    content.style.display = 'block';

                    content.innerHTML = `
                        <div style="margin-bottom: 10px;">
                            <label style="font-size: 12px; color: #666;">Name:</label>
                            <input type="text" id="edit-device-name-${listId}" value="${list.name}" />
                        </div>
                        <div style="margin-bottom: 10px;">
                            <label style="font-size: 12px; color: #666;">Devices (one per line):</label>
                            <textarea id="edit-device-list-${listId}">${list.devices.join('\n')}</textarea>
                        </div>
                        <div style="display: flex; gap: 5px;">
                            <button class="btn-sm btn-save" onclick="saveDeviceListItem(${listId})">Save Changes</button>
                            <button class="btn-sm btn-cancel" onclick="cancelEditDeviceListItem(${listId})">Cancel</button>
                        </div>
                    `;
                });
        }

        function cancelEditDeviceListItem(listId) {
            const container = document.getElementById(`device-item-${listId}`);
            const content = document.getElementById(`device-content-${listId}`);
            container.classList.remove('editing');
            content.style.display = 'none';
            manageDeviceLists(); // Refresh to show original content
        }

        async function saveDeviceListItem(listId) {
            const name = document.getElementById(`edit-device-name-${listId}`).value.trim();
            const devicesText = document.getElementById(`edit-device-list-${listId}`).value.trim();

            if (!name) {
                alert('Please enter a name');
                return;
            }

            const devices = devicesText.split('\n').map(d => d.trim()).filter(d => d);
            if (devices.length === 0) {
                alert('Please enter at least one device');
                return;
            }

            try {
                const response = await fetch(`/saved-items/api/device-lists/${listId}/update`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ name, devices })
                });

                const data = await response.json();
                if (data.success) {
                    // alert('Device list updated successfully!');
                    manageDeviceLists(); // Refresh the list
                } else {
                    alert(`Error: ${data.error}`);
                }
            } catch (error) {
                alert(`Error updating device list: ${error.message}`);
            }
        }

        async function deleteDeviceListFromManage(listId) {
            if (!confirm('Delete this device list?')) return;

            try {
                const response = await fetch(`/saved-items/api/device-lists/${listId}/delete`, {
                    method: 'POST'
                });

                const data = await response.json();
                if (data.success) {
                    manageDeviceLists(); // Refresh the list
                } else {
                    alert(`Error: ${data.error}`);
                }
            } catch (error) {
                alert(`Error deleting device list: ${error.message}`);
            }
        }

        function closeManageDeviceListsModal() {
            document.getElementById('manageDeviceListsModal').style.display = 'none';
        }

        // ===== Manage Command Lists =====
        async function manageCommandLists() {
            const contentDiv = document.getElementById('manageCommandListsContent');
            contentDiv.innerHTML = '<em>Loading...</em>';
            document.getElementById('manageCommandListsModal').style.display = 'block';

            try {
                const response = await fetch('/saved-items/api/commands');
                if (!response.ok) throw new Error('Failed to load commands');

                const lists = await response.json();

                if (lists.length === 0) {
                    contentDiv.innerHTML = '<p style="text-align: center; color: #666;">No saved commands in database. Use "Save" button to create one.</p>';
                } else {
                    contentDiv.innerHTML = '';
                    lists.forEach(list => {
                        contentDiv.appendChild(createManageCommandItem(list));
                    });
                }
            } catch (error) {
                contentDiv.innerHTML = `<p style="color: red;">Error loading commands: ${error.message}</p>`;
            }
        }

        function createManageCommandItem(list) {
            const container = document.createElement('div');
            container.className = 'manage-item';
            container.id = `command-item-${list.id}`;

            const vendorLabel = list.vendor ? `[${list.vendor}]` : '';

            const header = document.createElement('div');
            header.className = 'manage-item-header';
            header.innerHTML = `
                <div class="manage-item-title">
                    ${list.name} ${vendorLabel}
                    <span style="font-size: 11px; color: #999; margin-left: 10px;">${list.commands.length} command(s)</span>
                </div>
                <div class="manage-item-actions">
                    <button class="btn-sm btn-edit" onclick="editCommandListItem(${list.id})">Edit</button>
                    <button class="btn-sm btn-delete" onclick="deleteCommandListFromManage(${list.id})">Delete</button>
                </div>
            `;

            const content = document.createElement('div');
            content.className = 'manage-item-content';
            content.id = `command-content-${list.id}`;
            content.style.display = 'none';
            content.innerHTML = `
                <div style="color: #666; font-size: 12px; margin-bottom: 5px;">Commands:</div>
                <div style="font-family: monospace; background: white; padding: 8px; border: 1px solid #ddd; border-radius: 3px; max-height: 150px; overflow-y: auto;">
                    ${list.commands.join('<br>')}
                </div>
            `;

            container.appendChild(header);
            container.appendChild(content);
            return container;
        }

        function editCommandListItem(listId) {
            const container = document.getElementById(`command-item-${listId}`);
            const content = document.getElementById(`command-content-${listId}`);

            fetch(`/saved-items/api/commands/${listId}`)
                .then(response => response.json())
                .then(list => {
                    container.classList.add('editing');
                    content.style.display = 'block';

                    const vendors = ['all', 'cisco_ios', 'cisco_nxos', 'cisco_iosxr', 'cisco_asa', 'arista', 'juniper', 'paloalto', 'fortigate'];
                    const vendorOptions = vendors.map(v => `<option value="${v}" ${v === list.vendor ? 'selected' : ''}>${v}</option>`).join('');

                    content.innerHTML = `
                        <div style="margin-bottom: 10px;">
                            <label style="font-size: 12px; color: #666;">Name:</label>
                            <input type="text" id="edit-command-name-${listId}" value="${list.name}" />
                        </div>
                        <div style="margin-bottom: 10px;">
                            <label style="font-size: 12px; color: #666;">Vendor:</label>
                            <select id="edit-command-vendor-${listId}" style="width: 100%; padding: 5px; border: 1px solid #ccc; border-radius: 3px;">
                                ${vendorOptions}
                            </select>
                        </div>
                        <div style="margin-bottom: 10px;">
                            <label style="font-size: 12px; color: #666;">Commands (one per line):</label>
                            <textarea id="edit-command-list-${listId}">${list.commands.join('\n')}</textarea>
                        </div>
                        <div style="display: flex; gap: 5px;">
                            <button class="btn-sm btn-save" onclick="saveCommandListItem(${listId})">Save Changes</button>
                            <button class="btn-sm btn-cancel" onclick="cancelEditCommandListItem(${listId})">Cancel</button>
                        </div>
                    `;
                });
        }

        function cancelEditCommandListItem(listId) {
            const container = document.getElementById(`command-item-${listId}`);
            const content = document.getElementById(`command-content-${listId}`);
            container.classList.remove('editing');
            content.style.display = 'none';
            manageCommandLists(); // Refresh
        }

        async function saveCommandListItem(listId) {
            const name = document.getElementById(`edit-command-name-${listId}`).value.trim();
            const vendor = document.getElementById(`edit-command-vendor-${listId}`).value;
            const commandsText = document.getElementById(`edit-command-list-${listId}`).value.trim();

            if (!name) {
                alert('Please enter a name');
                return;
            }

            const commands = commandsText.split('\n').map(c => c.trim()).filter(c => c);
            if (commands.length === 0) {
                alert('Please enter at least one command');
                return;
            }

            try {
                const response = await fetch(`/saved-items/api/commands/${listId}/update`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ name, vendor, commands })
                });

                const data = await response.json();
                if (data.success) {
                    alert('Command list updated successfully!');
                    manageCommandLists(); // Refresh
                } else {
                    alert(`Error: ${data.error}`);
                }
            } catch (error) {
                alert(`Error updating command list: ${error.message}`);
            }
        }

        async function deleteCommandListFromManage(listId) {
            if (!confirm('Delete this command list?')) return;

            try {
                const response = await fetch(`/saved-items/api/commands/${listId}/delete`, {
                    method: 'POST'
                });

                const data = await response.json();
                if (data.success) {
                    manageCommandLists(); // Refresh
                } else {
                    alert(`Error: ${data.error}`);
                }
            } catch (error) {
                alert(`Error deleting command list: ${error.message}`);
            }
        }

        function closeManageCommandListsModal() {
            document.getElementById('manageCommandListsModal').style.display = 'none';
        }

        // Save/Load functionality for traceroute targets
        function saveTracerouteTargets() {
            const tracerouteTargets = document.getElementById('tracerouteTargets').value.trim();

            if (!tracerouteTargets) {
                alert('No traceroute targets to save');
                return;
            }

            document.getElementById('saveTracerouteTargetsModal').style.display = 'block';
            document.getElementById('tracerouteTargetsListName').focus();
        }

        function closeSaveTracerouteTargetsModal() {
            document.getElementById('saveTracerouteTargetsModal').style.display = 'none';
            document.getElementById('tracerouteTargetsListName').value = '';
        }

        function confirmSaveTracerouteTargets() {
            const listName = document.getElementById('tracerouteTargetsListName').value.trim();
            if (!listName) {
                alert('Please enter a list name');
                return;
            }

            const tracerouteTargets = document.getElementById('tracerouteTargets').value.trim();
            const targetList = tracerouteTargets.split('\n').map(t => t.trim()).filter(t => t.length > 0);

            // Save to localStorage
            let savedTracerouteTargetLists = JSON.parse(localStorage.getItem('savedTracerouteTargetLists') || '{}');
            savedTracerouteTargetLists[listName] = {
                targets: targetList,
                savedAt: new Date().toISOString()
            };
            localStorage.setItem('savedTracerouteTargetLists', JSON.stringify(savedTracerouteTargetLists));

            alert(`Traceroute target list "${listName}" saved successfully!`);
            closeSaveTracerouteTargetsModal();
        }

        function loadTracerouteTargets() {
            const savedTracerouteTargetLists = JSON.parse(localStorage.getItem('savedTracerouteTargetLists') || '{}');
            const savedListsDiv = document.getElementById('savedTracerouteTargetLists');

            if (Object.keys(savedTracerouteTargetLists).length === 0) {
                savedListsDiv.innerHTML = '<em>No saved traceroute target lists found...</em>';
            } else {
                savedListsDiv.innerHTML = '';

                // Add predefined common target lists
                const commonTargetLists = {
                    'Public DNS Servers': ['8.8.8.8', '1.1.1.1', '208.67.222.222', '9.9.9.9'],
                    'Internet Destinations': ['google.com', 'cloudflare.com', 'github.com', 'stackoverflow.com'],
                    'Network Test Sites': ['test-ipv6.com', 'ipv6-test.com', 'whatismyipaddress.com'],
                    'RFC3330 Test IPs': ['192.0.2.1', '198.51.100.1', '203.0.113.1']
                };

                // Add common target lists section
                const commonHeader = document.createElement('div');
                commonHeader.innerHTML = '<strong style="color: #007cba;">Common Target Lists:</strong>';
                commonHeader.style.marginBottom = '10px';
                savedListsDiv.appendChild(commonHeader);

                for (const [listName, targets] of Object.entries(commonTargetLists)) {
                    const savedItem = document.createElement('div');
                    savedItem.className = 'saved-item';
                    savedItem.style.borderColor = '#007cba';

                    const itemInfo = document.createElement('div');
                    itemInfo.innerHTML = `
                        <div class="saved-item-name">${listName}</div>
                        <div class="saved-item-count">${targets.length} targets</div>
                    `;

                    savedItem.appendChild(itemInfo);
                    savedItem.onclick = () => confirmLoadTracerouteTargets(listName, targets);
                    savedListsDiv.appendChild(savedItem);
                }

                // Add separator
                const separator = document.createElement('div');
                separator.innerHTML = '<hr style="margin: 15px 0;"><strong style="color: #28a745;">Saved Lists:</strong>';
                separator.style.marginBottom = '10px';
                savedListsDiv.appendChild(separator);

                // Add saved target lists
                for (const [listName, listData] of Object.entries(savedTracerouteTargetLists)) {
                    const savedItem = document.createElement('div');
                    savedItem.className = 'saved-item';

                    const itemInfo = document.createElement('div');
                    itemInfo.innerHTML = `
                        <div class="saved-item-name">${listName}</div>
                        <div class="saved-item-count">${listData.targets.length} targets - Saved: ${new Date(listData.savedAt).toLocaleDateString()}</div>
                    `;

                    const deleteBtn = document.createElement('span');
                    deleteBtn.className = 'delete-saved';
                    deleteBtn.innerHTML = '‚úó';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        deleteTracerouteTargetList(listName);
                    };

                    savedItem.appendChild(itemInfo);
                    savedItem.appendChild(deleteBtn);

                    savedItem.onclick = () => confirmLoadTracerouteTargets(listName, listData.targets);
                    savedListsDiv.appendChild(savedItem);
                }
            }

            document.getElementById('loadTracerouteTargetsModal').style.display = 'block';
        }

        function closeLoadTracerouteTargetsModal() {
            document.getElementById('loadTracerouteTargetsModal').style.display = 'none';
        }

        function confirmLoadTracerouteTargets(listName, targetList) {
            const tracerouteTargetsTextarea = document.getElementById('tracerouteTargets');
            const currentTargets = tracerouteTargetsTextarea.value.trim();

            if (currentTargets) {
                if (!confirm(`This will replace your current target list. Continue?`)) {
                    return;
                }
            }

            tracerouteTargetsTextarea.value = targetList.join('\n');
            closeLoadTracerouteTargetsModal();
        }

        function deleteTracerouteTargetList(listName) {
            if (confirm(`Delete traceroute target list "${listName}"?`)) {
                let savedTracerouteTargetLists = JSON.parse(localStorage.getItem('savedTracerouteTargetLists') || '{}');
                delete savedTracerouteTargetLists[listName];
                localStorage.setItem('savedTracerouteTargetLists', JSON.stringify(savedTracerouteTargetLists));
                loadTracerouteTargets(); // Refresh the modal
            }
        }

        // Close modals when clicking outside
        window.onclick = function(event) {
            const modals = ['saveDeviceModal', 'loadDeviceModal', 'saveCommandModal', 'loadCommandModal', 'manageDeviceListsModal', 'manageCommandListsModal', 'savedResultsModal', 'saveDnsServerModal', 'loadDnsServerModal', 'saveTracerouteTargetsModal', 'loadTracerouteTargetsModal'];
            modals.forEach(modalId => {
                const modal = document.getElementById(modalId);
                if (event.target === modal) {
                    modal.style.display = 'none';
                }
            });
        };

        // Add Enter key support for save modals
        document.getElementById('deviceListName').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                confirmSaveDeviceList();
            }
        });

        document.getElementById('commandListName').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                confirmSaveCommandList();
            }
        });

        // DNS Lookup functionality
        async function performDnsLookup() {
            const dnsInput = document.getElementById('dnsInput').value.trim();
            const dnsServers = document.getElementById('dnsServers').value.trim();
            const lookupType = document.getElementById('lookupType').value;
            const dnsResults = document.getElementById('dnsResults');
            const dnsProgress = document.getElementById('dnsProgress');

            if (!dnsInput) {
                alert('Please enter at least one domain or IP address');
                return;
            }

            // Parse input - split by lines and filter empty lines
            const targets = dnsInput.split('\n').map(line => line.trim()).filter(line => line.length > 0);
            const servers = dnsServers ? dnsServers.split('\n').map(line => line.trim()).filter(line => line.length > 0) : [];

            // Validate all targets
            const invalidTargets = [];
            for (const target of targets) {
                const validation = validateDnsTarget(target, lookupType);
                if (!validation.isValid) {
                    invalidTargets.push(`${target}: ${validation.message}`);
                }
            }

            // Validate all DNS servers
            const invalidServers = [];
            for (const server of servers) {
                const validation = validateDnsServer(server);
                if (!validation.isValid) {
                    invalidServers.push(`${server}: ${validation.message}`);
                }
            }

            // Check for validation errors
            const allErrors = [...invalidTargets, ...invalidServers];
            if (allErrors.length > 0) {
                alert('Invalid input(s) detected:\n\n' + allErrors.join('\n') + '\n\nPlease correct these entries and try again.');
                return;
            }

            dnsProgress.style.display = 'block';
            dnsResults.innerHTML = 'Performing DNS lookups...';

            try {
                const response = await fetch('/api/dns-lookup', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        targets: targets,
                        servers: servers,
                        lookup_type: lookupType
                    })
                });

                const data = await response.json();

                if (data.success) {
                    displayDnsResults(data.results);
                } else {
                    dnsResults.innerHTML = `Error: ${data.error}`;
                }
            } catch (error) {
                console.error('DNS lookup error:', error);
                dnsResults.innerHTML = `Error performing DNS lookup: ${error.message}`;
            } finally {
                dnsProgress.style.display = 'none';
            }
        }

        function displayDnsResults(results) {
            const dnsResults = document.getElementById('dnsResults');
            let output = [];

            output.push('DNS LOOKUP RESULTS');
            output.push('==================');
            output.push('');

            for (const [target, targetData] of Object.entries(results)) {
                if (targetData.error) {
                    output.push(`${target} - ERROR: ${targetData.error}`);
                    output.push('');
                    continue;
                }

                // Process results from each DNS server
                for (const [server, serverResults] of Object.entries(targetData.servers)) {
                    const serverName = server === 'system_default' ? 'System DNS' : server;

                    if (serverResults.error) {
                        output.push(`${target} - ERROR: ${serverResults.error} - DNS Server: ${serverName}`);
                    } else if (serverResults.records && serverResults.records.length > 0) {
                        serverResults.records.forEach(record => {
                            // Simplified single-line format for A and PTR records
                            if (record.type === 'A' || record.type === 'PTR') {
                                const ttlInfo = record.ttl ? ` - TTL: ${record.ttl}` : '';
                                output.push(`${target} ${record.value} - DNS Server: ${serverName}${ttlInfo}`);
                            } else {
                                // Keep more detailed format for other record types
                                const ttlInfo = record.ttl ? ` - TTL: ${record.ttl}` : '';
                                output.push(`${target} - ${record.type}: ${record.value} - DNS Server: ${serverName}${ttlInfo}`);
                            }
                        });
                    } else {
                        output.push(`${target} - No records found - DNS Server: ${serverName}`);
                    }
                }
                output.push('');
            }

            dnsResults.textContent = output.join('\n');
        }

        function copyDnsResults() {
            const dnsResults = document.getElementById('dnsResults');
            const textToCopy = dnsResults.textContent;

            navigator.clipboard.writeText(textToCopy).then(() => {
                // Visual feedback on the copy button
                const copyButton = document.getElementById('copyDnsButton');
                const originalText = copyButton.textContent;
                copyButton.textContent = 'Copied!';
                copyButton.style.backgroundColor = '#4caf50';
                copyButton.style.color = 'white';

                setTimeout(() => {
                    copyButton.textContent = originalText;
                    copyButton.style.backgroundColor = '';
                    copyButton.style.color = '';
                }, 1000);
            }).catch(err => {
                console.error('Failed to copy text: ', err);
                alert('Failed to copy to clipboard');
            });
        }

        // Save/Load functionality for DNS server lists
        function saveDnsServerList() {
            const dnsServers = document.getElementById('dnsServers').value.trim();

            if (!dnsServers) {
                alert('No DNS servers to save');
                return;
            }

            document.getElementById('saveDnsServerModal').style.display = 'block';
            document.getElementById('dnsServerListName').focus();
        }

        function closeSaveDnsServerModal() {
            document.getElementById('saveDnsServerModal').style.display = 'none';
            document.getElementById('dnsServerListName').value = '';
        }

        function confirmSaveDnsServerList() {
            const listName = document.getElementById('dnsServerListName').value.trim();
            if (!listName) {
                alert('Please enter a list name');
                return;
            }

            const dnsServers = document.getElementById('dnsServers').value.trim();
            const serverList = dnsServers.split('\n').map(s => s.trim()).filter(s => s.length > 0);

            // Save to localStorage
            let savedDnsServerLists = JSON.parse(localStorage.getItem('savedDnsServerLists') || '{}');
            savedDnsServerLists[listName] = {
                servers: serverList,
                savedAt: new Date().toISOString()
            };
            localStorage.setItem('savedDnsServerLists', JSON.stringify(savedDnsServerLists));

            alert(`DNS server list "${listName}" saved successfully!`);
            closeSaveDnsServerModal();
        }

        function loadDnsServerList() {
            const savedDnsServerLists = JSON.parse(localStorage.getItem('savedDnsServerLists') || '{}');
            const savedListsDiv = document.getElementById('savedDnsServerLists');

            if (Object.keys(savedDnsServerLists).length === 0) {
                savedListsDiv.innerHTML = '<em>No saved DNS server lists found...</em>';
            } else {
                savedListsDiv.innerHTML = '';

                // Add predefined common DNS server lists
                const commonDnsLists = {
                    'Public DNS - Google': ['8.8.8.8', '8.8.4.4'],
                    'Public DNS - Cloudflare': ['1.1.1.1', '1.0.0.1'],
                    'Public DNS - OpenDNS': ['208.67.222.222', '208.67.220.220'],
                    'Public DNS - Quad9': ['9.9.9.9', '149.112.112.112'],
                    'Public DNS - All Combined': ['8.8.8.8', '1.1.1.1', '208.67.222.222', '9.9.9.9']
                };

                // Add common DNS lists section
                const commonHeader = document.createElement('div');
                commonHeader.innerHTML = '<strong style="color: #007cba;">Common DNS Servers:</strong>';
                commonHeader.style.marginBottom = '10px';
                savedListsDiv.appendChild(commonHeader);

                for (const [listName, servers] of Object.entries(commonDnsLists)) {
                    const savedItem = document.createElement('div');
                    savedItem.className = 'saved-item';
                    savedItem.style.borderColor = '#007cba';

                    const itemInfo = document.createElement('div');
                    itemInfo.innerHTML = `
                        <div class="saved-item-name">${listName}</div>
                        <div class="saved-item-count">${servers.length} servers</div>
                    `;

                    savedItem.appendChild(itemInfo);
                    savedItem.onclick = () => confirmLoadDnsServerList(listName, servers);
                    savedListsDiv.appendChild(savedItem);
                }

                // Add separator
                const separator = document.createElement('div');
                separator.innerHTML = '<hr style="margin: 15px 0;"><strong style="color: #28a745;">Saved Lists:</strong>';
                separator.style.marginBottom = '10px';
                savedListsDiv.appendChild(separator);

                // Add saved DNS lists
                for (const [listName, listData] of Object.entries(savedDnsServerLists)) {
                    const savedItem = document.createElement('div');
                    savedItem.className = 'saved-item';

                    const itemInfo = document.createElement('div');
                    itemInfo.innerHTML = `
                        <div class="saved-item-name">${listName}</div>
                        <div class="saved-item-count">${listData.servers.length} servers - Saved: ${new Date(listData.savedAt).toLocaleDateString()}</div>
                    `;

                    const deleteBtn = document.createElement('span');
                    deleteBtn.className = 'delete-saved';
                    deleteBtn.innerHTML = '‚úó';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        deleteDnsServerList(listName);
                    };

                    savedItem.appendChild(itemInfo);
                    savedItem.appendChild(deleteBtn);

                    savedItem.onclick = () => confirmLoadDnsServerList(listName, listData.servers);
                    savedListsDiv.appendChild(savedItem);
                }
            }

            document.getElementById('loadDnsServerModal').style.display = 'block';
        }

        function closeLoadDnsServerModal() {
            document.getElementById('loadDnsServerModal').style.display = 'none';
        }

        function confirmLoadDnsServerList(listName, serverList) {
            const dnsServersTextarea = document.getElementById('dnsServers');
            dnsServersTextarea.value = serverList.join('\n');
            closeLoadDnsServerModal();
        }

        function deleteDnsServerList(listName) {
            if (confirm(`Delete DNS server list "${listName}"?`)) {
                let savedDnsServerLists = JSON.parse(localStorage.getItem('savedDnsServerLists') || '{}');
                delete savedDnsServerLists[listName];
                localStorage.setItem('savedDnsServerLists', JSON.stringify(savedDnsServerLists));
                loadDnsServerList(); // Refresh the modal
            }
        }

        // Add Enter key support for DNS server save modal
        document.getElementById('dnsServerListName').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                confirmSaveDnsServerList();
            }
        });

        // Add Enter key support for traceroute targets save modal
        document.getElementById('tracerouteTargetsListName').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                confirmSaveTracerouteTargets();
            }
        });

        // Traceroute functionality
        let tracerouteResultsData = {};
        let tracerouteEventSource = null;
        let currentTracerouteData = {};

        // Function to validate hostname or IP address for traceroute
        function validateTracerouteTarget(target) {
            // Remove any whitespace
            target = target.trim();

            // Check for spaces or invalid characters
            if (target.includes(' ')) {
                return { isValid: false, message: 'Spaces are not allowed' };
            }

            // IPv4 address pattern
            const ipv4Pattern = /^(\d{1,3}\.){3}\d{1,3}$/;

            // IPv6 address pattern (simplified)
            const ipv6Pattern = /^([0-9a-fA-F]{0,4}:){2,7}[0-9a-fA-F]{0,4}$/;

            // Hostname/domain pattern - only allows letters, numbers, dots, and hyphens
            // Must start and end with alphanumeric, can contain dots and hyphens in the middle
            const hostnamePattern = /^[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?)*$/;

            // Check if it's an IPv4 address
            if (ipv4Pattern.test(target)) {
                // Validate IPv4 octets are in range 0-255
                const octets = target.split('.');
                for (const octet of octets) {
                    const num = parseInt(octet);
                    if (num < 0 || num > 255) {
                        return { isValid: false, message: 'Invalid IPv4 address (octets must be 0-255)' };
                    }
                }
                return { isValid: true, type: 'ipv4' };
            }

            // Check if it's an IPv6 address
            if (ipv6Pattern.test(target) || target.includes(':')) {
                // Basic IPv6 validation
                if (target.match(/[^0-9a-fA-F:]/)) {
                    return { isValid: false, message: 'Invalid IPv6 address (contains invalid characters)' };
                }
                return { isValid: true, type: 'ipv6' };
            }

            // Check if it's a valid hostname/domain
            if (hostnamePattern.test(target)) {
                // Additional hostname validations
                if (target.length > 253) {
                    return { isValid: false, message: 'Hostname too long (max 253 characters)' };
                }

                // Check each label (part between dots)
                const labels = target.split('.');
                for (const label of labels) {
                    if (label.length > 63) {
                        return { isValid: false, message: 'Domain label too long (max 63 characters per label)' };
                    }
                    if (label.startsWith('-') || label.endsWith('-')) {
                        return { isValid: false, message: 'Domain labels cannot start or end with hyphens' };
                    }
                }

                return { isValid: true, type: 'hostname' };
            }

            // Check for common invalid characters
            const invalidChars = target.match(/[^a-zA-Z0-9.\-:]/);
            if (invalidChars) {
                return {
                    isValid: false,
                    message: `Invalid character(s) found: ${invalidChars.join(', ')}. Only letters, numbers, dots, hyphens, and colons (for IPv6) are allowed.`
                };
            }

            return { isValid: false, message: 'Invalid format. Please enter a valid IP address or hostname.' };
        }

        // Function to validate DNS lookup target (hostname, IP, or domain)
        function validateDnsTarget(target, lookupType) {
            // Remove any whitespace
            target = target.trim();

            // Check for spaces or invalid characters
            if (target.includes(' ')) {
                return { isValid: false, message: 'Spaces are not allowed' };
            }

            // IPv4 address pattern
            const ipv4Pattern = /^(\d{1,3}\.){3}\d{1,3}$/;

            // IPv6 address pattern (simplified)
            const ipv6Pattern = /^([0-9a-fA-F]{0,4}:){2,7}[0-9a-fA-F]{0,4}$/;

            // Hostname/domain pattern - only allows letters, numbers, dots, and hyphens
            const hostnamePattern = /^[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?)*$/;

            // Check if it's an IPv4 address
            if (ipv4Pattern.test(target)) {
                // Validate IPv4 octets are in range 0-255
                const octets = target.split('.');
                for (const octet of octets) {
                    const num = parseInt(octet);
                    if (num < 0 || num > 255) {
                        return { isValid: false, message: 'Invalid IPv4 address (octets must be 0-255)' };
                    }
                }

                // IP addresses are valid for all lookup types
                return { isValid: true, type: 'ipv4' };
            }

            // Check if it's an IPv6 address
            if (ipv6Pattern.test(target) || target.includes(':')) {
                // Basic IPv6 validation
                if (target.match(/[^0-9a-fA-F:]/)) {
                    return { isValid: false, message: 'Invalid IPv6 address (contains invalid characters)' };
                }

                // IPv6 addresses are valid for all lookup types
                return { isValid: true, type: 'ipv6' };
            }

            // Check if it's a valid hostname/domain
            if (hostnamePattern.test(target)) {
                // Additional hostname validations
                if (target.length > 253) {
                    return { isValid: false, message: 'Hostname too long (max 253 characters)' };
                }

                // Check each label (part between dots)
                const labels = target.split('.');
                for (const label of labels) {
                    if (label.length > 63) {
                        return { isValid: false, message: 'Domain label too long (max 63 characters per label)' };
                    }
                    if (label.startsWith('-') || label.endsWith('-')) {
                        return { isValid: false, message: 'Domain labels cannot start or end with hyphens' };
                    }
                }

                // Hostnames are valid for all lookup types
                return { isValid: true, type: 'hostname' };
            }

            // Check for common invalid characters
            const invalidChars = target.match(/[^a-zA-Z0-9.\-:]/);
            if (invalidChars) {
                return {
                    isValid: false,
                    message: `Invalid character(s) found: ${invalidChars.join(', ')}. Only letters, numbers, dots, hyphens, and colons (for IPv6) are allowed.`
                };
            }

            return { isValid: false, message: 'Invalid format. Please enter a valid IP address or hostname.' };
        }

        // Function to validate DNS server address
        function validateDnsServer(server) {
            server = server.trim();

            // Check for spaces
            if (server.includes(' ')) {
                return { isValid: false, message: 'Spaces are not allowed in DNS server addresses' };
            }

            // IPv4 address pattern
            const ipv4Pattern = /^(\d{1,3}\.){3}\d{1,3}$/;

            // IPv6 address pattern (simplified)
            const ipv6Pattern = /^([0-9a-fA-F]{0,4}:){2,7}[0-9a-fA-F]{0,4}$/;

            // Check if it's an IPv4 address
            if (ipv4Pattern.test(server)) {
                const octets = server.split('.');
                for (const octet of octets) {
                    const num = parseInt(octet);
                    if (num < 0 || num > 255) {
                        return { isValid: false, message: 'Invalid IPv4 address (octets must be 0-255)' };
                    }
                }
                return { isValid: true, type: 'ipv4' };
            }

            // Check if it's an IPv6 address
            if (ipv6Pattern.test(server) || server.includes(':')) {
                if (server.match(/[^0-9a-fA-F:]/)) {
                    return { isValid: false, message: 'Invalid IPv6 address (contains invalid characters)' };
                }
                return { isValid: true, type: 'ipv6' };
            }

            return { isValid: false, message: 'DNS servers must be valid IP addresses' };
        }

        // Function to validate DNS input in real-time
        function validateDnsInput() {
            const textarea = document.getElementById('dnsInput');
            const serversTextarea = document.getElementById('dnsServers');
            const lookupType = document.getElementById('lookupType').value;
            const validationDiv = document.getElementById('dnsValidation');
            const serversValidationDiv = document.getElementById('dnsServersValidation');

            const input = textarea.value.trim();
            const serversInput = serversTextarea.value.trim();

            // Validate targets
            if (!input) {
                validationDiv.innerHTML = '';
                textarea.style.borderColor = '';
            } else {
                const targets = input.split('\n').map(line => line.trim()).filter(line => line.length > 0);
                const invalidTargets = [];
                const validTargets = [];

                for (const target of targets) {
                    const validation = validateDnsTarget(target, lookupType);
                    if (!validation.isValid) {
                        invalidTargets.push(`${target}: ${validation.message}`);
                    } else {
                        validTargets.push(`${target} (${validation.type})`);
                    }
                }

                if (invalidTargets.length > 0) {
                    textarea.style.borderColor = '#dc3545';
                    validationDiv.innerHTML = `
                        <div style="color: #dc3545; font-size: 12px; font-family: monospace;">
                            <strong>‚ùå ${invalidTargets.length} invalid target(s):</strong><br>
                            ${invalidTargets.slice(0, 3).join('<br>')}
                            ${invalidTargets.length > 3 ? `<br>... and ${invalidTargets.length - 3} more` : ''}
                        </div>
                    `;
                } else {
                    textarea.style.borderColor = '#28a745';
                    validationDiv.innerHTML = `
                        <div style="color: #28a745; font-size: 12px; font-family: monospace;">
                            <strong>‚úÖ ${validTargets.length} valid target(s)</strong>
                            ${validTargets.length <= 3 ? '<br>' + validTargets.join('<br>') : ''}
                        </div>
                    `;
                }
            }

            // Validate DNS servers
            if (!serversInput) {
                serversValidationDiv.innerHTML = '<div style="color: #6c757d; font-size: 12px;">Using system default DNS servers</div>';
                serversTextarea.style.borderColor = '';
            } else {
                const servers = serversInput.split('\n').map(line => line.trim()).filter(line => line.length > 0);
                const invalidServers = [];
                const validServers = [];

                for (const server of servers) {
                    const validation = validateDnsServer(server);
                    if (!validation.isValid) {
                        invalidServers.push(`${server}: ${validation.message}`);
                    } else {
                        validServers.push(`${server} (${validation.type})`);
                    }
                }

                if (invalidServers.length > 0) {
                    serversTextarea.style.borderColor = '#dc3545';
                    serversValidationDiv.innerHTML = `
                        <div style="color: #dc3545; font-size: 12px; font-family: monospace;">
                            <strong>‚ùå ${invalidServers.length} invalid DNS server(s):</strong><br>
                            ${invalidServers.slice(0, 2).join('<br>')}
                            ${invalidServers.length > 2 ? `<br>... and ${invalidServers.length - 2} more` : ''}
                        </div>
                    `;
                } else {
                    serversTextarea.style.borderColor = '#28a745';
                    serversValidationDiv.innerHTML = `
                        <div style="color: #28a745; font-size: 12px; font-family: monospace;">
                            <strong>‚úÖ ${validServers.length} valid DNS server(s)</strong>
                            ${validServers.length <= 3 ? '<br>' + validServers.join('<br>') : ''}
                        </div>
                    `;
                }
            }
        }

        // Function to validate traceroute input in real-time
        function validateTracerouteInput() {
            const textarea = document.getElementById('tracerouteTargets');
            const validationDiv = document.getElementById('tracerouteValidation');
            const input = textarea.value.trim();

            if (!input) {
                validationDiv.innerHTML = '';
                textarea.style.borderColor = '';
                return;
            }

            const targets = input.split('\n').map(line => line.trim()).filter(line => line.length > 0);
            const invalidTargets = [];
            const validTargets = [];

            for (const target of targets) {
                const validation = validateTracerouteTarget(target);
                if (!validation.isValid) {
                    invalidTargets.push(`${target}: ${validation.message}`);
                } else {
                    validTargets.push(`${target} (${validation.type})`);
                }
            }

            if (invalidTargets.length > 0) {
                textarea.style.borderColor = '#dc3545';
                validationDiv.innerHTML = `
                    <div style="color: #dc3545; font-size: 12px; font-family: monospace;">
                        <strong>‚ùå ${invalidTargets.length} invalid target(s):</strong><br>
                        ${invalidTargets.slice(0, 3).join('<br>')}
                        ${invalidTargets.length > 3 ? `<br>... and ${invalidTargets.length - 3} more` : ''}
                    </div>
                `;
            } else {
                textarea.style.borderColor = '#28a745';
                validationDiv.innerHTML = `
                    <div style="color: #28a745; font-size: 12px; font-family: monospace;">
                        <strong>‚úÖ ${validTargets.length} valid target(s)</strong>
                        ${validTargets.length <= 5 ? ': ' + validTargets.join(', ') : ''}
                    </div>
                `;
            }
        }

        async function performTraceroute() {
            const targetsInput = document.getElementById('tracerouteTargets').value.trim();
            const maxHops = parseInt(document.getElementById('maxHops').value);
            const timeout = parseInt(document.getElementById('traceTimeout').value);
            const probesPerHop = parseInt(document.getElementById('probesPerHop').value);
            const packetSize = parseInt(document.getElementById('packetSize').value);
            const translateIPs = document.getElementById('translateIPs').checked;
            const resolveHostnames = document.getElementById('resolveHostnames').checked;

            const tracerouteResults = document.getElementById('tracerouteResults');
            const tracerouteProgress = document.getElementById('tracerouteProgress');
            const tracerouteProgressDetail = document.getElementById('tracerouteProgressDetail');

            if (!targetsInput) {
                alert('Please enter at least one target host');
                return;
            }

            // Parse input - split by lines and filter empty lines
            const targets = targetsInput.split('\n').map(line => line.trim()).filter(line => line.length > 0);

            // Validate all targets
            const invalidTargets = [];
            for (const target of targets) {
                const validation = validateTracerouteTarget(target);
                if (!validation.isValid) {
                    invalidTargets.push(`${target}: ${validation.message}`);
                }
            }

            if (invalidTargets.length > 0) {
                alert('Invalid target(s) detected:\n\n' + invalidTargets.join('\n') + '\n\nPlease correct these entries and try again.');
                return;
            }

            // Close any existing SSE connection
            if (tracerouteEventSource) {
                tracerouteEventSource.close();
            }

            // Reset data
            currentTracerouteData = {};
            tracerouteResultsData = {};

            // Show stop button, hide run button
            document.getElementById('runTracerouteButton').style.display = 'none';
            document.getElementById('stopTracerouteButton').style.display = 'inline-block';

            tracerouteProgress.style.display = 'block';
            tracerouteProgressDetail.textContent = `Starting traceroutes to ${targets.length} targets...`;
            tracerouteResults.innerHTML = '';

            // Initialize display for each target
            targets.forEach(target => {
                currentTracerouteData[target] = { hops: [] };
            });

            // Build query parameters
            const params = new URLSearchParams({
                targets: targets.join(','),
                max_hops: maxHops,
                timeout: timeout,
                probes_per_hop: probesPerHop,
                packet_size: packetSize,
                translate_ips: translateIPs,
                resolve_hostnames: resolveHostnames
            });

            // Create SSE connection for real-time updates
            tracerouteEventSource = new EventSource(`/api/traceroute-stream?${params}`);

            tracerouteEventSource.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    handleTracerouteUpdate(data, translateIPs);
                } catch (error) {
                    console.error('Error parsing SSE data:', error);
                }
            };

            tracerouteEventSource.onerror = function(error) {
                console.error('SSE error:', error);
                tracerouteEventSource.close();
                tracerouteProgress.style.display = 'none';
                // Show run button, hide stop button
                document.getElementById('runTracerouteButton').style.display = 'inline-block';
                document.getElementById('stopTracerouteButton').style.display = 'none';
            };
        }

        function stopTraceroute() {
            if (tracerouteEventSource) {
                tracerouteEventSource.close();
                tracerouteEventSource = null;
            }

            const tracerouteProgress = document.getElementById('tracerouteProgress');
            const tracerouteProgressDetail = document.getElementById('tracerouteProgressDetail');

            tracerouteProgressDetail.textContent = 'Traceroute stopped by user.';

            setTimeout(() => {
                tracerouteProgress.style.display = 'none';
            }, 1500);

            // Show run button, hide stop button
            document.getElementById('runTracerouteButton').style.display = 'inline-block';
            document.getElementById('stopTracerouteButton').style.display = 'none';
        }

        function handleTracerouteUpdate(data, translateIPs) {
            const tracerouteResults = document.getElementById('tracerouteResults');
            const tracerouteProgressDetail = document.getElementById('tracerouteProgressDetail');

            switch(data.type) {
                case 'init':
                    tracerouteResults.innerHTML = '<div style="font-weight: bold; margin-bottom: 10px;">TRACEROUTE RESULTS (Real-time)</div>';
                    break;

                case 'start':
                    tracerouteProgressDetail.textContent = data.message;
                    // Use display_target if available (includes resolved IP), otherwise use original target
                    const displayTarget = data.display_target || data.target;
                    // Create separate div for this target if it doesn't exist
                    let targetDiv = document.getElementById(`traceroute-${data.target.replace(/[^a-zA-Z0-9]/g, '-')}`);
                    if (!targetDiv) {
                        targetDiv = document.createElement('div');
                        targetDiv.id = `traceroute-${data.target.replace(/[^a-zA-Z0-9]/g, '-')}`;
                        targetDiv.style.cssText = 'margin-bottom: 20px; padding: 10px; border: 1px solid #ccc; background-color: #f9f9f9; font-family: monospace;';

                        const targetHeader = document.createElement('div');
                        targetHeader.style.cssText = 'font-weight: bold; color: #333; margin-bottom: 5px; border-bottom: 1px solid #ddd; padding-bottom: 5px;';
                        targetHeader.textContent = `Target: ${displayTarget}`;
                        targetDiv.appendChild(targetHeader);

                        const hopsContainer = document.createElement('pre');
                        hopsContainer.id = `hops-${data.target.replace(/[^a-zA-Z0-9]/g, '-')}`;
                        hopsContainer.style.cssText = 'margin: 0; white-space: pre-wrap; font-family: monospace;';
                        hopsContainer.textContent = '\n';  // Start with newline so first hop appears on new line
                        targetDiv.appendChild(hopsContainer);

                        tracerouteResults.appendChild(targetDiv);
                    }
                    break;

                case 'hop':
                    // Find the target's div and add hop
                    const targetId = `hops-${data.target.replace(/[^a-zA-Z0-9]/g, '-')}`;
                    const hopsContainer = document.getElementById(targetId);
                    const hop = data.hop;

                    if (hopsContainer) {
                        let hopLine = `${hop.hop_num.toString().padStart(2)}  `;

                        if (hop.probes && hop.probes.length > 0) {
                            hop.probes.forEach(probe => {
                                if (probe.success) {
                                    let probeInfo = '';

                                    // Show IP or hostname
                                    if (probe.hostname && probe.hostname !== probe.ip) {
                                        probeInfo += `${probe.hostname} (${probe.ip})`;
                                    } else {
                                        probeInfo += probe.ip;
                                    }

                                    // Add translated info if available and enabled
                                    if (translateIPs && probe.translated_info) {
                                        probeInfo += ` [${probe.translated_info}]`;
                                    }

                                    // Add RTT
                                    probeInfo += `  ${probe.rtt} ms`;

                                    hopLine += probeInfo + '  ';
                                } else {
                                    hopLine += '*  ';
                                }
                            });
                        } else {
                            hopLine += '* * *';
                        }

                        // Append hop line to target-specific container
                        hopsContainer.textContent += hopLine + '\n';
                    }

                    // Store hop data
                    if (!currentTracerouteData[data.target]) {
                        currentTracerouteData[data.target] = { hops: [] };
                    }
                    currentTracerouteData[data.target].hops.push(hop);
                    break;

                case 'complete':
                    tracerouteProgressDetail.textContent = data.message;
                    // Add completion message to target's div
                    const completedTargetId = `hops-${data.target.replace(/[^a-zA-Z0-9]/g, '-')}`;
                    const completedHopsContainer = document.getElementById(completedTargetId);
                    if (completedHopsContainer) {
                        completedHopsContainer.textContent += '\nTraceroute completed.\n';
                    }
                    // Store completed data
                    tracerouteResultsData[data.target] = currentTracerouteData[data.target];
                    break;

                case 'error':
                    // Add error to target's div or general results if no specific target
                    if (data.target) {
                        const errorTargetId = `hops-${data.target.replace(/[^a-zA-Z0-9]/g, '-')}`;
                        const errorHopsContainer = document.getElementById(errorTargetId);
                        if (errorHopsContainer) {
                            errorHopsContainer.textContent += `Error: ${data.error}\n`;
                        }
                    } else {
                        const errorDiv = document.createElement('div');
                        errorDiv.style.cssText = 'color: red; margin-bottom: 10px; padding: 5px; background-color: #ffe6e6; border: 1px solid #ff9999;';
                        errorDiv.textContent = `Error: ${data.error}`;
                        tracerouteResults.appendChild(errorDiv);
                    }
                    break;

                case 'parse_fail':
                    // Display the unparsed line as a fallback in target's div
                    const parseFailTargetId = `hops-${data.target.replace(/[^a-zA-Z0-9]/g, '-')}`;
                    const parseFailHopsContainer = document.getElementById(parseFailTargetId);
                    if (parseFailHopsContainer && data.line.match(/^\s*\d+/)) {
                        parseFailHopsContainer.textContent += `${data.line}\n`;
                    }
                    break;

                case 'all_complete':
                    document.getElementById('tracerouteProgress').style.display = 'none';
                    tracerouteEventSource.close();
                    // Show run button, hide stop button
                    document.getElementById('runTracerouteButton').style.display = 'inline-block';
                    document.getElementById('stopTracerouteButton').style.display = 'none';
                    break;
            }

            // Auto-scroll to bottom
            const resultsDiv = document.getElementById('tracerouteResults');
            resultsDiv.scrollTop = resultsDiv.scrollHeight;
        }

        function displayTracerouteResults(results, translateIPs) {
            const tracerouteResults = document.getElementById('tracerouteResults');
            let output = [];

            output.push('TRACEROUTE RESULTS');
            output.push('=' .repeat(80));
            output.push('');

            for (const [target, targetData] of Object.entries(results)) {
                // Use display_target if available (includes resolved IP), otherwise use original target
                const displayTarget = targetData.display_target || target;
                output.push(`Target: ${displayTarget}`);
                output.push('-'.repeat(40));

                if (targetData.error) {
                    output.push(`Error: ${targetData.error}`);
                    output.push('');
                    continue;
                }

                if (targetData.hops && targetData.hops.length > 0) {
                    targetData.hops.forEach(hop => {
                        let hopLine = `${hop.hop_num.toString().padStart(2)}  `;

                        if (hop.probes && hop.probes.length > 0) {
                            hop.probes.forEach(probe => {
                                if (probe.success) {
                                    let probeInfo = '';

                                    // Show IP or hostname
                                    if (probe.hostname && probe.hostname !== probe.ip) {
                                        probeInfo += `${probe.hostname} (${probe.ip})`;
                                    } else {
                                        probeInfo += probe.ip;
                                    }

                                    // Add translated info if available and enabled
                                    if (translateIPs && probe.translated_info) {
                                        probeInfo += ` [${probe.translated_info}]`;
                                    }

                                    // Add RTT
                                    probeInfo += `  ${probe.rtt} ms`;

                                    hopLine += probeInfo + '  ';
                                } else {
                                    hopLine += '*  ';
                                }
                            });
                        } else {
                            hopLine += '* * *';
                        }

                        output.push(hopLine);
                    });
                } else {
                    output.push('No hops found or traceroute failed');
                }

                output.push('');
                output.push('');
            }

            tracerouteResults.textContent = output.join('\n');
        }

        function copyTracerouteResults() {
            const tracerouteResults = document.getElementById('tracerouteResults');
            const textToCopy = tracerouteResults.textContent;

            navigator.clipboard.writeText(textToCopy).then(() => {
                // Visual feedback on the copy button
                const copyButton = document.getElementById('copyTracerouteButton');
                const originalText = copyButton.textContent;
                copyButton.textContent = 'Copied!';
                copyButton.style.backgroundColor = '#4caf50';
                copyButton.style.color = 'white';

                setTimeout(() => {
                    copyButton.textContent = originalText;
                    copyButton.style.backgroundColor = '';
                    copyButton.style.color = '';
                }, 1000);
            }).catch(err => {
                console.error('Failed to copy text: ', err);
                alert('Failed to copy to clipboard');
            });
        }

        function translateTracerouteResults() {
            const tracerouteResults = document.getElementById('tracerouteResults').textContent;

            if (!tracerouteResults || tracerouteResults.trim() === '' || tracerouteResults.includes('Traceroute results will appear here')) {
                alert('No traceroute results to translate');
                return;
            }

            // Switch to IP Translator tab
            showTab('ip-translator');

            // Populate the IP translator input with traceroute results
            const ipTranslatorInput = document.getElementById('inputText');
            ipTranslatorInput.value = tracerouteResults;

            // Scroll to the top
            window.scrollTo({ top: 0, behavior: 'smooth' });

            // Automatically trigger the translation
            translateText();

            // Visual feedback on the translate button
            const translateButton = document.getElementById('translateTracerouteButton');
            const originalText = translateButton.textContent;
            translateButton.textContent = 'Translated!';
            translateButton.style.backgroundColor = '#0056b3';

            setTimeout(() => {
                translateButton.textContent = originalText;
                translateButton.style.backgroundColor = '#007bff';
            }, 1500);
        }

        function downloadTracerouteResults() {
            const tracerouteResults = document.getElementById('tracerouteResults').textContent;
            const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
            const filename = `traceroute_results_${timestamp}.txt`;

            const blob = new Blob([tracerouteResults], { type: 'text/plain' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            a.remove();
        }

        // Toggle IP translation in real-time
        document.getElementById('translateIPs').addEventListener('change', function() {
            if (tracerouteResultsData && Object.keys(tracerouteResultsData).length > 0) {
                // Regenerate display with current data
                const translateIPs = this.checked;
                const tracerouteResults = document.getElementById('tracerouteResults');
                let output = [];

                output.push('TRACEROUTE RESULTS');
                output.push('='.repeat(80));
                output.push('');

                for (const [target, targetData] of Object.entries(tracerouteResultsData)) {
                    output.push(`Target: ${target}`);
                    output.push('-'.repeat(40));

                    if (targetData.hops && targetData.hops.length > 0) {
                        targetData.hops.forEach(hop => {
                            let hopLine = `${hop.hop_num.toString().padStart(2)}  `;

                            if (hop.probes && hop.probes.length > 0) {
                                hop.probes.forEach(probe => {
                                    if (probe.success) {
                                        let probeInfo = '';

                                        // Show IP or hostname
                                        if (probe.hostname && probe.hostname !== probe.ip) {
                                            probeInfo += `${probe.hostname} (${probe.ip})`;
                                        } else {
                                            probeInfo += probe.ip;
                                        }

                                        // Add translated info if available and enabled
                                        if (translateIPs && probe.translated_info) {
                                            probeInfo += ` [${probe.translated_info}]`;
                                        }

                                        // Add RTT
                                        probeInfo += `  ${probe.rtt} ms`;

                                        hopLine += probeInfo + '  ';
                                    } else {
                                        hopLine += '*  ';
                                    }
                                });
                            } else {
                                hopLine += '* * *';
                            }

                            output.push(hopLine);
                        });
                    } else {
                        output.push('No hops found or traceroute failed');
                    }

                    output.push('');
                    output.push('');
                }

                tracerouteResults.textContent = output.join('\n');
            }
        });

        // Debounced translation function
        function scheduleTranslation() {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(translateText, 500); // Wait 500ms after user stops typing
        }

        async function translateText() {
            const text = inputText.value.trim();

            if (!text) {
                outputArea.innerHTML = '<em>Your translated text will appear here...</em>';
                return;
            }

            loadingIndicator.style.display = 'block';

            try {
                const response = await fetch(`/api/translate-ip?text=${encodeURIComponent(text)}`);
                const data = await response.json();

                outputArea.innerHTML = data.translated_text || text;

                // Attach event listeners to enhanced IPs
                attachTooltipHandlers();

            } catch (error) {
                console.error('Translation error:', error);
                outputArea.innerHTML = text;
            } finally {
                loadingIndicator.style.display = 'none';
            }
        }

        function attachTooltipHandlers() {
            const enhancedIPs = document.querySelectorAll('.ip-enhanced');

            enhancedIPs.forEach(element => {
                element.addEventListener('mouseenter', showTooltip);
                element.addEventListener('mouseleave', scheduleHideTooltip);
                element.addEventListener('click', handleIPClick);
            });
        }

        let tooltipHideTimer = null;

        function showTooltip(event) {
            // Clear any pending hide timer
            if (tooltipHideTimer) {
                clearTimeout(tooltipHideTimer);
                tooltipHideTimer = null;
            }

            const element = event.target;
            const tooltipDataStr = element.getAttribute('data-tooltip').replace(/&quot;/g, '"');
            const tooltipData = JSON.parse(tooltipDataStr);
            const mgmtIP = element.getAttribute('data-mgmt-ip');

            // Get theme from backend (passed in template)
            const theme = '{{ tooltip_theme }}' || 'light';

            // Define theme colors
            const themes = {
                light: {
                    bg: '#ffffff',
                    text: '#333333',
                    border: '#d4d4d4',
                    shadow: 'rgba(0,0,0,0.16)',
                    divider: '#e5e5e5',
                    hostname: '#0451a5',
                    mgmtIp: '#a31515',
                    label: '#001080',
                    value: '#333333',
                    status: '#098658',
                    link: '#0066cc',
                    linkHoverBg: '#0066cc',
                    linkHoverText: '#ffffff',
                    separator: '#999999'
                },
                dark: {
                    bg: '#1e1e1e',
                    text: '#cccccc',
                    border: '#454545',
                    shadow: 'rgba(0,0,0,0.66)',
                    divider: '#2d2d30',
                    hostname: '#4ec9b0',
                    mgmtIp: '#ce9178',
                    label: '#9cdcfe',
                    value: '#cccccc',
                    status: '#4ec9b0',
                    link: '#3794ff',
                    linkHoverBg: '#3794ff',
                    linkHoverText: '#ffffff',
                    separator: '#808080'
                }
            };

            const colors = themes[theme];

            const tooltipContent = `
                <div style="background: ${colors.bg};
                            color: ${colors.text};
                            padding: 12px;
                            border-radius: 4px;
                            box-shadow: 0 0 0 1px ${colors.border}, 0 4px 11px ${colors.shadow};
                            min-width: 300px;
                            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
                            font-size: 13px;
                            line-height: 1.5;">
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; padding-bottom: 8px; border-bottom: 1px solid ${colors.divider};">
                        <div>
                            <span style="color: ${colors.hostname}; font-weight: 600;">${tooltipData.hostname}</span>
                            <span style="color: ${colors.separator}; margin: 0 6px;">‚Ä¢</span>
                            <span style="color: ${colors.mgmtIp};">${mgmtIP}</span>
                        </div>
                        <a href="ssh://${mgmtIP}"
                           onclick="event.stopPropagation();"
                           style="color: ${colors.link};
                                  text-decoration: none;
                                  font-size: 11px;
                                  padding: 3px 8px;
                                  border: 1px solid ${colors.link};
                                  border-radius: 3px;
                                  background: transparent;
                                  transition: all 0.2s;
                                  white-space: nowrap;"
                           onmouseover="this.style.background='${colors.linkHoverBg}'; this.style.color='${colors.linkHoverText}';"
                           onmouseout="this.style.background='transparent'; this.style.color='${colors.link}';">
                            SSH
                        </a>
                    </div>
                    <div style="font-size: 12px;">
                        <div style="margin-bottom: 4px;">
                            <span style="color: ${colors.label};">Interface:</span>
                            <span style="color: ${colors.value}; margin-left: 4px;">${tooltipData.interface_name}</span>
                        </div>
                        <div style="margin-bottom: 4px;">
                            <span style="color: ${colors.label};">Description:</span>
                            <span style="color: ${colors.value}; margin-left: 4px;">${tooltipData.interface_description}</span>
                        </div>
                        <div style="margin-bottom: 4px;">
                            <span style="color: ${colors.label};">Vendor:</span>
                            <span style="color: ${colors.value}; margin-left: 4px;">${tooltipData.device_vendor}</span>
                        </div>
                        <div>
                            <span style="color: ${colors.label};">Status:</span>
                            <span style="color: ${colors.status}; margin-left: 4px;">${tooltipData.interface_status}</span>
                        </div>
                    </div>
                </div>
            `;

            tooltip.innerHTML = tooltipContent;
            tooltip.style.display = 'block';

            // Add hover listeners to tooltip itself
            tooltip.addEventListener('mouseenter', cancelHideTooltip);
            tooltip.addEventListener('mouseleave', scheduleHideTooltip);

            // Position tooltip to the right of the mouse cursor
            const rect = element.getBoundingClientRect();
            tooltip.style.left = (rect.right + 15) + 'px';
            tooltip.style.top = rect.top + 'px';
        }

        function scheduleHideTooltip() {
            // Delay hiding to allow moving mouse to tooltip
            tooltipHideTimer = setTimeout(() => {
                hideTooltip();
            }, 200);
        }

        function cancelHideTooltip() {
            if (tooltipHideTimer) {
                clearTimeout(tooltipHideTimer);
                tooltipHideTimer = null;
            }
        }

        function hideTooltip() {
            tooltip.style.display = 'none';
        }

        function handleIPClick(event) {
            const element = event.target;
            const mgmtIP = element.getAttribute('data-mgmt-ip');

            // Copy management IP to clipboard
            navigator.clipboard.writeText(mgmtIP).then(() => {
                // Brief visual feedback
                element.style.backgroundColor = 'yellow';
                setTimeout(() => {
                    element.style.backgroundColor = '';
                }, 200);
            });
        }

        function copyTranslatedOutput() {
            const outputArea = document.getElementById('outputArea');
            // Get the text content without HTML tags
            const textToCopy = outputArea.innerText || outputArea.textContent;

            navigator.clipboard.writeText(textToCopy).then(() => {
                // Visual feedback on the copy button
                const copyButton = document.getElementById('copyButton');
                const originalText = copyButton.textContent;
                copyButton.textContent = 'Copied!';
                copyButton.style.backgroundColor = '#4caf50';
                copyButton.style.color = 'white';

                setTimeout(() => {
                    copyButton.textContent = originalText;
                    copyButton.style.backgroundColor = '';
                    copyButton.style.color = '';
                }, 1000);
            }).catch(err => {
                console.error('Failed to copy text: ', err);
                alert('Failed to copy to clipboard');
            });
        }

        // Event listeners
        inputText.addEventListener('input', scheduleTranslation);
        inputText.addEventListener('paste', () => {
            setTimeout(scheduleTranslation, 10); // Small delay to let paste complete
        });

        // Hide tooltip when clicking elsewhere
        document.addEventListener('click', (event) => {
            if (!event.target.closest('.ip-enhanced')) {
                hideTooltip();
            }
        });

        // Sample text for demonstration
        inputText.addEventListener('focus', function() {
            if (this.value === '') {
                this.placeholder = 'insert command output here..';
            }
        });

        inputText.addEventListener('blur', function() {
            this.placeholder = 'Paste your text here... IP addresses will be automatically translated to show hostname and interface information.';
        });

        // URL/App Insights Functions
        let urlInsightsData = {
            requests: [],
            startTime: null,
            loadTime: null,
            totalSize: 0,
            statusCode: null,
            tlsInfo: null,
            timeline: []
        };

        // Curl-based URL Insights variables
        let curlEventSource = null;
        let curlOutputData = '';
        let customHeadersCount = 0;

        function toggleCurlOptions() {
            const panel = document.getElementById('curlOptionsPanel');
            const icon = document.getElementById('curlOptionsToggleIcon');

            if (panel.style.display === 'none') {
                panel.style.display = 'block';
                icon.textContent = '‚ñº';
            } else {
                panel.style.display = 'none';
                icon.textContent = '‚ñ∂';
            }
        }

        function addCustomHeader() {
            customHeadersCount++;
            const headersList = document.getElementById('customHeadersList');
            const headerId = 'customHeader' + customHeadersCount;

            const headerDiv = document.createElement('div');
            headerDiv.id = headerId;
            headerDiv.style.marginBottom = '5px';
            headerDiv.style.display = 'flex';
            headerDiv.style.gap = '5px';

            headerDiv.innerHTML = `
                <input type="text" placeholder="Header-Name" style="flex: 1; padding: 4px; font-size: 12px;" data-header-key="${headerId}">
                <input type="text" placeholder="Value" style="flex: 1; padding: 4px; font-size: 12px;" data-header-value="${headerId}">
                <button onclick="removeCustomHeader('${headerId}')" style="padding: 4px 8px; font-size: 12px;">√ó</button>
            `;

            headersList.appendChild(headerDiv);
        }

        function removeCustomHeader(headerId) {
            const headerDiv = document.getElementById(headerId);
            if (headerDiv) {
                headerDiv.remove();
            }
        }

        function getCustomHeaders() {
            const headers = [];
            const headersList = document.getElementById('customHeadersList');
            const headerDivs = headersList.querySelectorAll('[id^="customHeader"]');

            headerDivs.forEach(div => {
                const keyInput = div.querySelector('[data-header-key]');
                const valueInput = div.querySelector('[data-header-value]');

                if (keyInput && valueInput && keyInput.value.trim() && valueInput.value.trim()) {
                    headers.push({
                        key: keyInput.value.trim(),
                        value: valueInput.value.trim()
                    });
                }
            });

            return headers;
        }

        function analyzeCurlURL() {
            const urlInput = document.getElementById('urlInsightsInput');
            const url = urlInput.value.trim();

            if (!url) {
                alert('Please enter a URL');
                return;
            }

            // Close existing event source if any
            if (curlEventSource) {
                curlEventSource.close();
                curlEventSource = null;
            }

            // Reset output
            curlOutputData = '';
            document.getElementById('curlPlaceholder').style.display = 'none';
            document.getElementById('curlOutput').style.display = 'block';
            document.getElementById('curlOutput').textContent = '';
            document.getElementById('curlStatus').textContent = 'Connecting...';
            document.getElementById('curlStatus').style.color = '#007cba';
            document.getElementById('exportCurlBtn').style.display = 'none';

            // Gather curl options
            const curlOptions = {
                url: url,
                follow_redirects: document.getElementById('curlFollowRedirects').checked,
                include_headers: document.getElementById('curlIncludeHeaders').checked,
                headers_only: document.getElementById('curlHeadersOnly').checked,
                verbose: document.getElementById('curlVerbose').checked,
                user_agent: document.getElementById('curlUserAgent').value.trim(),
                max_time: parseInt(document.getElementById('curlMaxTime').value) || 30,
                request_method: document.getElementById('curlMethod').value,
                custom_headers: getCustomHeaders()
            };

            // Start curl request
            fetch('/api/curl-url', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(curlOptions)
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Request failed');
                }

                // Stream the response
                const reader = response.body.getReader();
                const decoder = new TextDecoder();

                function readStream() {
                    reader.read().then(({ done, value }) => {
                        if (done) {
                            document.getElementById('curlStatus').textContent = 'Completed';
                            document.getElementById('curlStatus').style.color = '#28a745';
                            document.getElementById('exportCurlBtn').style.display = 'inline-block';
                            return;
                        }

                        const chunk = decoder.decode(value, { stream: true });
                        const lines = chunk.split('\n');

                        lines.forEach(line => {
                            if (line.startsWith('data: ')) {
                                try {
                                    const data = JSON.parse(line.substring(6));
                                    handleCurlEvent(data);
                                } catch (e) {
                                    // Ignore parse errors
                                }
                            }
                        });

                        readStream();
                    }).catch(error => {
                        document.getElementById('curlStatus').textContent = 'Error';
                        document.getElementById('curlStatus').style.color = '#dc3545';
                        appendCurlOutput('\n\nError: ' + error.message, '#dc3545');
                    });
                }

                readStream();
            })
            .catch(error => {
                document.getElementById('curlStatus').textContent = 'Error';
                document.getElementById('curlStatus').style.color = '#dc3545';
                appendCurlOutput('\n\nError: ' + error.message, '#dc3545');
            });
        }

        function handleCurlEvent(data) {
            switch(data.type) {
                case 'status':
                    document.getElementById('curlStatus').textContent = data.message;
                    document.getElementById('curlCommand').textContent = data.command || '';
                    appendCurlOutput('$ ' + (data.command || '') + '\n\n', '#569cd6');
                    break;

                case 'output':
                    appendCurlOutput(data.line + '\n', '#d4d4d4');
                    break;

                case 'stderr':
                    appendCurlOutput(data.line + '\n', '#ce9178');
                    break;

                case 'complete':
                    document.getElementById('curlStatus').textContent = 'Completed';
                    document.getElementById('curlStatus').style.color = '#28a745';
                    document.getElementById('exportCurlBtn').style.display = 'inline-block';
                    break;

                case 'error':
                    document.getElementById('curlStatus').textContent = 'Error';
                    document.getElementById('curlStatus').style.color = '#dc3545';
                    appendCurlOutput('\n\nError: ' + data.message + '\n', '#dc3545');
                    break;
            }
        }

        function appendCurlOutput(text, color) {
            const outputDiv = document.getElementById('curlOutput');
            curlOutputData += text;

            // Apply syntax highlighting if no explicit color is set (default output)
            if (color === '#d4d4d4' || color === '#ce9178') {
                const highlightedHTML = highlightCurlOutput(text);
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = highlightedHTML;
                while (tempDiv.firstChild) {
                    outputDiv.appendChild(tempDiv.firstChild);
                }
            } else {
                // Use explicit color for commands and errors
                const span = document.createElement('span');
                span.style.color = color;
                span.textContent = text;
                outputDiv.appendChild(span);
            }

            // Auto-scroll to bottom
            const container = document.getElementById('curlOutputContainer');
            container.scrollTop = container.scrollHeight;
        }

        function highlightCurlOutput(text) {
            let highlighted = text;

            // Escape HTML
            highlighted = highlighted.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

            // DNS resolution (getaddrinfo, Trying IP addresses)
            highlighted = highlighted.replace(
                /(getaddrinfo\(3\)|Trying\s+[\d\.]+(?::\d+)?|Connected to\s+\S+\s+\([\d\.]+\)|Host\s+\S+:\d+\s+was resolved)/gi,
                '<span style="color: #4ec9b0;">$1</span>'
            );

            // TLS/SSL Handshake and Certificate details
            highlighted = highlighted.replace(
                /(SSL connection using|TLSv[\d\.]+|TLS\s+handshake|SSL_connect|Server certificate|subject:|issuer:|start date:|expire date:|subjectAltName|ALPN|SSL certificate verify|CN=|O=|OU=)/gi,
                '<span style="color: #c586c0; font-weight: bold;">$1</span>'
            );

            // Certificate/Cipher suite details
            highlighted = highlighted.replace(
                /(TLS_\w+|ECDHE-RSA-\w+|AES[\d]+-\w+|SHA\d+|RSA\s+\d+\s+bits?)/gi,
                '<span style="color: #9cdcfe;">$1</span>'
            );

            // HTTP Response codes and status
            highlighted = highlighted.replace(
                /(HTTP\/[\d\.]+\s+)(\d{3})\s+(\w.*?)(<|$)/gi,
                function(match, protocol, code, status, end) {
                    let codeColor = '#4ec9b0'; // Default green
                    const codeNum = parseInt(code);
                    if (codeNum >= 200 && codeNum < 300) {
                        codeColor = '#4ec9b0'; // Green for 2xx
                    } else if (codeNum >= 300 && codeNum < 400) {
                        codeColor = '#dcdcaa'; // Yellow for 3xx
                    } else if (codeNum >= 400 && codeNum < 500) {
                        codeColor = '#f48771'; // Orange for 4xx
                    } else if (codeNum >= 500) {
                        codeColor = '#f14c4c'; // Red for 5xx
                    }
                    return '<span style="color: #569cd6;">' + protocol + '</span>' +
                           '<span style="color: ' + codeColor + '; font-weight: bold;">' + code + '</span> ' +
                           '<span style="color: ' + codeColor + ';">' + status + '</span>' + end;
                }
            );

            // HTTP Headers (key: value format)
            highlighted = highlighted.replace(
                /^([A-Z][A-Za-z0-9-]+):\s*(.*)$/gm,
                '<span style="color: #9cdcfe;">$1:</span> <span style="color: #ce9178;">$2</span>'
            );

            // Stats section
            highlighted = highlighted.replace(
                /(--- Stats ---|HTTP Code:|Total Time:|Size:)/gi,
                '<span style="color: #dcdcaa; font-weight: bold;">$1</span>'
            );

            // Numbers in stats
            highlighted = highlighted.replace(
                /(\d+\.\d+s|\d+ bytes)/gi,
                '<span style="color: #b5cea8;">$1</span>'
            );

            // Asterisks and connection symbols
            highlighted = highlighted.replace(
                /(\*\s+)/g,
                '<span style="color: #608b4e;">$1</span>'
            );

            return highlighted;
        }

        function clearCurlAnalysis() {
            // Close event source if running
            if (curlEventSource) {
                curlEventSource.close();
                curlEventSource = null;
            }

            document.getElementById('urlInsightsInput').value = '';
            document.getElementById('curlPlaceholder').style.display = 'block';
            document.getElementById('curlOutput').style.display = 'none';
            document.getElementById('curlOutput').textContent = '';
            document.getElementById('curlStatus').textContent = 'Ready';
            document.getElementById('curlStatus').style.color = '#666';
            document.getElementById('curlCommand').textContent = '';
            document.getElementById('exportCurlBtn').style.display = 'none';
            curlOutputData = '';
        }

        function exportCurlOutput() {
            const blob = new Blob([curlOutputData], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'curl-output-' + Date.now() + '.txt';
            a.click();
            URL.revokeObjectURL(url);
        }

        // TCP Handshake functions
        let tcpOutputData = '';

        function captureTCPHandshake() {
            const target = document.getElementById('tcpHandshakeTarget').value.trim();
            const port = parseInt(document.getElementById('tcpHandshakePort').value) || 80;

            if (!target) {
                alert('Please enter a target IP or domain');
                return;
            }

            // Reset output
            tcpOutputData = '';
            document.getElementById('tcpPlaceholder').style.display = 'none';
            document.getElementById('tcpOutput').style.display = 'block';
            document.getElementById('tcpOutput').innerHTML = '';
            document.getElementById('tcpStatus').textContent = 'Starting capture...';
            document.getElementById('tcpStatus').style.color = '#007cba';
            document.getElementById('exportTCPBtn').style.display = 'none';

            // Start TCP handshake capture
            fetch('/api/tcp-handshake', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ target: target, port: port })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Request failed');
                }

                // Stream the response
                const reader = response.body.getReader();
                const decoder = new TextDecoder();

                function readStream() {
                    reader.read().then(({ done, value }) => {
                        if (done) {
                            return;
                        }

                        const chunk = decoder.decode(value, { stream: true });
                        const lines = chunk.split('\n');

                        lines.forEach(line => {
                            if (line.startsWith('data: ')) {
                                try {
                                    const data = JSON.parse(line.substring(6));
                                    handleTCPEvent(data);
                                } catch (e) {
                                    // Ignore parse errors
                                }
                            }
                        });

                        readStream();
                    }).catch(error => {
                        document.getElementById('tcpStatus').textContent = 'Error';
                        document.getElementById('tcpStatus').style.color = '#dc3545';
                        appendTCPOutput('\n\nError: ' + error.message, '#dc3545');
                    });
                }

                readStream();
            })
            .catch(error => {
                document.getElementById('tcpStatus').textContent = 'Error';
                document.getElementById('tcpStatus').style.color = '#dc3545';
                appendTCPOutput('\n\nError: ' + error.message, '#dc3545');
            });
        }

        function handleTCPEvent(data) {
            switch(data.type) {
                case 'status':
                    document.getElementById('tcpStatus').textContent = data.message;
                    if (data.resolved_ip) {
                        appendTCPOutput('üîç Resolved: ' + data.resolved_ip + '\n\n', '#4ec9b0');
                    }
                    break;

                case 'command':
                    document.getElementById('tcpCommand').textContent = data.command || '';
                    appendTCPOutput('$ ' + (data.command || '') + '\n\n', '#569cd6');
                    break;

                case 'packet':
                    appendTCPOutput((data.packet_num ? '[' + data.packet_num + '] ' : '') + data.line + '\n', '#d4d4d4', true);
                    break;

                case 'info':
                    if (data.lines && data.lines.length > 0) {
                        appendTCPOutput('\nüìä Capture Info:\n', '#dcdcaa');
                        data.lines.forEach(line => {
                            appendTCPOutput(line + '\n', '#608b4e');
                        });
                    }
                    break;

                case 'warning':
                    appendTCPOutput('\n‚ö†Ô∏è  ' + data.message + '\n', '#ffc107');
                    break;

                case 'complete':
                    document.getElementById('tcpStatus').textContent = data.message || 'Completed';
                    document.getElementById('tcpStatus').style.color = '#28a745';
                    document.getElementById('exportTCPBtn').style.display = 'inline-block';
                    appendTCPOutput('\n‚úÖ ' + data.message + '\n', '#4ec9b0');
                    break;

                case 'error':
                    document.getElementById('tcpStatus').textContent = 'Error';
                    document.getElementById('tcpStatus').style.color = '#dc3545';
                    appendTCPOutput('\n\n‚ùå Error: ' + data.message + '\n', '#dc3545');
                    break;
            }
        }

        function appendTCPOutput(text, color, highlightPacket) {
            const outputDiv = document.getElementById('tcpOutput');
            tcpOutputData += text;

            // Apply syntax highlighting for packets
            if (highlightPacket) {
                const highlightedHTML = highlightTCPPacket(text);
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = highlightedHTML;
                while (tempDiv.firstChild) {
                    outputDiv.appendChild(tempDiv.firstChild);
                }
            } else {
                const span = document.createElement('span');
                span.style.color = color || '#d4d4d4';
                span.textContent = text;
                outputDiv.appendChild(span);
            }

            // Auto-scroll to bottom
            const container = document.getElementById('tcpOutputContainer');
            container.scrollTop = container.scrollHeight;
        }

        function highlightTCPPacket(text) {
            let highlighted = text;

            // Escape HTML
            highlighted = highlighted.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

            // Packet number [N]
            highlighted = highlighted.replace(/^(\[\d+\])/gm, '<span style="color: #608b4e;">$1</span>');

            // Timestamp
            highlighted = highlighted.replace(/(\d{2}:\d{2}:\d{2}\.\d+)/g, '<span style="color: #9cdcfe;">$1</span>');

            // IP addresses
            highlighted = highlighted.replace(/(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})/g, '<span style="color: #4ec9b0; font-weight: bold;">$1</span>');

            // TCP Flags - SYN (green/cyan)
            highlighted = highlighted.replace(/(\bFlags\s+\[)([^\]]*SYN[^\]]*)(\])/gi,
                '<span style="color: #dcdcaa;">$1</span><span style="color: #4ec9b0; font-weight: bold;">$2</span><span style="color: #dcdcaa;">$3</span>');

            // TCP Flags - SYN-ACK (yellow)
            highlighted = highlighted.replace(/(\bFlags\s+\[)([^\]]*S\.[^\]]*)(\])/gi,
                '<span style="color: #dcdcaa;">$1</span><span style="color: #dcdcaa; font-weight: bold;">$2</span><span style="color: #dcdcaa;">$3</span>');

            // TCP Flags - ACK (blue)
            highlighted = highlighted.replace(/(\bFlags\s+\[)([^\]]*ACK[^\]]*)(\])/gi,
                '<span style="color: #dcdcaa;">$1</span><span style="color: #569cd6; font-weight: bold;">$2</span><span style="color: #dcdcaa;">$3</span>');

            // TCP Flags - other
            highlighted = highlighted.replace(/(\bFlags\s+\[)([^\]]+)(\])/gi,
                '<span style="color: #dcdcaa;">$1</span><span style="color: #c586c0;">$2</span><span style="color: #dcdcaa;">$3</span>');

            // Port numbers
            highlighted = highlighted.replace(/\.(\d{1,5}):/g, '.<span style="color: #b5cea8;">$1</span>:');

            // Sequence numbers
            highlighted = highlighted.replace(/(seq\s+)(\d+)(:\d+)?/gi,
                '<span style="color: #9cdcfe;">$1</span><span style="color: #b5cea8;">$2$3</span>');

            // Acknowledgment numbers
            highlighted = highlighted.replace(/(ack\s+)(\d+)/gi,
                '<span style="color: #9cdcfe;">$1</span><span style="color: #b5cea8;">$2</span>');

            // Window size
            highlighted = highlighted.replace(/(win\s+)(\d+)/gi,
                '<span style="color: #9cdcfe;">$1</span><span style="color: #b5cea8;">$2</span>');

            // Length
            highlighted = highlighted.replace(/(length\s+)(\d+)/gi,
                '<span style="color: #9cdcfe;">$1</span><span style="color: #b5cea8;">$2</span>');

            // Protocol keywords
            highlighted = highlighted.replace(/\b(tcp|TCP|IP)\b/g, '<span style="color: #c586c0; font-weight: bold;">$1</span>');

            // Direction arrows
            highlighted = highlighted.replace(/(&gt;)/g, '<span style="color: #f48771;">$1</span>');

            return highlighted;
        }

        function clearTCPHandshake() {
            document.getElementById('tcpHandshakeTarget').value = '';
            document.getElementById('tcpHandshakePort').value = '80';
            document.getElementById('tcpPlaceholder').style.display = 'block';
            document.getElementById('tcpOutput').style.display = 'none';
            document.getElementById('tcpOutput').innerHTML = '';
            document.getElementById('tcpStatus').textContent = 'Ready';
            document.getElementById('tcpStatus').style.color = '#666';
            document.getElementById('tcpCommand').textContent = '';
            document.getElementById('exportTCPBtn').style.display = 'none';
            tcpOutputData = '';
        }

        function exportTCPOutput() {
            const blob = new Blob([tcpOutputData], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'tcp-handshake-' + Date.now() + '.txt';
            a.click();
            URL.revokeObjectURL(url);
        }

        // Initialize insights tab on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Set default active tab to Overview
            const overviewTab = document.querySelector('.insights-tab');
            if (overviewTab) {
                overviewTab.classList.add('active');
                document.getElementById('overview-content').classList.add('active');
            }

            // Load WhoAmI data
            loadWhoAmIData();
        });

        // WhoAmI Functions
        function loadWhoAmIData() {
            const ipAddressElement = document.getElementById('userIpAddress');
            const ipDetailsElement = document.getElementById('ipDetails');
            const ipVersionElement = document.getElementById('ipVersion');
            const ipTypeElement = document.getElementById('ipType');
            const reverseDnsElement = document.getElementById('reverseDns');
            const reverseDnsValueElement = document.getElementById('reverseDnsValue');

            if (!ipAddressElement) return; // Tab not visible

            // Fetch IP address from server
            fetch('/api/whoami')
                .then(response => response.json())
                .then(data => {
                    if (data.ip) {
                        ipAddressElement.innerHTML = data.ip;

                        // Determine IP version
                        const isIPv6 = data.ip.includes(':');
                        ipVersionElement.textContent = isIPv6 ? 'IPv6' : 'IPv4';

                        // Determine IP type (private vs public)
                        const isPrivate = isPrivateIP(data.ip);
                        ipTypeElement.textContent = isPrivate ? 'Private' : 'Public';

                        // Show details
                        ipDetailsElement.style.display = 'block';

                        // Show reverse DNS if available
                        if (data.reverse_dns) {
                            reverseDnsValueElement.textContent = data.reverse_dns;
                            reverseDnsElement.style.display = 'block';
                        }
                    } else {
                        ipAddressElement.innerHTML = '<span style="opacity: 0.6;">Unable to detect</span>';
                    }
                })
                .catch(error => {
                    console.error('Error fetching IP:', error);
                    ipAddressElement.innerHTML = '<span style="opacity: 0.6;">Error loading</span>';
                });
        }

        function isPrivateIP(ip) {
            // Check for IPv4 private ranges
            if (ip.includes('.')) {
                const parts = ip.split('.');
                if (parts.length === 4) {
                    const first = parseInt(parts[0]);
                    const second = parseInt(parts[1]);

                    // 10.0.0.0/8
                    if (first === 10) return true;

                    // 172.16.0.0/12
                    if (first === 172 && second >= 16 && second <= 31) return true;

                    // 192.168.0.0/16
                    if (first === 192 && second === 168) return true;

                    // 127.0.0.0/8 (localhost)
                    if (first === 127) return true;
                }
            }

            // Check for IPv6 private ranges
            if (ip.includes(':')) {
                // Link-local (fe80::/10)
                if (ip.toLowerCase().startsWith('fe80:')) return true;

                // Unique local (fc00::/7)
                if (ip.toLowerCase().startsWith('fc') || ip.toLowerCase().startsWith('fd')) return true;

                // Loopback (::1)
                if (ip === '::1') return true;
            }

            return false;
        }

        // ==================== BGP Looking Glass Functions ====================

        // Load BGP Looking Glass devices when page loads
        document.addEventListener('DOMContentLoaded', function() {
            loadBgpDevices();
        });

        async function loadBgpDevices() {
            // Check if BGP devices list element exists (only on BGP Looking Glass tool)
            const devicesList = document.getElementById('bgpDevicesList');
            if (!devicesList) {
                return; // Element doesn't exist, skip loading
            }

            try {
                const response = await fetch('/api/bgp-looking-glass/devices');
                if (response.ok) {
                    const devices = await response.json();

                    if (devices.length === 0) {
                        devicesList.innerHTML = '<p style="color: #666; font-style: italic;">No devices configured. Please configure in Settings.</p>';
                        return;
                    }

                    // Sort devices alphabetically by hostname
                    devices.sort((a, b) => a.hostname.localeCompare(b.hostname));

                    // Group devices by common prefix (first part before number or dash)
                    const groups = groupDevicesByPrefix(devices);

                    // Build HTML for checkbox list with 4 columns
                    let html = '';
                    for (const [groupName, groupDevices] of Object.entries(groups)) {
                        if (groupName && Object.keys(groups).length > 1) {
                            html += `<div style="margin-bottom: 15px;">
                                <h4 style="font-size: 14px; font-weight: bold; color: #495057; margin-bottom: 8px; border-bottom: 2px solid #dee2e6; padding-bottom: 4px;">
                                    ${groupName}
                                </h4>`;
                        }

                        html += '<div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; margin-bottom: 10px;">';

                        groupDevices.forEach(device => {
                            html += `
                                <label style="display: flex; align-items: center; padding: 4px; cursor: pointer; font-size: 13px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                                    <input type="checkbox" class="bgp-device-checkbox" value="${device.id}" style="margin-right: 6px;">
                                    <span title="${device.hostname} (${device.ip_address})">${device.hostname}</span>
                                </label>
                            `;
                        });

                        html += '</div>';

                        if (groupName && Object.keys(groups).length > 1) {
                            html += '</div>';
                        }
                    }

                    devicesList.innerHTML = html;
                } else {
                    console.error('Error loading BGP devices');
                    devicesList.innerHTML = '<p style="color: #dc3545;">Error loading devices</p>';
                }
            } catch (error) {
                console.error('Error loading BGP devices:', error);
                devicesList.innerHTML = '<p style="color: #dc3545;">Error loading devices</p>';
            }
        }

        function groupDevicesByPrefix(devices) {
            const groups = {};

            devices.forEach(device => {
                // Extract prefix from hostname (letters before numbers/dashes)
                const match = device.hostname.match(/^([a-zA-Z]+)/);
                const prefix = match ? match[1] : 'Other';

                if (!groups[prefix]) {
                    groups[prefix] = [];
                }
                groups[prefix].push(device);
            });

            // If all devices have different prefixes or only one group, don't group
            if (Object.keys(groups).length === devices.length || Object.keys(groups).length === 1) {
                return { '': devices };
            }

            return groups;
        }

        function selectAllBgpDevices() {
            const checkboxes = document.querySelectorAll('.bgp-device-checkbox');
            checkboxes.forEach(cb => cb.checked = true);
        }

        function deselectAllBgpDevices() {
            const checkboxes = document.querySelectorAll('.bgp-device-checkbox');
            checkboxes.forEach(cb => cb.checked = false);
        }

        async function runBgpLookup() {
            const username = document.getElementById('bgpUsername').value.trim();
            const password = document.getElementById('bgpPassword').value.trim();
            const prefix = document.getElementById('bgpPrefix').value.trim();
            const showIpRoute = document.getElementById('optShowIpRoute').checked;
            const showIpBgp = document.getElementById('optShowIpBgp').checked;

            // Get selected devices from checkboxes
            const checkedBoxes = document.querySelectorAll('.bgp-device-checkbox:checked');
            const selectedDevices = Array.from(checkedBoxes).map(cb => cb.value);

            // Validation
            if (!username || !password) {
                alert('Please enter username and password');
                return;
            }

            if (!prefix) {
                alert('Please enter a prefix');
                return;
            }

            if (!showIpRoute && !showIpBgp) {
                alert('Please select at least one query option');
                return;
            }

            if (selectedDevices.length === 0) {
                alert('Please select at least one device');
                return;
            }

            const progressDiv = document.getElementById('bgpProgress');
            const resultsDiv = document.getElementById('bgpResults');
            const copyButton = document.getElementById('bgpCopyButton');

            progressDiv.style.display = 'block';
            progressDiv.innerHTML = '<div>Starting BGP lookup...</div>';
            resultsDiv.textContent = '';
            copyButton.style.display = 'none'; // Hide copy button when starting new lookup

            // Build URL with query parameters for POST with EventSource compatibility
            const formData = new URLSearchParams({
                username: username,
                password: password,
                prefix: prefix,
                show_ip_route: showIpRoute,
                show_ip_bgp: showIpBgp,
                device_ids: JSON.stringify(selectedDevices)
            });

            try {
                const response = await fetch('/api/bgp-looking-glass/lookup', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        username: username,
                        password: password,
                        prefix: prefix,
                        show_ip_route: showIpRoute,
                        show_ip_bgp: showIpBgp,
                        device_ids: selectedDevices
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    alert('Error: ' + (errorData.error || 'Unknown error'));
                    progressDiv.style.display = 'none';
                    return;
                }

                // Handle streaming response
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';

                while (true) {
                    const { done, value } = await reader.read();

                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n\n');
                    buffer = lines.pop(); // Keep incomplete line in buffer

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const jsonStr = line.substring(6);
                            try {
                                const event = JSON.parse(jsonStr);
                                handleBgpStreamEvent(event, progressDiv, resultsDiv);
                            } catch (e) {
                                console.error('Error parsing SSE data:', e, jsonStr);
                            }
                        }
                    }
                }

                progressDiv.innerHTML = '<div style="color: green;">‚úì BGP lookup completed!</div>';
                setTimeout(() => {
                    progressDiv.style.display = 'none';
                }, 3000);

            } catch (error) {
                console.error('Error running BGP lookup:', error);
                alert('Error running BGP lookup: ' + error.message);
                progressDiv.style.display = 'none';
            }
        }

        async function handleBgpStreamEvent(event, progressDiv, resultsDiv) {
            const { type, hostname, command, output, message } = event;
            const translateIps = document.getElementById('optTranslateIps')?.checked || false;

            switch (type) {
                case 'device_start':
                    resultsDiv.innerHTML += '=' + '='.repeat(79) + '\n';
                    resultsDiv.innerHTML += `Device: ${hostname}\n`;
                    resultsDiv.innerHTML += '=' + '='.repeat(79) + '\n\n';
                    progressDiv.innerHTML = `<div>Processing device: ${hostname}...</div>`;
                    break;

                case 'status':
                    progressDiv.innerHTML = `<div>${hostname}: ${message}</div>`;
                    break;

                case 'command':
                    resultsDiv.innerHTML += `----- ${command} -----\n`;
                    progressDiv.innerHTML = `<div>${hostname}: Executing command...</div>`;
                    break;

                case 'output':
                    let displayOutput = output || '(no output)';

                    // Translate IPs if option is enabled
                    if (translateIps && output) {
                        try {
                            const response = await fetch(`/api/translate-ip?text=${encodeURIComponent(output)}`);
                            const data = await response.json();
                            displayOutput = data.translated_text || output;
                        } catch (error) {
                            console.error('Error translating IPs:', error);
                            // Fall back to original output on error
                        }
                    }

                    resultsDiv.innerHTML += displayOutput;
                    resultsDiv.innerHTML += '\n\n';
                    // Auto-scroll to bottom
                    resultsDiv.scrollTop = resultsDiv.scrollHeight;
                    break;

                case 'error':
                    resultsDiv.innerHTML += `ERROR: ${message}\n\n`;
                    resultsDiv.scrollTop = resultsDiv.scrollHeight;
                    break;

                case 'device_complete':
                    resultsDiv.innerHTML += '\n';
                    break;

                case 'complete':
                    progressDiv.innerHTML = '<div style="color: green;">‚úì All devices processed!</div>';
                    // Show copy button when all processing is complete
                    const copyBtn = document.getElementById('bgpCopyButton');
                    if (copyBtn) copyBtn.style.display = 'inline-block';
                    break;
            }
        }

        function copyBgpResults() {
            const resultsDiv = document.getElementById('bgpResults');
            const copyButton = document.getElementById('bgpCopyButton');

            // Get the text content, stripping HTML tags
            const textToCopy = resultsDiv.innerText || resultsDiv.textContent;

            // Use the Clipboard API
            navigator.clipboard.writeText(textToCopy).then(() => {
                // Show success feedback
                const originalText = copyButton.innerHTML;
                copyButton.innerHTML = '<i class="bi bi-check2"></i> Copied!';
                copyButton.style.background = '#218838';

                // Reset button after 2 seconds
                setTimeout(() => {
                    copyButton.innerHTML = originalText;
                    copyButton.style.background = '#28a745';
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy text: ', err);
                alert('Failed to copy to clipboard. Please try selecting and copying manually.');
            });
        }

        function displayBgpResults(data) {
            const resultsDiv = document.getElementById('bgpResults');
            let output = '';

            for (const [deviceName, deviceData] of Object.entries(data.results)) {
                output += '=' + '='.repeat(79) + '\n';
                output += `Device: ${deviceName}\n`;
                output += '=' + '='.repeat(79) + '\n\n';

                if (deviceData.status === 'success') {
                    for (const [command, commandData] of Object.entries(deviceData.commands)) {
                        output += `----- ${command} -----\n`;
                        output += commandData.output || '(no output)';
                        output += '\n\n';
                    }
                } else {
                    output += `ERROR: ${deviceData.error}\n\n`;
                }
            }

            resultsDiv.textContent = output;
        }
    </script>
</body>
</html>