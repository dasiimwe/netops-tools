<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>netops Toolkit</title>
    <style>
        .tabs {
            display: flex;
            border-bottom: 1px solid #ccc;
            margin-bottom: 20px;
        }
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border: 1px solid #ccc;
            border-bottom: none;
            background: #f0f0f0;
            margin-right: 5px;
        }
        .tab.active {
            background: white;
            border-bottom: 1px solid white;
            margin-bottom: -1px;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .device-list, .command-list {
            border: 1px solid #ccc;
            min-height: 100px;
            padding: 10px;
            margin: 10px 0;
            font-family: monospace;
        }
        .add-item {
            margin: 5px 0;
        }
        .remove-btn {
            color: red;
            cursor: pointer;
            margin-left: 10px;
        }
        .run-section {
            background: #f9f9f9;
            padding: 15px;
            border: 1px solid #ddd;
            margin: 20px 0;
        }
        .output-section {
            margin-top: 20px;
        }
        .device-output {
            border: 1px solid #ccc;
            margin: 10px 0;
            padding: 10px;
        }
        .device-output h4 {
            margin: 0 0 10px 0;
            color: #333;
        }
        .command-output {
            background: #f5f5f5;
            border: 1px solid #ddd;
            padding: 10px;
            margin: 5px 0;
            font-family: monospace;
            white-space: pre-wrap;
            overflow-x: auto;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }
        .modal-content {
            background-color: white;
            margin: 15% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 400px;
            border-radius: 5px;
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .close {
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        .close:hover {
            color: black;
        }
        .saved-item {
            padding: 8px;
            margin: 5px 0;
            background: #f9f9f9;
            border: 1px solid #ddd;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .saved-item:hover {
            background: #e9e9e9;
        }
        .saved-item-name {
            font-weight: bold;
        }
        .saved-item-count {
            color: #666;
            font-size: 12px;
        }
        .delete-saved {
            color: red;
            cursor: pointer;
            padding: 2px 6px;
        }
        .command-input-valid {
            border: 2px solid #28a745 !important;
            background-color: #f8fff8 !important;
        }
        .command-input-invalid {
            border: 2px solid #dc3545 !important;
            background-color: #fff5f5 !important;
        }
        .command-help-text {
            font-size: 11px;
            color: #666;
            margin-top: 2px;
            line-height: 1.2;
        }
        .insights-tab {
            display: inline-block;
            padding: 6px 12px;
            margin-right: 4px;
            background: #f8f9fa;
            border: 1px solid #ddd;
            cursor: pointer;
            font-size: 12px;
            border-radius: 3px;
        }
        .insights-tab.active {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }
        .insights-tab-content {
            display: none;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 3px;
            background: #fff;
            margin-top: 5px;
        }
        .insights-tab-content.active {
            display: block;
        }
        .insights-stat {
            text-align: center;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 3px;
        }
        .insights-stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #007bff;
        }
        .insights-stat-label {
            font-size: 11px;
            color: #666;
            margin-top: 2px;
        }
    </style>
</head>
<body>
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 style="margin: 0;">netops Toolkit</h2>
        <a href="{{ url_for('main.admin') }}" style="color: #0000EE; text-decoration: underline;">Admin Dashboard ‚Üí</a>
    </div>

    <div class="tabs">
        {% if tool_visibility.ip_translator %}
        <div class="tab active" onclick="showTab('ip-translator')">IP Translator</div>
        {% endif %}
        {% if tool_visibility.command_runner %}
        <div class="tab{% if not tool_visibility.ip_translator %} active{% endif %}" onclick="showTab('command-runner')">Command Run Tool</div>
        {% endif %}
        {% if tool_visibility.dns_lookup %}
        <div class="tab{% if not tool_visibility.ip_translator and not tool_visibility.command_runner %} active{% endif %}" onclick="showTab('dns-lookup')">DNS Lookup</div>
        {% endif %}
        {% if tool_visibility.traceroute %}
        <div class="tab{% if not tool_visibility.ip_translator and not tool_visibility.command_runner and not tool_visibility.dns_lookup %} active{% endif %}" onclick="showTab('traceroute')">Traceroute</div>
        {% endif %}
        {% if tool_visibility.url_insights %}
        <div class="tab{% if not tool_visibility.ip_translator and not tool_visibility.command_runner and not tool_visibility.dns_lookup and not tool_visibility.traceroute %} active{% endif %}" onclick="showTab('url-insights')">URL/App Insights</div>
        {% endif %}
        {% if tool_visibility.whoami %}
        <div class="tab{% if not tool_visibility.ip_translator and not tool_visibility.command_runner and not tool_visibility.dns_lookup and not tool_visibility.traceroute and not tool_visibility.url_insights %} active{% endif %}" onclick="showTab('whoami')">WhoAmI</div>
        {% endif %}
    </div>

    <!-- IP Translator Tab -->
    {% if tool_visibility.ip_translator %}
    <div id="ip-translator" class="tab-content active">
        <p>Network IP Address Translator</p>

        <label for="inputText">
            <strong>Enter text with IP addresses:</strong>
        </label>
        <br>
        <textarea
            id="inputText"
            rows="6"
            cols="80"
            placeholder="Paste your text here... IP addresses like 192.168.1.1 will be automatically translated to show hostname and interface information."></textarea>
        <div id="loadingIndicator" style="display: none;">
            Translating...
        </div>

        <br><br>

        <label>
            <strong>Translated Output:</strong>
            <button id="copyButton" style="margin-left: 10px; padding: 4px 8px; cursor: pointer;" onclick="copyTranslatedOutput()">Copy</button>
        </label>
        <br>
        <div id="outputArea" style="border: 0px solid #ccc; padding: 10px; min-height: 100px; font-family: 'Consolas', monospace; line-height: 1.2;">
            <em>Your translated text will appear here...</em>
        </div>
    </div>
    {% endif %}

    <!-- Command Run Tool Tab -->
    {% if tool_visibility.command_runner %}
    <div id="command-runner" class="tab-content{% if not tool_visibility.ip_translator %} active{% endif %}">
        <p>Network Device Command Runner</p>

        <div style="display: flex; gap: 20px;">
            <div style="flex: 1;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <label><strong>Devices:</strong></label>
                    <div>
                        <button onclick="saveDeviceList()" style="padding: 4px 8px; margin-right: 5px; background: #28a745; color: white; border: none; cursor: pointer; font-size: 12px;">Save</button>
                        <button onclick="loadDeviceList()" style="padding: 4px 8px; background: #007cba; color: white; border: none; cursor: pointer; font-size: 12px;">Load</button>
                    </div>
                </div>
                <div class="add-item">
                    <input type="text" id="deviceInput" placeholder="Enter device IP/hostname" style="width: 200px;">
                    <button onclick="addDevice()">Add Device</button>
                </div>
                <div id="deviceList" class="device-list">
                    <em>No devices added...</em>
                </div>
            </div>

            <div style="flex: 1;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <label><strong>Commands:</strong></label>
                    <div>
                        <button onclick="saveCommandList()" style="padding: 4px 8px; margin-right: 5px; background: #28a745; color: white; border: none; cursor: pointer; font-size: 12px;">Save</button>
                        <button onclick="loadCommandList()" style="padding: 4px 8px; background: #007cba; color: white; border: none; cursor: pointer; font-size: 12px;">Load</button>
                    </div>
                </div>
                <div class="add-item">
                    <input type="text" id="commandInput" placeholder="Enter safe command (e.g., show version)" style="width: 200px;">
                    <button onclick="addCommand()">Add Command</button>
                    <div class="command-help-text">
                         Allowed: show, ping, traceroute, get, diagnose, execute<br>
                    </div>
                </div>
                <div id="commandList" class="command-list">
                    <em>No commands added...</em>
                </div>
            </div>
        </div>

        <div class="run-section">
            <label><strong>Credentials:</strong></label><br>
            <label>Username: <input type="text" id="username" style="margin: 5px;"></label><br>
            <label>Password: <input type="password" id="password" style="margin: 5px;"></label><br><br>

            <button onclick="runCommands()" style="padding: 10px 20px; background: #007cba; color: white; border: none; cursor: pointer;">Run Commands</button>
            <div id="runProgress" style="display: none; margin-top: 10px;">
                <div>Running commands... Please wait.</div>
            </div>
        </div>

        <div class="output-section">
            <div id="commandResults"></div>
            <div id="downloadSection" style="display: none; margin-top: 20px;">
                <button onclick="downloadResults()" style="padding: 10px 20px; background: #28a745; color: white; border: none; cursor: pointer;">Download All Results (ZIP)</button>
            </div>
        </div>
    </div>
    {% endif %}

    <!-- DNS Lookup Tab -->
    {% if tool_visibility.dns_lookup %}
    <div id="dns-lookup" class="tab-content{% if not tool_visibility.ip_translator and not tool_visibility.command_runner %} active{% endif %}">
        <p>Bulk DNS Lookup Tool</p>

        <div>
            <label><strong>Domains/IP Addresses (one per line):</strong></label>
            <br>
            <textarea
                id="dnsInput"
                rows="10"
                cols="50"
                placeholder="Enter domains or IP addresses, one per line:&#10;"
                oninput="validateDnsInput()"
                style="width: 50%; font-family: monospace;"></textarea>

            <div id="dnsValidation" style="margin-top: 5px; min-height: 20px;"></div>

            <div style="margin-top: 15px;">
                <!-- DNS Servers Section -->
                <div style="display: flex; align-items: center; gap: 10px;">
                    <label><strong>DNS Servers (optional):</strong></label>
                    <span style="font-size: 12px; color: #666;">Leave empty for system default</span>
                    <button onclick="saveDnsServerList()" style="padding: 4px 8px; background: #28a745; color: white; border: none; cursor: pointer; font-size: 12px;">Save</button>
                    <button onclick="loadDnsServerList()" style="padding: 4px 8px; background: #007cba; color: white; border: none; cursor: pointer; font-size: 12px;">Load</button>
                </div>

                <textarea
                    id="dnsServers"
                    rows="3"
                    cols="30"
                    placeholder=""
                    oninput="validateDnsInput()"
                    style="width: 50%; font-family: monospace; margin-top: 5px;"></textarea>

                <div id="dnsServersValidation" style="margin-top: 5px; min-height: 20px;"></div>

                <!-- Lookup Type on same line as button -->
                <div style="margin-top: 15px;">
                    <label style="display: inline-block; margin-right: 10px;">
                        <strong>Lookup Type:</strong>
                        <select id="lookupType" style="padding: 5px; margin-left: 5px;" onchange="validateDnsInput()">
                            <option value="A">A Record (IPv4)</option>
                            <option value="AAAA">AAAA Record (IPv6)</option>
                            <option value="CNAME">CNAME Record</option>
                            <option value="MX">MX Record</option>
                            <option value="NS">NS Record</option>
                            <option value="PTR">PTR Record (Reverse)</option>
                            <option value="TXT">TXT Record</option>
                            <option value="ALL">All Records</option>
                        </select>
                    </label>
                    <button onclick="performDnsLookup()" style="padding: 10px 20px; background: #007cba; color: white; border: none; cursor: pointer;">Perform DNS Lookup</button>
                    <div id="dnsProgress" style="display: none; margin-top: 10px;">
                        <div>Performing DNS lookups... Please wait.</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="output-section">
            <div style="margin-top: 20px;">
                <label>
                    <strong>DNS Lookup Results:</strong>
                    <button id="copyDnsButton" style="margin-left: 10px; padding: 4px 8px; cursor: pointer;" onclick="copyDnsResults()">Copy</button>
                </label>
                <br>
                <div id="dnsResults" style="border: 1px solid #ccc; padding: 10px; min-height: 200px; font-family: 'Consolas', monospace; line-height: 1.2; background: white; margin-top: 10px; white-space: pre-wrap;">
                    <em>DNS lookup results will appear here...</em>
                </div>
            </div>
        </div>
    </div>
    {% endif %}

    <!-- Traceroute Tab -->
    {% if tool_visibility.traceroute %}
    <div id="traceroute" class="tab-content{% if not tool_visibility.ip_translator and not tool_visibility.command_runner and not tool_visibility.dns_lookup %} active{% endif %}">
        <p>Parallel Traceroute Tool</p>

        <div>
            <div style="display: flex; align-items: center; gap: 10px;">
                <label><strong>Target Hosts (one per line):</strong></label>
                <button onclick="saveTracerouteTargets()" style="padding: 4px 8px; background: #28a745; color: white; border: none; cursor: pointer; font-size: 12px;">Save</button>
                <button onclick="loadTracerouteTargets()" style="padding: 4px 8px; background: #007cba; color: white; border: none; cursor: pointer; font-size: 12px;">Load</button>
            </div>
            <br>
            <textarea
                id="tracerouteTargets"
                rows="10"
                cols="50"
                placeholder="Enter IP addresses or hostnames, one per line:&#10;"
                oninput="validateTracerouteInput()"
                style="width: 50%; font-family: monospace;"></textarea>

            <div id="tracerouteValidation" style="margin-top: 5px; min-height: 20px;"></div>

            <div style="margin-top: 15px;">
                <label><strong>Traceroute Options:</strong></label>

                <!-- Compact options in a single line -->
                <div style="margin: 10px 0;">
                    <label style="display: inline-block; margin-right: 15px;">
                        Max Hops: <input type="number" id="maxHops" min="1" max="255" value="30" style="width: 50px; padding: 2px;">
                    </label>
                    <label style="display: inline-block; margin-right: 15px;">
                        Timeout (s): <input type="number" id="traceTimeout" min="1" max="60" value="1" style="width: 50px; padding: 2px;">
                    </label>
                    <label style="display: inline-block; margin-right: 15px;">
                        Probes/hop: <input type="number" id="probesPerHop" min="1" max="10" value="1" style="width: 50px; padding: 2px;">
                    </label>
                    <label style="display: inline-block;">
                        Packet size: <input type="number" id="packetSize" min="28" max="65000" value="60" style="width: 60px; padding: 2px;"> bytes
                    </label>
                </div>

                <div style="margin: 10px 0;">
                    <label style="margin-right: 20px;">
                        <input type="checkbox" id="translateIPs" checked>
                        Translate IP addresses
                    </label>
                    <label>
                        <input type="checkbox" id="resolveHostnames" checked>
                        Resolve hostnames
                    </label>
                </div>

                <div style="margin-top: 15px;">
                    <button id="runTracerouteButton" onclick="performTraceroute()" style="padding: 10px 20px; background: #007cba; color: white; border: none; cursor: pointer;">Run Traceroute</button>
                    <button id="stopTracerouteButton" onclick="stopTraceroute()" style="padding: 10px 20px; background: #dc3545; color: white; border: none; cursor: pointer; display: none;">Stop</button>
                    <div id="tracerouteProgress" style="display: none; margin-top: 10px;">
                        <div id="tracerouteProgressText">Running traceroutes... Please wait.</div>
                        <div id="tracerouteProgressDetail" style="margin-top: 5px; font-size: 12px; color: #666;"></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="output-section">
            <div style="margin-top: 20px;">
                <label>
                    <strong>Traceroute Results:</strong>
                    <button id="copyTracerouteButton" style="margin-left: 10px; padding: 4px 8px; cursor: pointer;" onclick="copyTracerouteResults()">Copy</button>
                    <button id="translateTracerouteButton" style="margin-left: 10px; padding: 4px 8px; cursor: pointer; background: #007bff; color: white; border: none;" onclick="translateTracerouteResults()">Translate</button>
                    <button id="downloadTracerouteButton" style="margin-left: 10px; padding: 4px 8px; cursor: pointer; background: #28a745; color: white; border: none;" onclick="downloadTracerouteResults()">Download</button>
                </label>
                <br>
                <div id="tracerouteResults" style="border: 0px solid #ccc; padding: 10px; min-height: 200px; font-family: 'Consolas', monospace; line-height: 1.4; background: white; margin-top: 10px; white-space: pre-wrap; overflow-x: auto;">
                    <em>Traceroute results will appear here...</em>
                </div>
            </div>
        </div>
    </div>
    {% endif %}

    <!-- URL/App Insights Tab -->
    {% if tool_visibility.url_insights %}
    <div id="url-insights" class="tab-content{% if not tool_visibility.ip_translator and not tool_visibility.command_runner and not tool_visibility.dns_lookup and not tool_visibility.traceroute %} active{% endif %}">
        <p>URL/App Insights - Browser-based Diagnostics</p>

        <div style="margin-bottom: 20px;">
            <label><strong>URL to Analyze:</strong></label><br>
            <input type="url" id="urlInsightsInput" placeholder="https://example.com"
                   style="width: 60%; padding: 8px; font-family: monospace;">
            <button onclick="analyzeURL()" style="padding: 8px 16px; background: #007cba; color: white; border: none; cursor: pointer; margin-left: 10px;">Analyze</button>
            <button onclick="clearURLAnalysis()" style="padding: 8px 16px; background: #6c757d; color: white; border: none; cursor: pointer; margin-left: 5px;">Clear</button>
            <br>
            <small style="color: #666;">Enter a full URL including http:// or https://</small>
        </div>

        <!-- Dual pane layout -->
        <div style="display: flex; gap: 20px; height: 600px;">
            <!-- Left pane: Content Display -->
            <div style="flex: 1; border: 1px solid #ccc; background: white; position: relative;">
                <div style="background: #f0f0f0; padding: 8px; border-bottom: 1px solid #ccc; display: flex; justify-content: space-between;">
                    <strong>Content Display</strong>
                    <span id="contentStatus" style="color: #666; font-size: 12px;">No URL loaded</span>
                </div>
                <div id="urlInsightsContent" style="height: calc(100% - 35px); overflow: auto; padding: 20px; background: #f9f9f9;">
                    <div id="urlPreview" style="text-align: center; color: #666; padding-top: 100px;">
                        <div style="font-size: 48px; margin-bottom: 20px;">üåê</div>
                        <p style="font-size: 16px; margin-bottom: 10px;">Enter a URL to begin analysis</p>
                        <p style="font-size: 12px; color: #999;">Click "Analyze" to open the URL and capture diagnostics</p>
                    </div>
                    <div id="urlInfo" style="display: none;">
                        <div style="background: #fff; padding: 15px; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 10px;">
                            <h4 style="margin: 0 0 10px 0; color: #333;">URL Information</h4>
                            <div style="font-family: monospace; font-size: 12px;">
                                <p><strong>URL:</strong> <span id="analyzed-url"></span></p>
                                <p><strong>Protocol:</strong> <span id="analyzed-protocol"></span></p>
                                <p><strong>Hostname:</strong> <span id="analyzed-hostname"></span></p>
                                <p><strong>Port:</strong> <span id="analyzed-port"></span></p>
                            </div>
                        </div>
                        <div style="background: #e7f3ff; padding: 12px; border: 1px solid #007cba; border-radius: 4px;">
                            <p style="margin: 0; font-size: 13px;">
                                ‚ÑπÔ∏è <strong>Note:</strong> The URL has been opened in a new tab. Check the Diagnostics panel for connection details.
                            </p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right pane: Diagnostics -->
            <div style="flex: 1; border: 1px solid #ccc; background: white; display: flex; flex-direction: column;">
                <div style="background: #f0f0f0; padding: 8px; border-bottom: 1px solid #ccc; display: flex; justify-content: space-between;">
                    <strong>Diagnostics</strong>
                    <button id="exportInsightsBtn" onclick="exportInsights()" style="display: none; padding: 4px 8px; font-size: 12px; cursor: pointer;">Export</button>
                </div>

                <!-- Tab buttons -->
                <div style="display: flex; border-bottom: 1px solid #ccc; background: #f9f9f9;">
                    <div class="insights-tab active" onclick="showInsightsTab('overview')" style="padding: 8px 16px; cursor: pointer; border-right: 1px solid #ccc;">Overview</div>
                    <div class="insights-tab" onclick="showInsightsTab('requests')" style="padding: 8px 16px; cursor: pointer; border-right: 1px solid #ccc;">Requests</div>
                    <div class="insights-tab" onclick="showInsightsTab('tls')" style="padding: 8px 16px; cursor: pointer; border-right: 1px solid #ccc;">TLS/SSL</div>
                    <div class="insights-tab" onclick="showInsightsTab('timeline')" style="padding: 8px 16px; cursor: pointer;">Timeline</div>
                </div>

                <!-- Tab content areas -->
                <div style="flex: 1; overflow-y: auto; padding: 10px;">
                    <!-- Overview tab -->
                    <div id="overview-content" class="insights-tab-content">
                        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-bottom: 15px;">
                            <div style="background: #f0f0f0; padding: 10px; text-align: center; border: 1px solid #ddd;">
                                <div id="stat-total-requests" style="font-size: 20px; font-weight: bold; color: #007cba;">0</div>
                                <div style="font-size: 11px; color: #666;">REQUESTS</div>
                            </div>
                            <div style="background: #f0f0f0; padding: 10px; text-align: center; border: 1px solid #ddd;">
                                <div id="stat-total-size" style="font-size: 20px; font-weight: bold; color: #007cba;">0 B</div>
                                <div style="font-size: 11px; color: #666;">TOTAL SIZE</div>
                            </div>
                            <div style="background: #f0f0f0; padding: 10px; text-align: center; border: 1px solid #ddd;">
                                <div id="stat-load-time" style="font-size: 20px; font-weight: bold; color: #007cba;">-</div>
                                <div style="font-size: 11px; color: #666;">LOAD TIME</div>
                            </div>
                            <div style="background: #f0f0f0; padding: 10px; text-align: center; border: 1px solid #ddd;">
                                <div id="stat-status-code" style="font-size: 20px; font-weight: bold; color: #007cba;">-</div>
                                <div style="font-size: 11px; color: #666;">STATUS</div>
                            </div>
                        </div>
                        <div style="font-family: monospace; font-size: 12px; line-height: 1.6;">
                            <div style="padding: 8px; background: #e7f3ff; border-left: 3px solid #007cba; margin-bottom: 5px;">
                                ‚Ñπ Ready to analyze URLs<br>
                                <small style="color: #666;">Connection diagnostics will appear here</small>
                            </div>
                        </div>
                    </div>

                    <!-- Requests tab -->
                    <div id="requests-content" class="insights-tab-content">
                        <em style="color: #666;">No requests captured yet...</em>
                    </div>

                    <!-- TLS/SSL tab -->
                    <div id="tls-content" class="insights-tab-content">
                        <em style="color: #666;">No TLS information available...</em>
                    </div>

                    <!-- Timeline tab -->
                    <div id="timeline-content" class="insights-tab-content">
                        <em style="color: #666;">No timeline events yet...</em>
                    </div>
                </div>
            </div>
        </div>
    </div>
    {% endif %}

    <!-- WhoAmI Tab -->
    {% if tool_visibility.whoami %}
    <div id="whoami" class="tab-content{% if not tool_visibility.ip_translator and not tool_visibility.command_runner and not tool_visibility.dns_lookup and not tool_visibility.traceroute and not tool_visibility.url_insights %} active{% endif %}">
        <p></p>

        <div style="max-width: 50%; margin: 0 auto;">
            <label><strong>Your IP Address:</strong></label><br>
            <div id="userIpAddress" style="border: 1px solid #ccc; padding: 20px; background: white; font-family: 'Consolas', monospace; font-size: 24px; font-weight: bold; text-align: center; margin: 10px 0;">
                <span style="color: #999;">Loading...</span>
            </div>

            <div id="ipDetails" style="margin-top: 10px; display: none;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                    <div>
                        <label><strong>IP Version:</strong></label><br>
                        <div id="ipVersion" style="border: 1px solid #ccc; padding: 8px; background: white; font-family: 'Consolas', monospace;">-</div>
                    </div>
                    <div>
                        <label><strong>Type:</strong></label><br>
                        <div id="ipType" style="border: 1px solid #ccc; padding: 8px; background: white; font-family: 'Consolas', monospace;">-</div>
                    </div>
                </div>
            </div>

            <div id="reverseDns" style="margin-top: 10px; display: none;">
                <label><strong>Reverse DNS:</strong></label><br>
                <div id="reverseDnsValue" style="border: 1px solid #ccc; padding: 8px; background: white; font-family: 'Consolas', monospace; word-break: break-all;">-</div>
            </div>

            <br>
            <div style="background: #f0f0f0; padding: 15px; border: 1px solid #ccc; margin-top: 10px;">
                <p style="margin: 0 0 10px 0;"><strong>About:</strong><br>
                This tool displays your public IP address as seen by the server.</p>
               
            </div>
        </div>
    </div>
    {% endif %}



    <!-- Tooltip container -->
    <div id="tooltip" style="position: absolute; display: none; z-index: 1000;"></div>

    <!-- Save Device List Modal -->
    <div id="saveDeviceModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Save Device List</h3>
                <span class="close" onclick="closeSaveDeviceModal()">&times;</span>
            </div>
            <div>
                <label for="deviceListName"><strong>List Name:</strong></label><br>
                <input type="text" id="deviceListName" placeholder="Enter list name" style="width: 100%; margin: 10px 0; padding: 5px;">
                <div style="margin-top: 15px;">
                    <button onclick="confirmSaveDeviceList()" style="padding: 8px 16px; background: #28a745; color: white; border: none; cursor: pointer; margin-right: 10px;">Save</button>
                    <button onclick="closeSaveDeviceModal()" style="padding: 8px 16px; background: #6c757d; color: white; border: none; cursor: pointer;">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Load Device List Modal -->
    <div id="loadDeviceModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Load Device List</h3>
                <span class="close" onclick="closeLoadDeviceModal()">&times;</span>
            </div>
            <div id="savedDeviceLists">
                <em>No saved device lists found...</em>
            </div>
        </div>
    </div>

    <!-- Save Command List Modal -->
    <div id="saveCommandModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Save Command List</h3>
                <span class="close" onclick="closeSaveCommandModal()">&times;</span>
            </div>
            <div>
                <label for="commandListName"><strong>List Name:</strong></label><br>
                <input type="text" id="commandListName" placeholder="Enter list name" style="width: 100%; margin: 10px 0; padding: 5px;">
                <div style="margin-top: 15px;">
                    <button onclick="confirmSaveCommandList()" style="padding: 8px 16px; background: #28a745; color: white; border: none; cursor: pointer; margin-right: 10px;">Save</button>
                    <button onclick="closeSaveCommandModal()" style="padding: 8px 16px; background: #6c757d; color: white; border: none; cursor: pointer;">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Load Command List Modal -->
    <div id="loadCommandModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Load Command List</h3>
                <span class="close" onclick="closeLoadCommandModal()">&times;</span>
            </div>
            <div id="savedCommandLists">
                <em>No saved command lists found...</em>
            </div>
        </div>
    </div>

    <!-- Save DNS Server List Modal -->
    <div id="saveDnsServerModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Save DNS Server List</h3>
                <span class="close" onclick="closeSaveDnsServerModal()">&times;</span>
            </div>
            <div>
                <label for="dnsServerListName"><strong>List Name:</strong></label><br>
                <input type="text" id="dnsServerListName" placeholder="Enter list name (e.g., Public DNS, Corporate DNS)" style="width: 100%; margin: 10px 0; padding: 5px;">
                <div style="margin-top: 15px;">
                    <button onclick="confirmSaveDnsServerList()" style="padding: 8px 16px; background: #28a745; color: white; border: none; cursor: pointer; margin-right: 10px;">Save</button>
                    <button onclick="closeSaveDnsServerModal()" style="padding: 8px 16px; background: #6c757d; color: white; border: none; cursor: pointer;">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Load DNS Server List Modal -->
    <div id="loadDnsServerModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Load DNS Server List</h3>
                <span class="close" onclick="closeLoadDnsServerModal()">&times;</span>
            </div>
            <div id="savedDnsServerLists">
                <em>No saved DNS server lists found...</em>
            </div>
        </div>
    </div>

    <!-- Save Traceroute Targets Modal -->
    <div id="saveTracerouteTargetsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Save Traceroute Targets</h3>
                <span class="close" onclick="closeSaveTracerouteTargetsModal()">&times;</span>
            </div>
            <div>
                <label for="tracerouteTargetsListName"><strong>List Name:</strong></label><br>
                <input type="text" id="tracerouteTargetsListName" placeholder="Enter list name (e.g., Core Networks, Remote Sites)" style="width: 100%; margin: 10px 0; padding: 5px;">
                <div style="margin-top: 15px;">
                    <button onclick="confirmSaveTracerouteTargets()" style="padding: 8px 16px; background: #28a745; color: white; border: none; cursor: pointer; margin-right: 10px;">Save</button>
                    <button onclick="closeSaveTracerouteTargetsModal()" style="padding: 8px 16px; background: #6c757d; color: white; border: none; cursor: pointer;">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Load Traceroute Targets Modal -->
    <div id="loadTracerouteTargetsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Load Traceroute Targets</h3>
                <span class="close" onclick="closeLoadTracerouteTargetsModal()">&times;</span>
            </div>
            <div id="savedTracerouteTargetLists">
                <em>No saved traceroute target lists found...</em>
            </div>
        </div>
    </div>
    <script>
        // Global variables
        let timeoutId;
        const inputText = document.getElementById('inputText');
        const outputArea = document.getElementById('outputArea');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const tooltip = document.getElementById('tooltip');

        // Command runner variables
        let devices = [];
        let commands = [];
        let commandResults = {};

        // Command validation rules (loaded from database)
        let commandRules = {
            safePrefixes: [],
            dangerousPatterns: [],
            standaloneCommands: []
        };

        // Tab switching function
        function showTab(tabName) {
            // Hide all tab contents
            const tabContents = document.querySelectorAll('.tab-content');
            tabContents.forEach(tab => tab.classList.remove('active'));

            // Remove active class from all tabs
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => tab.classList.remove('active'));

            // Show selected tab
            document.getElementById(tabName).classList.add('active');

            // Add active class to clicked tab
            event.target.classList.add('active');

            // Save current tab to localStorage
            localStorage.setItem('activeTab', tabName);
        }

        // Restore last active tab on page load
        document.addEventListener('DOMContentLoaded', function() {
            const savedTab = localStorage.getItem('activeTab');
            if (savedTab) {
                // Check if the saved tab element exists (in case it's been hidden by admin)
                const savedTabElement = document.getElementById(savedTab);
                if (savedTabElement) {
                    // Remove active class from all tabs
                    document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
                    document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));

                    // Activate saved tab
                    savedTabElement.classList.add('active');

                    // Find and activate the corresponding tab button
                    const tabButtons = document.querySelectorAll('.tab');
                    tabButtons.forEach(button => {
                        if (button.getAttribute('onclick').includes(savedTab)) {
                            button.classList.add('active');
                        }
                    });
                }
            }
        });

        // Load command validation rules from server
        function loadCommandRules() {
            fetch('/settings/api/command-rules')
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        commandRules = data.rules;
                    }
                })
                .catch(error => {
                    console.error('Error loading command rules:', error);
                    // Use default rules if server request fails
                    commandRules = {
                        safePrefixes: [
                            'show ',
                            'execute ping ',
                            'execute traceroute ',
                            'ping ',
                            'traceroute ',
                            'trace ',
                            'get system ',
                            'diagnose '
                        ],
                        dangerousPatterns: [
                            'delete',
                            'remove',
                            'erase',
                            'format',
                            'reload',
                            'reboot',
                            'shutdown',
                            'clear',
                            'reset',
                            'write',
                            'copy',
                            'configure',
                            'config',
                            'exit',
                            'quit',
                            'end',
                            'commit',
                            'save'
                        ],
                        standaloneCommands: [
                            'uptime',
                            'version',
                            'date',
                            'clock',
                            'whoami',
                            'pwd'
                        ]
                    };
                });
        }

        // Initialize page
        document.addEventListener('DOMContentLoaded', function() {
            loadCommandRules();
        });

        // Command safety validation function (client-side) - uses database rules
        function validateCommandSafety(command) {
            if (!command || typeof command !== 'string') {
                return { isValid: false, message: "Invalid command format" };
            }

            const cleanCommand = command.trim().toLowerCase();

            // Step 1: Check for dangerous patterns first (blocklist approach)
            for (const pattern of commandRules.dangerousPatterns) {
                if (cleanCommand.includes(pattern.toLowerCase())) {
                    return {
                        isValid: false,
                        message: `Dangerous command pattern detected: '${pattern}'. Only read-only troubleshooting commands are allowed.`
                    };
                }
            }

            // Step 2: Check for safe prefixes (allowlist approach)
            for (const prefix of commandRules.safePrefixes) {
                if (cleanCommand.startsWith(prefix.toLowerCase())) {
                    return { isValid: true, message: null };
                }
            }

            // Step 3: Check standalone commands
            if (commandRules.standaloneCommands.some(cmd => cleanCommand === cmd.toLowerCase())) {
                return { isValid: true, message: null };
            }

            return {
                isValid: false,
                message: `Command '${command}' is not in the list of allowed safe commands. Use the Settings page to manage allowed commands.`
            };
        }

        // Command runner functions
        function addDevice() {
            const deviceInput = document.getElementById('deviceInput');
            const device = deviceInput.value.trim();

            if (device && !devices.includes(device)) {
                devices.push(device);
                updateDeviceList();
                deviceInput.value = '';
            }
        }

        function addCommand() {
            const commandInput = document.getElementById('commandInput');
            const command = commandInput.value.trim();

            if (!command) {
                return;
            }

            // Validate command safety
            const validation = validateCommandSafety(command);
            if (!validation.isValid) {
                alert(`‚ùå Command Blocked\n\n${validation.message}\n\nOnly safe, read-only troubleshooting commands are allowed.`);
                commandInput.value = '';
                commandInput.focus();
                return;
            }

            if (!commands.includes(command)) {
                commands.push(command);
                updateCommandList();
                commandInput.value = '';
                // Visual feedback for successful addition
                const addButton = event.target;
                const originalText = addButton.textContent;
                addButton.textContent = '‚úì Added';
                addButton.style.backgroundColor = '#28a745';
                addButton.style.color = 'white';
                setTimeout(() => {
                    addButton.textContent = originalText;
                    addButton.style.backgroundColor = '';
                    addButton.style.color = '';
                }, 1000);
            } else {
                alert('Command already exists in the list');
                commandInput.value = '';
            }
        }

        function removeDevice(device) {
            devices = devices.filter(d => d !== device);
            updateDeviceList();
        }

        function removeCommand(command) {
            commands = commands.filter(c => c !== command);
            updateCommandList();
        }

        function updateDeviceList() {
            const deviceList = document.getElementById('deviceList');
            if (devices.length === 0) {
                deviceList.innerHTML = '<em>No devices added...</em>';
            } else {
                deviceList.innerHTML = devices.map(device =>
                    `<div>${device} <span class="remove-btn" onclick="removeDevice('${device}')">‚úó</span></div>`
                ).join('');
            }
        }

        function updateCommandList() {
            const commandList = document.getElementById('commandList');
            if (commands.length === 0) {
                commandList.innerHTML = '<em>No commands added...</em>';
            } else {
                commandList.innerHTML = commands.map(command =>
                    `<div>${command} <span class="remove-btn" onclick="removeCommand('${command}')">‚úó</span></div>`
                ).join('');
            }
        }

        async function runCommands() {
            const username = document.getElementById('username').value.trim();
            const password = document.getElementById('password').value.trim();

            if (!username || !password) {
                alert('Please enter username and password');
                return;
            }

            if (devices.length === 0) {
                alert('Please add at least one device');
                return;
            }

            if (commands.length === 0) {
                alert('Please add at least one command');
                return;
            }

            // Final safety check - validate all commands before execution
            const invalidCommands = [];
            for (const command of commands) {
                const validation = validateCommandSafety(command);
                if (!validation.isValid) {
                    invalidCommands.push({
                        command: command,
                        reason: validation.message
                    });
                }
            }

            if (invalidCommands.length > 0) {
                let errorMessage = `üö´ Execution Blocked - Unsafe Commands Detected\n\n`;
                invalidCommands.forEach(item => {
                    errorMessage += `‚Ä¢ "${item.command}"\n  Reason: ${item.reason}\n\n`;
                });
                errorMessage += `Please remove these commands and try again.`;
                alert(errorMessage);
                return;
            }

            const runProgress = document.getElementById('runProgress');
            const commandResults = document.getElementById('commandResults');

            runProgress.style.display = 'block';
            commandResults.innerHTML = '';

            try {
                const response = await fetch('/api/run-commands', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        devices: devices,
                        commands: commands,
                        username: username,
                        password: password
                    })
                });

                const data = await response.json();

                if (data.success) {
                    displayResults(data.results);
                    document.getElementById('downloadSection').style.display = 'block';
                } else {
                    alert('Error: ' + data.error);
                }
            } catch (error) {
                console.error('Error running commands:', error);
                alert('Error running commands: ' + error.message);
            } finally {
                runProgress.style.display = 'none';
            }
        }

        function displayResults(results) {
            const commandResults = document.getElementById('commandResults');
            commandResults.innerHTML = '';

            console.log('Displaying results:', results); // Debug log

            for (const [device, deviceData] of Object.entries(results)) {
                const deviceDiv = document.createElement('div');
                deviceDiv.className = 'device-output';

                const deviceHeader = document.createElement('h4');
                deviceHeader.textContent = `${device} (${deviceData.status})`;
                deviceDiv.appendChild(deviceHeader);

                if (deviceData.status === 'success') {
                    for (const [command, commandData] of Object.entries(deviceData.commands)) {
                        const commandDiv = document.createElement('div');
                        commandDiv.innerHTML = `<strong>Command:</strong> ${command}`;
                        deviceDiv.appendChild(commandDiv);

                        const outputDiv = document.createElement('div');
                        outputDiv.className = 'command-output';

                        // Debug logging
                        console.log(`Command: ${command}`);
                        console.log(`CommandData:`, commandData);
                        console.log(`Raw output length: ${commandData.output ? commandData.output.length : 0}`);
                        console.log(`Translated output length: ${commandData.translated_output ? commandData.translated_output.length : 0}`);

                        let outputText = 'No output received';
                        if (commandData.translated_output && commandData.translated_output.trim()) {
                            outputText = commandData.translated_output;
                        } else if (commandData.output && commandData.output.trim()) {
                            outputText = commandData.output;
                        }

                        // Use innerHTML instead of textContent to preserve formatting
                        outputDiv.innerHTML = outputText.replace(/\n/g, '<br>');
                        deviceDiv.appendChild(outputDiv);
                    }
                } else {
                    const errorDiv = document.createElement('div');
                    errorDiv.className = 'command-output';
                    errorDiv.style.color = 'red';
                    errorDiv.textContent = deviceData.error;
                    deviceDiv.appendChild(errorDiv);
                }

                commandResults.appendChild(deviceDiv);
            }

            // Store results for download
            window.lastResults = results;
        }

        async function downloadResults() {
            if (!window.lastResults) {
                alert('No results to download');
                return;
            }

            try {
                const response = await fetch('/api/download-results', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        results: window.lastResults
                    })
                });

                if (response.ok) {
                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `command_results_${new Date().toISOString().slice(0,19).replace(/:/g, '-')}.zip`;
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(url);
                    a.remove();
                } else {
                    alert('Error downloading results');
                }
            } catch (error) {
                console.error('Error downloading results:', error);
                alert('Error downloading results: ' + error.message);
            }
        }

        // Add event listeners for Enter key
        document.getElementById('deviceInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                addDevice();
            }
        });

        document.getElementById('commandInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                addCommand();
            }
        });

        // Add real-time command validation
        document.getElementById('commandInput').addEventListener('input', function(e) {
            const command = e.target.value.trim();
            const addButton = document.querySelector('button[onclick="addCommand()"]');

            // Remove existing validation classes
            e.target.classList.remove('command-input-valid', 'command-input-invalid');

            if (command) {
                const validation = validateCommandSafety(command);
                if (!validation.isValid) {
                    // Show visual feedback for invalid command
                    e.target.classList.add('command-input-invalid');
                    e.target.title = validation.message;
                    addButton.disabled = true;
                    addButton.style.opacity = '0.6';
                    addButton.title = 'Command not allowed - ' + validation.message;
                } else {
                    // Command is valid
                    e.target.classList.add('command-input-valid');
                    e.target.title = 'Valid command - ready to add';
                    addButton.disabled = false;
                    addButton.style.opacity = '1';
                    addButton.title = 'Add this command';
                }
            } else {
                // Reset to default state when empty
                e.target.title = '';
                addButton.disabled = false;
                addButton.style.opacity = '1';
                addButton.title = '';
            }
        });

        // Save/Load functionality for device lists
        function saveDeviceList() {
            if (devices.length === 0) {
                alert('No devices to save');
                return;
            }
            document.getElementById('saveDeviceModal').style.display = 'block';
            document.getElementById('deviceListName').focus();
        }

        function closeSaveDeviceModal() {
            document.getElementById('saveDeviceModal').style.display = 'none';
            document.getElementById('deviceListName').value = '';
        }

        function confirmSaveDeviceList() {
            const listName = document.getElementById('deviceListName').value.trim();
            if (!listName) {
                alert('Please enter a list name');
                return;
            }

            // Save to localStorage
            let savedDeviceLists = JSON.parse(localStorage.getItem('savedDeviceLists') || '{}');
            savedDeviceLists[listName] = {
                devices: [...devices],
                savedAt: new Date().toISOString()
            };
            localStorage.setItem('savedDeviceLists', JSON.stringify(savedDeviceLists));

            alert(`Device list "${listName}" saved successfully!`);
            closeSaveDeviceModal();
        }

        function loadDeviceList() {
            const savedDeviceLists = JSON.parse(localStorage.getItem('savedDeviceLists') || '{}');
            const savedListsDiv = document.getElementById('savedDeviceLists');

            if (Object.keys(savedDeviceLists).length === 0) {
                savedListsDiv.innerHTML = '<em>No saved device lists found...</em>';
            } else {
                savedListsDiv.innerHTML = '';
                for (const [listName, listData] of Object.entries(savedDeviceLists)) {
                    const savedItem = document.createElement('div');
                    savedItem.className = 'saved-item';

                    const itemInfo = document.createElement('div');
                    itemInfo.innerHTML = `
                        <div class="saved-item-name">${listName}</div>
                        <div class="saved-item-count">${listData.devices.length} devices - Saved: ${new Date(listData.savedAt).toLocaleDateString()}</div>
                    `;

                    const deleteBtn = document.createElement('span');
                    deleteBtn.className = 'delete-saved';
                    deleteBtn.innerHTML = '‚úó';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        deleteDeviceList(listName);
                    };

                    savedItem.appendChild(itemInfo);
                    savedItem.appendChild(deleteBtn);

                    savedItem.onclick = () => confirmLoadDeviceList(listName, listData.devices);
                    savedListsDiv.appendChild(savedItem);
                }
            }

            document.getElementById('loadDeviceModal').style.display = 'block';
        }

        function closeLoadDeviceModal() {
            document.getElementById('loadDeviceModal').style.display = 'none';
        }

        function confirmLoadDeviceList(listName, deviceList) {
            if (devices.length > 0) {
                if (!confirm(`This will replace your current device list (${devices.length} devices). Continue?`)) {
                    return;
                }
            }

            devices = [...deviceList];
            updateDeviceList();
            closeLoadDeviceModal();
            alert(`Device list "${listName}" loaded successfully!`);
        }

        function deleteDeviceList(listName) {
            if (confirm(`Delete device list "${listName}"?`)) {
                let savedDeviceLists = JSON.parse(localStorage.getItem('savedDeviceLists') || '{}');
                delete savedDeviceLists[listName];
                localStorage.setItem('savedDeviceLists', JSON.stringify(savedDeviceLists));
                loadDeviceList(); // Refresh the modal
            }
        }

        // Save/Load functionality for command lists
        function saveCommandList() {
            if (commands.length === 0) {
                alert('No commands to save');
                return;
            }
            document.getElementById('saveCommandModal').style.display = 'block';
            document.getElementById('commandListName').focus();
        }

        function closeSaveCommandModal() {
            document.getElementById('saveCommandModal').style.display = 'none';
            document.getElementById('commandListName').value = '';
        }

        function confirmSaveCommandList() {
            const listName = document.getElementById('commandListName').value.trim();
            if (!listName) {
                alert('Please enter a list name');
                return;
            }

            // Save to localStorage
            let savedCommandLists = JSON.parse(localStorage.getItem('savedCommandLists') || '{}');
            savedCommandLists[listName] = {
                commands: [...commands],
                savedAt: new Date().toISOString()
            };
            localStorage.setItem('savedCommandLists', JSON.stringify(savedCommandLists));

            alert(`Command list "${listName}" saved successfully!`);
            closeSaveCommandModal();
        }

        function loadCommandList() {
            const savedCommandLists = JSON.parse(localStorage.getItem('savedCommandLists') || '{}');
            const savedListsDiv = document.getElementById('savedCommandLists');

            if (Object.keys(savedCommandLists).length === 0) {
                savedListsDiv.innerHTML = '<em>No saved command lists found...</em>';
            } else {
                savedListsDiv.innerHTML = '';
                for (const [listName, listData] of Object.entries(savedCommandLists)) {
                    const savedItem = document.createElement('div');
                    savedItem.className = 'saved-item';

                    const itemInfo = document.createElement('div');
                    itemInfo.innerHTML = `
                        <div class="saved-item-name">${listName}</div>
                        <div class="saved-item-count">${listData.commands.length} commands - Saved: ${new Date(listData.savedAt).toLocaleDateString()}</div>
                    `;

                    const deleteBtn = document.createElement('span');
                    deleteBtn.className = 'delete-saved';
                    deleteBtn.innerHTML = '‚úó';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        deleteCommandList(listName);
                    };

                    savedItem.appendChild(itemInfo);
                    savedItem.appendChild(deleteBtn);

                    savedItem.onclick = () => confirmLoadCommandList(listName, listData.commands);
                    savedListsDiv.appendChild(savedItem);
                }
            }

            document.getElementById('loadCommandModal').style.display = 'block';
        }

        function closeLoadCommandModal() {
            document.getElementById('loadCommandModal').style.display = 'none';
        }

        function confirmLoadCommandList(listName, commandList) {
            if (commands.length > 0) {
                if (!confirm(`This will replace your current command list (${commands.length} commands). Continue?`)) {
                    return;
                }
            }

            // Validate all commands being loaded
            const validCommands = [];
            const invalidCommands = [];

            for (const command of commandList) {
                const validation = validateCommandSafety(command);
                if (validation.isValid) {
                    validCommands.push(command);
                } else {
                    invalidCommands.push({
                        command: command,
                        reason: validation.message
                    });
                }
            }

            if (invalidCommands.length > 0) {
                let warningMessage = `‚ö†Ô∏è Security Warning\n\n${invalidCommands.length} unsafe command(s) were blocked from loading:\n\n`;
                invalidCommands.forEach(item => {
                    warningMessage += `‚Ä¢ "${item.command}"\n  Reason: ${item.reason}\n\n`;
                });

                if (validCommands.length > 0) {
                    warningMessage += `${validCommands.length} safe command(s) will be loaded.`;
                } else {
                    warningMessage += `No safe commands found in this list.`;
                }

                alert(warningMessage);
            }

            commands = validCommands;
            updateCommandList();
            closeLoadCommandModal();

            if (validCommands.length > 0) {
                alert(`Command list "${listName}" loaded with ${validCommands.length} safe command(s)!`);
            } else {
                alert(`Command list "${listName}" contained no safe commands.`);
            }
        }

        function deleteCommandList(listName) {
            if (confirm(`Delete command list "${listName}"?`)) {
                let savedCommandLists = JSON.parse(localStorage.getItem('savedCommandLists') || '{}');
                delete savedCommandLists[listName];
                localStorage.setItem('savedCommandLists', JSON.stringify(savedCommandLists));
                loadCommandList(); // Refresh the modal
            }
        }

        // Save/Load functionality for traceroute targets
        function saveTracerouteTargets() {
            const tracerouteTargets = document.getElementById('tracerouteTargets').value.trim();

            if (!tracerouteTargets) {
                alert('No traceroute targets to save');
                return;
            }

            document.getElementById('saveTracerouteTargetsModal').style.display = 'block';
            document.getElementById('tracerouteTargetsListName').focus();
        }

        function closeSaveTracerouteTargetsModal() {
            document.getElementById('saveTracerouteTargetsModal').style.display = 'none';
            document.getElementById('tracerouteTargetsListName').value = '';
        }

        function confirmSaveTracerouteTargets() {
            const listName = document.getElementById('tracerouteTargetsListName').value.trim();
            if (!listName) {
                alert('Please enter a list name');
                return;
            }

            const tracerouteTargets = document.getElementById('tracerouteTargets').value.trim();
            const targetList = tracerouteTargets.split('\n').map(t => t.trim()).filter(t => t.length > 0);

            // Save to localStorage
            let savedTracerouteTargetLists = JSON.parse(localStorage.getItem('savedTracerouteTargetLists') || '{}');
            savedTracerouteTargetLists[listName] = {
                targets: targetList,
                savedAt: new Date().toISOString()
            };
            localStorage.setItem('savedTracerouteTargetLists', JSON.stringify(savedTracerouteTargetLists));

            alert(`Traceroute target list "${listName}" saved successfully!`);
            closeSaveTracerouteTargetsModal();
        }

        function loadTracerouteTargets() {
            const savedTracerouteTargetLists = JSON.parse(localStorage.getItem('savedTracerouteTargetLists') || '{}');
            const savedListsDiv = document.getElementById('savedTracerouteTargetLists');

            if (Object.keys(savedTracerouteTargetLists).length === 0) {
                savedListsDiv.innerHTML = '<em>No saved traceroute target lists found...</em>';
            } else {
                savedListsDiv.innerHTML = '';

                // Add predefined common target lists
                const commonTargetLists = {
                    'Public DNS Servers': ['8.8.8.8', '1.1.1.1', '208.67.222.222', '9.9.9.9'],
                    'Internet Destinations': ['google.com', 'cloudflare.com', 'github.com', 'stackoverflow.com'],
                    'Network Test Sites': ['test-ipv6.com', 'ipv6-test.com', 'whatismyipaddress.com'],
                    'RFC3330 Test IPs': ['192.0.2.1', '198.51.100.1', '203.0.113.1']
                };

                // Add common target lists section
                const commonHeader = document.createElement('div');
                commonHeader.innerHTML = '<strong style="color: #007cba;">Common Target Lists:</strong>';
                commonHeader.style.marginBottom = '10px';
                savedListsDiv.appendChild(commonHeader);

                for (const [listName, targets] of Object.entries(commonTargetLists)) {
                    const savedItem = document.createElement('div');
                    savedItem.className = 'saved-item';
                    savedItem.style.borderColor = '#007cba';

                    const itemInfo = document.createElement('div');
                    itemInfo.innerHTML = `
                        <div class="saved-item-name">${listName}</div>
                        <div class="saved-item-count">${targets.length} targets</div>
                    `;

                    savedItem.appendChild(itemInfo);
                    savedItem.onclick = () => confirmLoadTracerouteTargets(listName, targets);
                    savedListsDiv.appendChild(savedItem);
                }

                // Add separator
                const separator = document.createElement('div');
                separator.innerHTML = '<hr style="margin: 15px 0;"><strong style="color: #28a745;">Saved Lists:</strong>';
                separator.style.marginBottom = '10px';
                savedListsDiv.appendChild(separator);

                // Add saved target lists
                for (const [listName, listData] of Object.entries(savedTracerouteTargetLists)) {
                    const savedItem = document.createElement('div');
                    savedItem.className = 'saved-item';

                    const itemInfo = document.createElement('div');
                    itemInfo.innerHTML = `
                        <div class="saved-item-name">${listName}</div>
                        <div class="saved-item-count">${listData.targets.length} targets - Saved: ${new Date(listData.savedAt).toLocaleDateString()}</div>
                    `;

                    const deleteBtn = document.createElement('span');
                    deleteBtn.className = 'delete-saved';
                    deleteBtn.innerHTML = '‚úó';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        deleteTracerouteTargetList(listName);
                    };

                    savedItem.appendChild(itemInfo);
                    savedItem.appendChild(deleteBtn);

                    savedItem.onclick = () => confirmLoadTracerouteTargets(listName, listData.targets);
                    savedListsDiv.appendChild(savedItem);
                }
            }

            document.getElementById('loadTracerouteTargetsModal').style.display = 'block';
        }

        function closeLoadTracerouteTargetsModal() {
            document.getElementById('loadTracerouteTargetsModal').style.display = 'none';
        }

        function confirmLoadTracerouteTargets(listName, targetList) {
            const tracerouteTargetsTextarea = document.getElementById('tracerouteTargets');
            const currentTargets = tracerouteTargetsTextarea.value.trim();

            if (currentTargets) {
                if (!confirm(`This will replace your current target list. Continue?`)) {
                    return;
                }
            }

            tracerouteTargetsTextarea.value = targetList.join('\n');
            closeLoadTracerouteTargetsModal();
        }

        function deleteTracerouteTargetList(listName) {
            if (confirm(`Delete traceroute target list "${listName}"?`)) {
                let savedTracerouteTargetLists = JSON.parse(localStorage.getItem('savedTracerouteTargetLists') || '{}');
                delete savedTracerouteTargetLists[listName];
                localStorage.setItem('savedTracerouteTargetLists', JSON.stringify(savedTracerouteTargetLists));
                loadTracerouteTargets(); // Refresh the modal
            }
        }

        // Close modals when clicking outside
        window.onclick = function(event) {
            const modals = ['saveDeviceModal', 'loadDeviceModal', 'saveCommandModal', 'loadCommandModal', 'saveDnsServerModal', 'loadDnsServerModal', 'saveTracerouteTargetsModal', 'loadTracerouteTargetsModal'];
            modals.forEach(modalId => {
                const modal = document.getElementById(modalId);
                if (event.target === modal) {
                    modal.style.display = 'none';
                }
            });
        };

        // Add Enter key support for save modals
        document.getElementById('deviceListName').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                confirmSaveDeviceList();
            }
        });

        document.getElementById('commandListName').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                confirmSaveCommandList();
            }
        });

        // DNS Lookup functionality
        async function performDnsLookup() {
            const dnsInput = document.getElementById('dnsInput').value.trim();
            const dnsServers = document.getElementById('dnsServers').value.trim();
            const lookupType = document.getElementById('lookupType').value;
            const dnsResults = document.getElementById('dnsResults');
            const dnsProgress = document.getElementById('dnsProgress');

            if (!dnsInput) {
                alert('Please enter at least one domain or IP address');
                return;
            }

            // Parse input - split by lines and filter empty lines
            const targets = dnsInput.split('\n').map(line => line.trim()).filter(line => line.length > 0);
            const servers = dnsServers ? dnsServers.split('\n').map(line => line.trim()).filter(line => line.length > 0) : [];

            // Validate all targets
            const invalidTargets = [];
            for (const target of targets) {
                const validation = validateDnsTarget(target, lookupType);
                if (!validation.isValid) {
                    invalidTargets.push(`${target}: ${validation.message}`);
                }
            }

            // Validate all DNS servers
            const invalidServers = [];
            for (const server of servers) {
                const validation = validateDnsServer(server);
                if (!validation.isValid) {
                    invalidServers.push(`${server}: ${validation.message}`);
                }
            }

            // Check for validation errors
            const allErrors = [...invalidTargets, ...invalidServers];
            if (allErrors.length > 0) {
                alert('Invalid input(s) detected:\n\n' + allErrors.join('\n') + '\n\nPlease correct these entries and try again.');
                return;
            }

            dnsProgress.style.display = 'block';
            dnsResults.innerHTML = 'Performing DNS lookups...';

            try {
                const response = await fetch('/api/dns-lookup', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        targets: targets,
                        servers: servers,
                        lookup_type: lookupType
                    })
                });

                const data = await response.json();

                if (data.success) {
                    displayDnsResults(data.results);
                } else {
                    dnsResults.innerHTML = `Error: ${data.error}`;
                }
            } catch (error) {
                console.error('DNS lookup error:', error);
                dnsResults.innerHTML = `Error performing DNS lookup: ${error.message}`;
            } finally {
                dnsProgress.style.display = 'none';
            }
        }

        function displayDnsResults(results) {
            const dnsResults = document.getElementById('dnsResults');
            let output = [];

            output.push('DNS LOOKUP RESULTS');
            output.push('==================');
            output.push('');

            for (const [target, targetData] of Object.entries(results)) {
                if (targetData.error) {
                    output.push(`${target} - ERROR: ${targetData.error}`);
                    output.push('');
                    continue;
                }

                // Process results from each DNS server
                for (const [server, serverResults] of Object.entries(targetData.servers)) {
                    const serverName = server === 'system_default' ? 'System DNS' : server;

                    if (serverResults.error) {
                        output.push(`${target} - ERROR: ${serverResults.error} - DNS Server: ${serverName}`);
                    } else if (serverResults.records && serverResults.records.length > 0) {
                        serverResults.records.forEach(record => {
                            // Simplified single-line format for A and PTR records
                            if (record.type === 'A' || record.type === 'PTR') {
                                const ttlInfo = record.ttl ? ` - TTL: ${record.ttl}` : '';
                                output.push(`${target} ${record.value} - DNS Server: ${serverName}${ttlInfo}`);
                            } else {
                                // Keep more detailed format for other record types
                                const ttlInfo = record.ttl ? ` - TTL: ${record.ttl}` : '';
                                output.push(`${target} - ${record.type}: ${record.value} - DNS Server: ${serverName}${ttlInfo}`);
                            }
                        });
                    } else {
                        output.push(`${target} - No records found - DNS Server: ${serverName}`);
                    }
                }
                output.push('');
            }

            dnsResults.textContent = output.join('\n');
        }

        function copyDnsResults() {
            const dnsResults = document.getElementById('dnsResults');
            const textToCopy = dnsResults.textContent;

            navigator.clipboard.writeText(textToCopy).then(() => {
                // Visual feedback on the copy button
                const copyButton = document.getElementById('copyDnsButton');
                const originalText = copyButton.textContent;
                copyButton.textContent = 'Copied!';
                copyButton.style.backgroundColor = '#4caf50';
                copyButton.style.color = 'white';

                setTimeout(() => {
                    copyButton.textContent = originalText;
                    copyButton.style.backgroundColor = '';
                    copyButton.style.color = '';
                }, 1000);
            }).catch(err => {
                console.error('Failed to copy text: ', err);
                alert('Failed to copy to clipboard');
            });
        }

        // Save/Load functionality for DNS server lists
        function saveDnsServerList() {
            const dnsServers = document.getElementById('dnsServers').value.trim();

            if (!dnsServers) {
                alert('No DNS servers to save');
                return;
            }

            document.getElementById('saveDnsServerModal').style.display = 'block';
            document.getElementById('dnsServerListName').focus();
        }

        function closeSaveDnsServerModal() {
            document.getElementById('saveDnsServerModal').style.display = 'none';
            document.getElementById('dnsServerListName').value = '';
        }

        function confirmSaveDnsServerList() {
            const listName = document.getElementById('dnsServerListName').value.trim();
            if (!listName) {
                alert('Please enter a list name');
                return;
            }

            const dnsServers = document.getElementById('dnsServers').value.trim();
            const serverList = dnsServers.split('\n').map(s => s.trim()).filter(s => s.length > 0);

            // Save to localStorage
            let savedDnsServerLists = JSON.parse(localStorage.getItem('savedDnsServerLists') || '{}');
            savedDnsServerLists[listName] = {
                servers: serverList,
                savedAt: new Date().toISOString()
            };
            localStorage.setItem('savedDnsServerLists', JSON.stringify(savedDnsServerLists));

            alert(`DNS server list "${listName}" saved successfully!`);
            closeSaveDnsServerModal();
        }

        function loadDnsServerList() {
            const savedDnsServerLists = JSON.parse(localStorage.getItem('savedDnsServerLists') || '{}');
            const savedListsDiv = document.getElementById('savedDnsServerLists');

            if (Object.keys(savedDnsServerLists).length === 0) {
                savedListsDiv.innerHTML = '<em>No saved DNS server lists found...</em>';
            } else {
                savedListsDiv.innerHTML = '';

                // Add predefined common DNS server lists
                const commonDnsLists = {
                    'Public DNS - Google': ['8.8.8.8', '8.8.4.4'],
                    'Public DNS - Cloudflare': ['1.1.1.1', '1.0.0.1'],
                    'Public DNS - OpenDNS': ['208.67.222.222', '208.67.220.220'],
                    'Public DNS - Quad9': ['9.9.9.9', '149.112.112.112'],
                    'Public DNS - All Combined': ['8.8.8.8', '1.1.1.1', '208.67.222.222', '9.9.9.9']
                };

                // Add common DNS lists section
                const commonHeader = document.createElement('div');
                commonHeader.innerHTML = '<strong style="color: #007cba;">Common DNS Servers:</strong>';
                commonHeader.style.marginBottom = '10px';
                savedListsDiv.appendChild(commonHeader);

                for (const [listName, servers] of Object.entries(commonDnsLists)) {
                    const savedItem = document.createElement('div');
                    savedItem.className = 'saved-item';
                    savedItem.style.borderColor = '#007cba';

                    const itemInfo = document.createElement('div');
                    itemInfo.innerHTML = `
                        <div class="saved-item-name">${listName}</div>
                        <div class="saved-item-count">${servers.length} servers</div>
                    `;

                    savedItem.appendChild(itemInfo);
                    savedItem.onclick = () => confirmLoadDnsServerList(listName, servers);
                    savedListsDiv.appendChild(savedItem);
                }

                // Add separator
                const separator = document.createElement('div');
                separator.innerHTML = '<hr style="margin: 15px 0;"><strong style="color: #28a745;">Saved Lists:</strong>';
                separator.style.marginBottom = '10px';
                savedListsDiv.appendChild(separator);

                // Add saved DNS lists
                for (const [listName, listData] of Object.entries(savedDnsServerLists)) {
                    const savedItem = document.createElement('div');
                    savedItem.className = 'saved-item';

                    const itemInfo = document.createElement('div');
                    itemInfo.innerHTML = `
                        <div class="saved-item-name">${listName}</div>
                        <div class="saved-item-count">${listData.servers.length} servers - Saved: ${new Date(listData.savedAt).toLocaleDateString()}</div>
                    `;

                    const deleteBtn = document.createElement('span');
                    deleteBtn.className = 'delete-saved';
                    deleteBtn.innerHTML = '‚úó';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        deleteDnsServerList(listName);
                    };

                    savedItem.appendChild(itemInfo);
                    savedItem.appendChild(deleteBtn);

                    savedItem.onclick = () => confirmLoadDnsServerList(listName, listData.servers);
                    savedListsDiv.appendChild(savedItem);
                }
            }

            document.getElementById('loadDnsServerModal').style.display = 'block';
        }

        function closeLoadDnsServerModal() {
            document.getElementById('loadDnsServerModal').style.display = 'none';
        }

        function confirmLoadDnsServerList(listName, serverList) {
            const dnsServersTextarea = document.getElementById('dnsServers');
            dnsServersTextarea.value = serverList.join('\n');
            closeLoadDnsServerModal();
        }

        function deleteDnsServerList(listName) {
            if (confirm(`Delete DNS server list "${listName}"?`)) {
                let savedDnsServerLists = JSON.parse(localStorage.getItem('savedDnsServerLists') || '{}');
                delete savedDnsServerLists[listName];
                localStorage.setItem('savedDnsServerLists', JSON.stringify(savedDnsServerLists));
                loadDnsServerList(); // Refresh the modal
            }
        }

        // Add Enter key support for DNS server save modal
        document.getElementById('dnsServerListName').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                confirmSaveDnsServerList();
            }
        });

        // Add Enter key support for traceroute targets save modal
        document.getElementById('tracerouteTargetsListName').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                confirmSaveTracerouteTargets();
            }
        });

        // Traceroute functionality
        let tracerouteResultsData = {};
        let tracerouteEventSource = null;
        let currentTracerouteData = {};

        // Function to validate hostname or IP address for traceroute
        function validateTracerouteTarget(target) {
            // Remove any whitespace
            target = target.trim();

            // Check for spaces or invalid characters
            if (target.includes(' ')) {
                return { isValid: false, message: 'Spaces are not allowed' };
            }

            // IPv4 address pattern
            const ipv4Pattern = /^(\d{1,3}\.){3}\d{1,3}$/;

            // IPv6 address pattern (simplified)
            const ipv6Pattern = /^([0-9a-fA-F]{0,4}:){2,7}[0-9a-fA-F]{0,4}$/;

            // Hostname/domain pattern - only allows letters, numbers, dots, and hyphens
            // Must start and end with alphanumeric, can contain dots and hyphens in the middle
            const hostnamePattern = /^[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?)*$/;

            // Check if it's an IPv4 address
            if (ipv4Pattern.test(target)) {
                // Validate IPv4 octets are in range 0-255
                const octets = target.split('.');
                for (const octet of octets) {
                    const num = parseInt(octet);
                    if (num < 0 || num > 255) {
                        return { isValid: false, message: 'Invalid IPv4 address (octets must be 0-255)' };
                    }
                }
                return { isValid: true, type: 'ipv4' };
            }

            // Check if it's an IPv6 address
            if (ipv6Pattern.test(target) || target.includes(':')) {
                // Basic IPv6 validation
                if (target.match(/[^0-9a-fA-F:]/)) {
                    return { isValid: false, message: 'Invalid IPv6 address (contains invalid characters)' };
                }
                return { isValid: true, type: 'ipv6' };
            }

            // Check if it's a valid hostname/domain
            if (hostnamePattern.test(target)) {
                // Additional hostname validations
                if (target.length > 253) {
                    return { isValid: false, message: 'Hostname too long (max 253 characters)' };
                }

                // Check each label (part between dots)
                const labels = target.split('.');
                for (const label of labels) {
                    if (label.length > 63) {
                        return { isValid: false, message: 'Domain label too long (max 63 characters per label)' };
                    }
                    if (label.startsWith('-') || label.endsWith('-')) {
                        return { isValid: false, message: 'Domain labels cannot start or end with hyphens' };
                    }
                }

                return { isValid: true, type: 'hostname' };
            }

            // Check for common invalid characters
            const invalidChars = target.match(/[^a-zA-Z0-9.\-:]/);
            if (invalidChars) {
                return {
                    isValid: false,
                    message: `Invalid character(s) found: ${invalidChars.join(', ')}. Only letters, numbers, dots, hyphens, and colons (for IPv6) are allowed.`
                };
            }

            return { isValid: false, message: 'Invalid format. Please enter a valid IP address or hostname.' };
        }

        // Function to validate DNS lookup target (hostname, IP, or domain)
        function validateDnsTarget(target, lookupType) {
            // Remove any whitespace
            target = target.trim();

            // Check for spaces or invalid characters
            if (target.includes(' ')) {
                return { isValid: false, message: 'Spaces are not allowed' };
            }

            // IPv4 address pattern
            const ipv4Pattern = /^(\d{1,3}\.){3}\d{1,3}$/;

            // IPv6 address pattern (simplified)
            const ipv6Pattern = /^([0-9a-fA-F]{0,4}:){2,7}[0-9a-fA-F]{0,4}$/;

            // Hostname/domain pattern - only allows letters, numbers, dots, and hyphens
            const hostnamePattern = /^[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?)*$/;

            // Check if it's an IPv4 address
            if (ipv4Pattern.test(target)) {
                // Validate IPv4 octets are in range 0-255
                const octets = target.split('.');
                for (const octet of octets) {
                    const num = parseInt(octet);
                    if (num < 0 || num > 255) {
                        return { isValid: false, message: 'Invalid IPv4 address (octets must be 0-255)' };
                    }
                }

                // IP addresses are valid for all lookup types
                return { isValid: true, type: 'ipv4' };
            }

            // Check if it's an IPv6 address
            if (ipv6Pattern.test(target) || target.includes(':')) {
                // Basic IPv6 validation
                if (target.match(/[^0-9a-fA-F:]/)) {
                    return { isValid: false, message: 'Invalid IPv6 address (contains invalid characters)' };
                }

                // IPv6 addresses are valid for all lookup types
                return { isValid: true, type: 'ipv6' };
            }

            // Check if it's a valid hostname/domain
            if (hostnamePattern.test(target)) {
                // Additional hostname validations
                if (target.length > 253) {
                    return { isValid: false, message: 'Hostname too long (max 253 characters)' };
                }

                // Check each label (part between dots)
                const labels = target.split('.');
                for (const label of labels) {
                    if (label.length > 63) {
                        return { isValid: false, message: 'Domain label too long (max 63 characters per label)' };
                    }
                    if (label.startsWith('-') || label.endsWith('-')) {
                        return { isValid: false, message: 'Domain labels cannot start or end with hyphens' };
                    }
                }

                // Hostnames are valid for all lookup types
                return { isValid: true, type: 'hostname' };
            }

            // Check for common invalid characters
            const invalidChars = target.match(/[^a-zA-Z0-9.\-:]/);
            if (invalidChars) {
                return {
                    isValid: false,
                    message: `Invalid character(s) found: ${invalidChars.join(', ')}. Only letters, numbers, dots, hyphens, and colons (for IPv6) are allowed.`
                };
            }

            return { isValid: false, message: 'Invalid format. Please enter a valid IP address or hostname.' };
        }

        // Function to validate DNS server address
        function validateDnsServer(server) {
            server = server.trim();

            // Check for spaces
            if (server.includes(' ')) {
                return { isValid: false, message: 'Spaces are not allowed in DNS server addresses' };
            }

            // IPv4 address pattern
            const ipv4Pattern = /^(\d{1,3}\.){3}\d{1,3}$/;

            // IPv6 address pattern (simplified)
            const ipv6Pattern = /^([0-9a-fA-F]{0,4}:){2,7}[0-9a-fA-F]{0,4}$/;

            // Check if it's an IPv4 address
            if (ipv4Pattern.test(server)) {
                const octets = server.split('.');
                for (const octet of octets) {
                    const num = parseInt(octet);
                    if (num < 0 || num > 255) {
                        return { isValid: false, message: 'Invalid IPv4 address (octets must be 0-255)' };
                    }
                }
                return { isValid: true, type: 'ipv4' };
            }

            // Check if it's an IPv6 address
            if (ipv6Pattern.test(server) || server.includes(':')) {
                if (server.match(/[^0-9a-fA-F:]/)) {
                    return { isValid: false, message: 'Invalid IPv6 address (contains invalid characters)' };
                }
                return { isValid: true, type: 'ipv6' };
            }

            return { isValid: false, message: 'DNS servers must be valid IP addresses' };
        }

        // Function to validate DNS input in real-time
        function validateDnsInput() {
            const textarea = document.getElementById('dnsInput');
            const serversTextarea = document.getElementById('dnsServers');
            const lookupType = document.getElementById('lookupType').value;
            const validationDiv = document.getElementById('dnsValidation');
            const serversValidationDiv = document.getElementById('dnsServersValidation');

            const input = textarea.value.trim();
            const serversInput = serversTextarea.value.trim();

            // Validate targets
            if (!input) {
                validationDiv.innerHTML = '';
                textarea.style.borderColor = '';
            } else {
                const targets = input.split('\n').map(line => line.trim()).filter(line => line.length > 0);
                const invalidTargets = [];
                const validTargets = [];

                for (const target of targets) {
                    const validation = validateDnsTarget(target, lookupType);
                    if (!validation.isValid) {
                        invalidTargets.push(`${target}: ${validation.message}`);
                    } else {
                        validTargets.push(`${target} (${validation.type})`);
                    }
                }

                if (invalidTargets.length > 0) {
                    textarea.style.borderColor = '#dc3545';
                    validationDiv.innerHTML = `
                        <div style="color: #dc3545; font-size: 12px; font-family: monospace;">
                            <strong>‚ùå ${invalidTargets.length} invalid target(s):</strong><br>
                            ${invalidTargets.slice(0, 3).join('<br>')}
                            ${invalidTargets.length > 3 ? `<br>... and ${invalidTargets.length - 3} more` : ''}
                        </div>
                    `;
                } else {
                    textarea.style.borderColor = '#28a745';
                    validationDiv.innerHTML = `
                        <div style="color: #28a745; font-size: 12px; font-family: monospace;">
                            <strong>‚úÖ ${validTargets.length} valid target(s)</strong>
                            ${validTargets.length <= 3 ? '<br>' + validTargets.join('<br>') : ''}
                        </div>
                    `;
                }
            }

            // Validate DNS servers
            if (!serversInput) {
                serversValidationDiv.innerHTML = '<div style="color: #6c757d; font-size: 12px;">Using system default DNS servers</div>';
                serversTextarea.style.borderColor = '';
            } else {
                const servers = serversInput.split('\n').map(line => line.trim()).filter(line => line.length > 0);
                const invalidServers = [];
                const validServers = [];

                for (const server of servers) {
                    const validation = validateDnsServer(server);
                    if (!validation.isValid) {
                        invalidServers.push(`${server}: ${validation.message}`);
                    } else {
                        validServers.push(`${server} (${validation.type})`);
                    }
                }

                if (invalidServers.length > 0) {
                    serversTextarea.style.borderColor = '#dc3545';
                    serversValidationDiv.innerHTML = `
                        <div style="color: #dc3545; font-size: 12px; font-family: monospace;">
                            <strong>‚ùå ${invalidServers.length} invalid DNS server(s):</strong><br>
                            ${invalidServers.slice(0, 2).join('<br>')}
                            ${invalidServers.length > 2 ? `<br>... and ${invalidServers.length - 2} more` : ''}
                        </div>
                    `;
                } else {
                    serversTextarea.style.borderColor = '#28a745';
                    serversValidationDiv.innerHTML = `
                        <div style="color: #28a745; font-size: 12px; font-family: monospace;">
                            <strong>‚úÖ ${validServers.length} valid DNS server(s)</strong>
                            ${validServers.length <= 3 ? '<br>' + validServers.join('<br>') : ''}
                        </div>
                    `;
                }
            }
        }

        // Function to validate traceroute input in real-time
        function validateTracerouteInput() {
            const textarea = document.getElementById('tracerouteTargets');
            const validationDiv = document.getElementById('tracerouteValidation');
            const input = textarea.value.trim();

            if (!input) {
                validationDiv.innerHTML = '';
                textarea.style.borderColor = '';
                return;
            }

            const targets = input.split('\n').map(line => line.trim()).filter(line => line.length > 0);
            const invalidTargets = [];
            const validTargets = [];

            for (const target of targets) {
                const validation = validateTracerouteTarget(target);
                if (!validation.isValid) {
                    invalidTargets.push(`${target}: ${validation.message}`);
                } else {
                    validTargets.push(`${target} (${validation.type})`);
                }
            }

            if (invalidTargets.length > 0) {
                textarea.style.borderColor = '#dc3545';
                validationDiv.innerHTML = `
                    <div style="color: #dc3545; font-size: 12px; font-family: monospace;">
                        <strong>‚ùå ${invalidTargets.length} invalid target(s):</strong><br>
                        ${invalidTargets.slice(0, 3).join('<br>')}
                        ${invalidTargets.length > 3 ? `<br>... and ${invalidTargets.length - 3} more` : ''}
                    </div>
                `;
            } else {
                textarea.style.borderColor = '#28a745';
                validationDiv.innerHTML = `
                    <div style="color: #28a745; font-size: 12px; font-family: monospace;">
                        <strong>‚úÖ ${validTargets.length} valid target(s)</strong>
                        ${validTargets.length <= 5 ? ': ' + validTargets.join(', ') : ''}
                    </div>
                `;
            }
        }

        async function performTraceroute() {
            const targetsInput = document.getElementById('tracerouteTargets').value.trim();
            const maxHops = parseInt(document.getElementById('maxHops').value);
            const timeout = parseInt(document.getElementById('traceTimeout').value);
            const probesPerHop = parseInt(document.getElementById('probesPerHop').value);
            const packetSize = parseInt(document.getElementById('packetSize').value);
            const translateIPs = document.getElementById('translateIPs').checked;
            const resolveHostnames = document.getElementById('resolveHostnames').checked;

            const tracerouteResults = document.getElementById('tracerouteResults');
            const tracerouteProgress = document.getElementById('tracerouteProgress');
            const tracerouteProgressDetail = document.getElementById('tracerouteProgressDetail');

            if (!targetsInput) {
                alert('Please enter at least one target host');
                return;
            }

            // Parse input - split by lines and filter empty lines
            const targets = targetsInput.split('\n').map(line => line.trim()).filter(line => line.length > 0);

            // Validate all targets
            const invalidTargets = [];
            for (const target of targets) {
                const validation = validateTracerouteTarget(target);
                if (!validation.isValid) {
                    invalidTargets.push(`${target}: ${validation.message}`);
                }
            }

            if (invalidTargets.length > 0) {
                alert('Invalid target(s) detected:\n\n' + invalidTargets.join('\n') + '\n\nPlease correct these entries and try again.');
                return;
            }

            // Close any existing SSE connection
            if (tracerouteEventSource) {
                tracerouteEventSource.close();
            }

            // Reset data
            currentTracerouteData = {};
            tracerouteResultsData = {};

            // Show stop button, hide run button
            document.getElementById('runTracerouteButton').style.display = 'none';
            document.getElementById('stopTracerouteButton').style.display = 'inline-block';

            tracerouteProgress.style.display = 'block';
            tracerouteProgressDetail.textContent = `Starting traceroutes to ${targets.length} targets...`;
            tracerouteResults.innerHTML = '';

            // Initialize display for each target
            targets.forEach(target => {
                currentTracerouteData[target] = { hops: [] };
            });

            // Build query parameters
            const params = new URLSearchParams({
                targets: targets.join(','),
                max_hops: maxHops,
                timeout: timeout,
                probes_per_hop: probesPerHop,
                packet_size: packetSize,
                translate_ips: translateIPs,
                resolve_hostnames: resolveHostnames
            });

            // Create SSE connection for real-time updates
            tracerouteEventSource = new EventSource(`/api/traceroute-stream?${params}`);

            tracerouteEventSource.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    handleTracerouteUpdate(data, translateIPs);
                } catch (error) {
                    console.error('Error parsing SSE data:', error);
                }
            };

            tracerouteEventSource.onerror = function(error) {
                console.error('SSE error:', error);
                tracerouteEventSource.close();
                tracerouteProgress.style.display = 'none';
                // Show run button, hide stop button
                document.getElementById('runTracerouteButton').style.display = 'inline-block';
                document.getElementById('stopTracerouteButton').style.display = 'none';
            };
        }

        function stopTraceroute() {
            if (tracerouteEventSource) {
                tracerouteEventSource.close();
                tracerouteEventSource = null;
            }

            const tracerouteProgress = document.getElementById('tracerouteProgress');
            const tracerouteProgressDetail = document.getElementById('tracerouteProgressDetail');

            tracerouteProgressDetail.textContent = 'Traceroute stopped by user.';

            setTimeout(() => {
                tracerouteProgress.style.display = 'none';
            }, 1500);

            // Show run button, hide stop button
            document.getElementById('runTracerouteButton').style.display = 'inline-block';
            document.getElementById('stopTracerouteButton').style.display = 'none';
        }

        function handleTracerouteUpdate(data, translateIPs) {
            const tracerouteResults = document.getElementById('tracerouteResults');
            const tracerouteProgressDetail = document.getElementById('tracerouteProgressDetail');

            switch(data.type) {
                case 'init':
                    tracerouteResults.innerHTML = '<div style="font-weight: bold; margin-bottom: 10px;">TRACEROUTE RESULTS (Real-time)</div>';
                    break;

                case 'start':
                    tracerouteProgressDetail.textContent = data.message;
                    // Use display_target if available (includes resolved IP), otherwise use original target
                    const displayTarget = data.display_target || data.target;
                    // Create separate div for this target if it doesn't exist
                    let targetDiv = document.getElementById(`traceroute-${data.target.replace(/[^a-zA-Z0-9]/g, '-')}`);
                    if (!targetDiv) {
                        targetDiv = document.createElement('div');
                        targetDiv.id = `traceroute-${data.target.replace(/[^a-zA-Z0-9]/g, '-')}`;
                        targetDiv.style.cssText = 'margin-bottom: 20px; padding: 10px; border: 1px solid #ccc; background-color: #f9f9f9; font-family: monospace;';

                        const targetHeader = document.createElement('div');
                        targetHeader.style.cssText = 'font-weight: bold; color: #333; margin-bottom: 5px; border-bottom: 1px solid #ddd; padding-bottom: 5px;';
                        targetHeader.textContent = `Target: ${displayTarget}`;
                        targetDiv.appendChild(targetHeader);

                        const hopsContainer = document.createElement('pre');
                        hopsContainer.id = `hops-${data.target.replace(/[^a-zA-Z0-9]/g, '-')}`;
                        hopsContainer.style.cssText = 'margin: 0; white-space: pre-wrap; font-family: monospace;';
                        hopsContainer.textContent = '\n';  // Start with newline so first hop appears on new line
                        targetDiv.appendChild(hopsContainer);

                        tracerouteResults.appendChild(targetDiv);
                    }
                    break;

                case 'hop':
                    // Find the target's div and add hop
                    const targetId = `hops-${data.target.replace(/[^a-zA-Z0-9]/g, '-')}`;
                    const hopsContainer = document.getElementById(targetId);
                    const hop = data.hop;

                    if (hopsContainer) {
                        let hopLine = `${hop.hop_num.toString().padStart(2)}  `;

                        if (hop.probes && hop.probes.length > 0) {
                            hop.probes.forEach(probe => {
                                if (probe.success) {
                                    let probeInfo = '';

                                    // Show IP or hostname
                                    if (probe.hostname && probe.hostname !== probe.ip) {
                                        probeInfo += `${probe.hostname} (${probe.ip})`;
                                    } else {
                                        probeInfo += probe.ip;
                                    }

                                    // Add translated info if available and enabled
                                    if (translateIPs && probe.translated_info) {
                                        probeInfo += ` [${probe.translated_info}]`;
                                    }

                                    // Add RTT
                                    probeInfo += `  ${probe.rtt} ms`;

                                    hopLine += probeInfo + '  ';
                                } else {
                                    hopLine += '*  ';
                                }
                            });
                        } else {
                            hopLine += '* * *';
                        }

                        // Append hop line to target-specific container
                        hopsContainer.textContent += hopLine + '\n';
                    }

                    // Store hop data
                    if (!currentTracerouteData[data.target]) {
                        currentTracerouteData[data.target] = { hops: [] };
                    }
                    currentTracerouteData[data.target].hops.push(hop);
                    break;

                case 'complete':
                    tracerouteProgressDetail.textContent = data.message;
                    // Add completion message to target's div
                    const completedTargetId = `hops-${data.target.replace(/[^a-zA-Z0-9]/g, '-')}`;
                    const completedHopsContainer = document.getElementById(completedTargetId);
                    if (completedHopsContainer) {
                        completedHopsContainer.textContent += '\nTraceroute completed.\n';
                    }
                    // Store completed data
                    tracerouteResultsData[data.target] = currentTracerouteData[data.target];
                    break;

                case 'error':
                    // Add error to target's div or general results if no specific target
                    if (data.target) {
                        const errorTargetId = `hops-${data.target.replace(/[^a-zA-Z0-9]/g, '-')}`;
                        const errorHopsContainer = document.getElementById(errorTargetId);
                        if (errorHopsContainer) {
                            errorHopsContainer.textContent += `Error: ${data.error}\n`;
                        }
                    } else {
                        const errorDiv = document.createElement('div');
                        errorDiv.style.cssText = 'color: red; margin-bottom: 10px; padding: 5px; background-color: #ffe6e6; border: 1px solid #ff9999;';
                        errorDiv.textContent = `Error: ${data.error}`;
                        tracerouteResults.appendChild(errorDiv);
                    }
                    break;

                case 'parse_fail':
                    // Display the unparsed line as a fallback in target's div
                    const parseFailTargetId = `hops-${data.target.replace(/[^a-zA-Z0-9]/g, '-')}`;
                    const parseFailHopsContainer = document.getElementById(parseFailTargetId);
                    if (parseFailHopsContainer && data.line.match(/^\s*\d+/)) {
                        parseFailHopsContainer.textContent += `${data.line}\n`;
                    }
                    break;

                case 'all_complete':
                    document.getElementById('tracerouteProgress').style.display = 'none';
                    tracerouteEventSource.close();
                    // Show run button, hide stop button
                    document.getElementById('runTracerouteButton').style.display = 'inline-block';
                    document.getElementById('stopTracerouteButton').style.display = 'none';
                    break;
            }

            // Auto-scroll to bottom
            const resultsDiv = document.getElementById('tracerouteResults');
            resultsDiv.scrollTop = resultsDiv.scrollHeight;
        }

        function displayTracerouteResults(results, translateIPs) {
            const tracerouteResults = document.getElementById('tracerouteResults');
            let output = [];

            output.push('TRACEROUTE RESULTS');
            output.push('=' .repeat(80));
            output.push('');

            for (const [target, targetData] of Object.entries(results)) {
                // Use display_target if available (includes resolved IP), otherwise use original target
                const displayTarget = targetData.display_target || target;
                output.push(`Target: ${displayTarget}`);
                output.push('-'.repeat(40));

                if (targetData.error) {
                    output.push(`Error: ${targetData.error}`);
                    output.push('');
                    continue;
                }

                if (targetData.hops && targetData.hops.length > 0) {
                    targetData.hops.forEach(hop => {
                        let hopLine = `${hop.hop_num.toString().padStart(2)}  `;

                        if (hop.probes && hop.probes.length > 0) {
                            hop.probes.forEach(probe => {
                                if (probe.success) {
                                    let probeInfo = '';

                                    // Show IP or hostname
                                    if (probe.hostname && probe.hostname !== probe.ip) {
                                        probeInfo += `${probe.hostname} (${probe.ip})`;
                                    } else {
                                        probeInfo += probe.ip;
                                    }

                                    // Add translated info if available and enabled
                                    if (translateIPs && probe.translated_info) {
                                        probeInfo += ` [${probe.translated_info}]`;
                                    }

                                    // Add RTT
                                    probeInfo += `  ${probe.rtt} ms`;

                                    hopLine += probeInfo + '  ';
                                } else {
                                    hopLine += '*  ';
                                }
                            });
                        } else {
                            hopLine += '* * *';
                        }

                        output.push(hopLine);
                    });
                } else {
                    output.push('No hops found or traceroute failed');
                }

                output.push('');
                output.push('');
            }

            tracerouteResults.textContent = output.join('\n');
        }

        function copyTracerouteResults() {
            const tracerouteResults = document.getElementById('tracerouteResults');
            const textToCopy = tracerouteResults.textContent;

            navigator.clipboard.writeText(textToCopy).then(() => {
                // Visual feedback on the copy button
                const copyButton = document.getElementById('copyTracerouteButton');
                const originalText = copyButton.textContent;
                copyButton.textContent = 'Copied!';
                copyButton.style.backgroundColor = '#4caf50';
                copyButton.style.color = 'white';

                setTimeout(() => {
                    copyButton.textContent = originalText;
                    copyButton.style.backgroundColor = '';
                    copyButton.style.color = '';
                }, 1000);
            }).catch(err => {
                console.error('Failed to copy text: ', err);
                alert('Failed to copy to clipboard');
            });
        }

        function translateTracerouteResults() {
            const tracerouteResults = document.getElementById('tracerouteResults').textContent;

            if (!tracerouteResults || tracerouteResults.trim() === '' || tracerouteResults.includes('Traceroute results will appear here')) {
                alert('No traceroute results to translate');
                return;
            }

            // Switch to IP Translator tab
            showTab('ip-translator');

            // Populate the IP translator input with traceroute results
            const ipTranslatorInput = document.getElementById('inputText');
            ipTranslatorInput.value = tracerouteResults;

            // Scroll to the top
            window.scrollTo({ top: 0, behavior: 'smooth' });

            // Automatically trigger the translation
            translateText();

            // Visual feedback on the translate button
            const translateButton = document.getElementById('translateTracerouteButton');
            const originalText = translateButton.textContent;
            translateButton.textContent = 'Translated!';
            translateButton.style.backgroundColor = '#0056b3';

            setTimeout(() => {
                translateButton.textContent = originalText;
                translateButton.style.backgroundColor = '#007bff';
            }, 1500);
        }

        function downloadTracerouteResults() {
            const tracerouteResults = document.getElementById('tracerouteResults').textContent;
            const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
            const filename = `traceroute_results_${timestamp}.txt`;

            const blob = new Blob([tracerouteResults], { type: 'text/plain' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            a.remove();
        }

        // Toggle IP translation in real-time
        document.getElementById('translateIPs').addEventListener('change', function() {
            if (tracerouteResultsData && Object.keys(tracerouteResultsData).length > 0) {
                // Regenerate display with current data
                const translateIPs = this.checked;
                const tracerouteResults = document.getElementById('tracerouteResults');
                let output = [];

                output.push('TRACEROUTE RESULTS');
                output.push('='.repeat(80));
                output.push('');

                for (const [target, targetData] of Object.entries(tracerouteResultsData)) {
                    output.push(`Target: ${target}`);
                    output.push('-'.repeat(40));

                    if (targetData.hops && targetData.hops.length > 0) {
                        targetData.hops.forEach(hop => {
                            let hopLine = `${hop.hop_num.toString().padStart(2)}  `;

                            if (hop.probes && hop.probes.length > 0) {
                                hop.probes.forEach(probe => {
                                    if (probe.success) {
                                        let probeInfo = '';

                                        // Show IP or hostname
                                        if (probe.hostname && probe.hostname !== probe.ip) {
                                            probeInfo += `${probe.hostname} (${probe.ip})`;
                                        } else {
                                            probeInfo += probe.ip;
                                        }

                                        // Add translated info if available and enabled
                                        if (translateIPs && probe.translated_info) {
                                            probeInfo += ` [${probe.translated_info}]`;
                                        }

                                        // Add RTT
                                        probeInfo += `  ${probe.rtt} ms`;

                                        hopLine += probeInfo + '  ';
                                    } else {
                                        hopLine += '*  ';
                                    }
                                });
                            } else {
                                hopLine += '* * *';
                            }

                            output.push(hopLine);
                        });
                    } else {
                        output.push('No hops found or traceroute failed');
                    }

                    output.push('');
                    output.push('');
                }

                tracerouteResults.textContent = output.join('\n');
            }
        });

        // Debounced translation function
        function scheduleTranslation() {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(translateText, 500); // Wait 500ms after user stops typing
        }

        async function translateText() {
            const text = inputText.value.trim();

            if (!text) {
                outputArea.innerHTML = '<em>Your translated text will appear here...</em>';
                return;
            }

            loadingIndicator.style.display = 'block';

            try {
                const response = await fetch(`/api/translate-ip?text=${encodeURIComponent(text)}`);
                const data = await response.json();

                outputArea.innerHTML = data.translated_text || text;

                // Attach event listeners to enhanced IPs
                attachTooltipHandlers();

            } catch (error) {
                console.error('Translation error:', error);
                outputArea.innerHTML = text;
            } finally {
                loadingIndicator.style.display = 'none';
            }
        }

        function attachTooltipHandlers() {
            const enhancedIPs = document.querySelectorAll('.ip-enhanced');

            enhancedIPs.forEach(element => {
                element.addEventListener('mouseenter', showTooltip);
                element.addEventListener('mouseleave', scheduleHideTooltip);
                element.addEventListener('click', handleIPClick);
            });
        }

        let tooltipHideTimer = null;

        function showTooltip(event) {
            // Clear any pending hide timer
            if (tooltipHideTimer) {
                clearTimeout(tooltipHideTimer);
                tooltipHideTimer = null;
            }

            const element = event.target;
            const tooltipDataStr = element.getAttribute('data-tooltip').replace(/&quot;/g, '"');
            const tooltipData = JSON.parse(tooltipDataStr);
            const mgmtIP = element.getAttribute('data-mgmt-ip');

            // Get theme from backend (passed in template)
            const theme = '{{ tooltip_theme }}' || 'light';

            // Define theme colors
            const themes = {
                light: {
                    bg: '#ffffff',
                    text: '#333333',
                    border: '#d4d4d4',
                    shadow: 'rgba(0,0,0,0.16)',
                    divider: '#e5e5e5',
                    hostname: '#0451a5',
                    mgmtIp: '#a31515',
                    label: '#001080',
                    value: '#333333',
                    status: '#098658',
                    link: '#0066cc',
                    linkHoverBg: '#0066cc',
                    linkHoverText: '#ffffff',
                    separator: '#999999'
                },
                dark: {
                    bg: '#1e1e1e',
                    text: '#cccccc',
                    border: '#454545',
                    shadow: 'rgba(0,0,0,0.66)',
                    divider: '#2d2d30',
                    hostname: '#4ec9b0',
                    mgmtIp: '#ce9178',
                    label: '#9cdcfe',
                    value: '#cccccc',
                    status: '#4ec9b0',
                    link: '#3794ff',
                    linkHoverBg: '#3794ff',
                    linkHoverText: '#ffffff',
                    separator: '#808080'
                }
            };

            const colors = themes[theme];

            const tooltipContent = `
                <div style="background: ${colors.bg};
                            color: ${colors.text};
                            padding: 12px;
                            border-radius: 4px;
                            box-shadow: 0 0 0 1px ${colors.border}, 0 4px 11px ${colors.shadow};
                            min-width: 300px;
                            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
                            font-size: 13px;
                            line-height: 1.5;">
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; padding-bottom: 8px; border-bottom: 1px solid ${colors.divider};">
                        <div>
                            <span style="color: ${colors.hostname}; font-weight: 600;">${tooltipData.hostname}</span>
                            <span style="color: ${colors.separator}; margin: 0 6px;">‚Ä¢</span>
                            <span style="color: ${colors.mgmtIp};">${mgmtIP}</span>
                        </div>
                        <a href="ssh://${mgmtIP}"
                           onclick="event.stopPropagation();"
                           style="color: ${colors.link};
                                  text-decoration: none;
                                  font-size: 11px;
                                  padding: 3px 8px;
                                  border: 1px solid ${colors.link};
                                  border-radius: 3px;
                                  background: transparent;
                                  transition: all 0.2s;
                                  white-space: nowrap;"
                           onmouseover="this.style.background='${colors.linkHoverBg}'; this.style.color='${colors.linkHoverText}';"
                           onmouseout="this.style.background='transparent'; this.style.color='${colors.link}';">
                            SSH
                        </a>
                    </div>
                    <div style="font-size: 12px;">
                        <div style="margin-bottom: 4px;">
                            <span style="color: ${colors.label};">Interface:</span>
                            <span style="color: ${colors.value}; margin-left: 4px;">${tooltipData.interface_name}</span>
                        </div>
                        <div style="margin-bottom: 4px;">
                            <span style="color: ${colors.label};">Description:</span>
                            <span style="color: ${colors.value}; margin-left: 4px;">${tooltipData.interface_description}</span>
                        </div>
                        <div style="margin-bottom: 4px;">
                            <span style="color: ${colors.label};">Vendor:</span>
                            <span style="color: ${colors.value}; margin-left: 4px;">${tooltipData.device_vendor}</span>
                        </div>
                        <div>
                            <span style="color: ${colors.label};">Status:</span>
                            <span style="color: ${colors.status}; margin-left: 4px;">${tooltipData.interface_status}</span>
                        </div>
                    </div>
                </div>
            `;

            tooltip.innerHTML = tooltipContent;
            tooltip.style.display = 'block';

            // Add hover listeners to tooltip itself
            tooltip.addEventListener('mouseenter', cancelHideTooltip);
            tooltip.addEventListener('mouseleave', scheduleHideTooltip);

            // Position tooltip
            const rect = element.getBoundingClientRect();
            tooltip.style.left = rect.left + 'px';
            tooltip.style.top = (rect.bottom + 10) + 'px';
        }

        function scheduleHideTooltip() {
            // Delay hiding to allow moving mouse to tooltip
            tooltipHideTimer = setTimeout(() => {
                hideTooltip();
            }, 200);
        }

        function cancelHideTooltip() {
            if (tooltipHideTimer) {
                clearTimeout(tooltipHideTimer);
                tooltipHideTimer = null;
            }
        }

        function hideTooltip() {
            tooltip.style.display = 'none';
        }

        function handleIPClick(event) {
            const element = event.target;
            const mgmtIP = element.getAttribute('data-mgmt-ip');

            // Copy management IP to clipboard
            navigator.clipboard.writeText(mgmtIP).then(() => {
                // Brief visual feedback
                element.style.backgroundColor = 'yellow';
                setTimeout(() => {
                    element.style.backgroundColor = '';
                }, 200);
            });
        }

        function copyTranslatedOutput() {
            const outputArea = document.getElementById('outputArea');
            // Get the text content without HTML tags
            const textToCopy = outputArea.innerText || outputArea.textContent;

            navigator.clipboard.writeText(textToCopy).then(() => {
                // Visual feedback on the copy button
                const copyButton = document.getElementById('copyButton');
                const originalText = copyButton.textContent;
                copyButton.textContent = 'Copied!';
                copyButton.style.backgroundColor = '#4caf50';
                copyButton.style.color = 'white';

                setTimeout(() => {
                    copyButton.textContent = originalText;
                    copyButton.style.backgroundColor = '';
                    copyButton.style.color = '';
                }, 1000);
            }).catch(err => {
                console.error('Failed to copy text: ', err);
                alert('Failed to copy to clipboard');
            });
        }

        // Event listeners
        inputText.addEventListener('input', scheduleTranslation);
        inputText.addEventListener('paste', () => {
            setTimeout(scheduleTranslation, 10); // Small delay to let paste complete
        });

        // Hide tooltip when clicking elsewhere
        document.addEventListener('click', (event) => {
            if (!event.target.closest('.ip-enhanced')) {
                hideTooltip();
            }
        });

        // Sample text for demonstration
        inputText.addEventListener('focus', function() {
            if (this.value === '') {
                this.placeholder = 'insert command output here..';
            }
        });

        inputText.addEventListener('blur', function() {
            this.placeholder = 'Paste your text here... IP addresses will be automatically translated to show hostname and interface information.';
        });

        // URL/App Insights Functions
        let urlInsightsData = {
            requests: [],
            startTime: null,
            loadTime: null,
            totalSize: 0,
            statusCode: null,
            tlsInfo: null,
            timeline: []
        };

        function showInsightsTab(tabName) {
            // Hide all tab contents
            const contents = document.querySelectorAll('.insights-tab-content');
            contents.forEach(content => content.classList.remove('active'));

            // Remove active class from all tabs
            const tabs = document.querySelectorAll('.insights-tab');
            tabs.forEach(tab => tab.classList.remove('active'));

            // Show selected tab
            document.getElementById(tabName + '-content').classList.add('active');
            event.target.classList.add('active');
        }

        function analyzeURL() {
            const urlInput = document.getElementById('urlInsightsInput');
            let url = urlInput.value.trim();

            if (!url) {
                alert('Please enter a URL');
                return;
            }

            // Auto-add https:// if no protocol specified
            if (!url.match(/^https?:\/\//i)) {
                url = 'https://' + url;
                urlInput.value = url;
            }

            // Validate URL
            let urlObj;
            try {
                urlObj = new URL(url);
            } catch (e) {
                alert('Please enter a valid URL');
                return;
            }

            // Reset data
            urlInsightsData = {
                requests: [],
                startTime: Date.now(),
                loadTime: null,
                totalSize: 0,
                statusCode: null,
                tlsInfo: null,
                timeline: [],
                url: url,
                urlObj: urlObj
            };

            // Show URL info in left pane
            document.getElementById('urlPreview').style.display = 'none';
            document.getElementById('urlInfo').style.display = 'block';
            document.getElementById('analyzed-url').textContent = url;
            document.getElementById('analyzed-protocol').textContent = urlObj.protocol;
            document.getElementById('analyzed-hostname').textContent = urlObj.hostname;
            document.getElementById('analyzed-port').textContent = urlObj.port || (urlObj.protocol === 'https:' ? '443' : '80');
            document.getElementById('contentStatus').textContent = 'Analyzing...';
            document.getElementById('exportInsightsBtn').style.display = 'inline-block';

            // Add initial timeline entry
            addTimelineEntry('Analysis started', 'info');

            // Detect protocol
            if (urlObj.protocol === 'https:') {
                urlInsightsData.tlsInfo = {
                    enabled: true,
                    protocol: 'TLS/SSL',
                    detected: true
                };
                addTimelineEntry('HTTPS detected - TLS encryption enabled', 'success');
            } else {
                urlInsightsData.tlsInfo = {
                    enabled: false,
                    protocol: 'HTTP',
                    detected: false
                };
                addTimelineEntry('HTTP detected - No encryption', 'warning');
            }
            updateTLSDisplay();

            // Make fetch request to analyze
            addTimelineEntry('Initiating connection to: ' + url, 'info');

            // Add error listener to catch network errors before they reach console
            const startFetch = Date.now();

            fetch(url, {
                method: 'HEAD',
                mode: 'no-cors'
            })
            .then(() => {
                urlInsightsData.loadTime = Date.now() - urlInsightsData.startTime;
                urlInsightsData.statusCode = 200;
                addTimelineEntry('HEAD request completed (' + urlInsightsData.loadTime + 'ms)', 'success');
                document.getElementById('contentStatus').textContent = 'Connection successful';

                // Try to get more details with GET
                return fetch(url, { method: 'GET', mode: 'no-cors' });
            })
            .then(response => {
                const fullLoadTime = Date.now() - urlInsightsData.startTime;
                addTimelineEntry('GET request completed (' + fullLoadTime + 'ms)', 'success');
                urlInsightsData.loadTime = fullLoadTime;

                // Add simulated request entry
                urlInsightsData.requests.push({
                    url: url,
                    duration: fullLoadTime,
                    size: 0,
                    type: 'document'
                });

                updateRequestsDisplay();
                updateOverviewStats();
            })
            .catch(error => {
                urlInsightsData.statusCode = 'ERROR';
                urlInsightsData.loadTime = Date.now() - urlInsightsData.startTime;

                // Detect specific error types
                let errorType = 'Connection Error';
                let errorMessage = error.message || 'Unknown error';

                if (error instanceof TypeError) {
                    if (errorMessage.includes('Failed to fetch')) {
                        errorType = 'DNS Resolution Failed / Network Error';
                        addTimelineEntry('DNS lookup failed - hostname could not be resolved', 'error');
                        addTimelineEntry('Possible causes: Invalid domain, DNS issues, or network connectivity problems', 'error');
                        document.getElementById('contentStatus').textContent = 'DNS Error';
                    } else if (errorMessage.includes('NetworkError')) {
                        errorType = 'Network Error';
                        addTimelineEntry('Network error occurred during connection', 'error');
                        document.getElementById('contentStatus').textContent = 'Network Error';
                    } else if (errorMessage.includes('CORS')) {
                        errorType = 'CORS Policy Violation';
                        addTimelineEntry('CORS policy blocked the request', 'warning');
                        document.getElementById('contentStatus').textContent = 'CORS Blocked';
                    } else {
                        addTimelineEntry('Connection failed: ' + errorMessage, 'error');
                        document.getElementById('contentStatus').textContent = 'Connection Failed';
                    }
                } else {
                    addTimelineEntry('Error: ' + errorMessage, 'error');
                    document.getElementById('contentStatus').textContent = 'Error';
                }

                addTimelineEntry('Connection attempt duration: ' + urlInsightsData.loadTime + 'ms', 'info');

                // Add failed request entry
                urlInsightsData.requests.push({
                    url: url,
                    duration: urlInsightsData.loadTime,
                    size: 0,
                    type: 'failed',
                    error: errorType
                });

                updateRequestsDisplay();
                updateOverviewStats();
            });
        }

        function clearURLAnalysis() {
            document.getElementById('urlInsightsInput').value = '';
            document.getElementById('urlPreview').style.display = 'block';
            document.getElementById('urlInfo').style.display = 'none';
            document.getElementById('contentStatus').textContent = 'No URL loaded';
            document.getElementById('exportInsightsBtn').style.display = 'none';

            urlInsightsData = {
                requests: [],
                startTime: null,
                loadTime: null,
                totalSize: 0,
                statusCode: null,
                tlsInfo: null,
                timeline: []
            };
            updateOverviewStats();
            updateRequestsDisplay();
            updateTLSDisplay();
            updateTimelineDisplay();
        }

        function exportInsights() {
            const dataStr = JSON.stringify(urlInsightsData, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'url-insights-' + Date.now() + '.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function updateOverviewStats() {
            document.getElementById('stat-total-requests').textContent = urlInsightsData.requests.length;
            document.getElementById('stat-total-size').textContent = formatBytes(urlInsightsData.totalSize);
            document.getElementById('stat-load-time').textContent = urlInsightsData.loadTime ? urlInsightsData.loadTime + ' ms' : '-';
            document.getElementById('stat-status-code').textContent = urlInsightsData.statusCode || '-';
        }

        function updateRequestsDisplay() {
            const container = document.getElementById('requests-content');
            if (urlInsightsData.requests.length === 0) {
                container.innerHTML = '<em style="color: #666;">No requests captured yet...</em>';
                return;
            }

            let html = '<table style="width: 100%; font-size: 11px; border-collapse: collapse;">';
            html += '<thead><tr style="background: #f8f9fa; border-bottom: 2px solid #ddd;">';
            html += '<th style="padding: 6px; text-align: left;">URL</th>';
            html += '<th style="padding: 6px; text-align: left;">Type</th>';
            html += '<th style="padding: 6px; text-align: right;">Duration</th>';
            html += '<th style="padding: 6px; text-align: right;">Size</th>';
            html += '</tr></thead><tbody>';

            urlInsightsData.requests.forEach(req => {
                const isError = req.type === 'failed';
                const rowStyle = isError ? 'border-bottom: 1px solid #eee; background: #fff5f5;' : 'border-bottom: 1px solid #eee;';

                html += '<tr style="' + rowStyle + '">';
                html += '<td style="padding: 4px; max-width: 300px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">' + req.url + '</td>';

                if (isError) {
                    html += '<td style="padding: 4px; color: #dc3545;"><strong>' + (req.error || 'Error') + '</strong></td>';
                } else {
                    html += '<td style="padding: 4px;">' + req.type + '</td>';
                }

                html += '<td style="padding: 4px; text-align: right;">' + Math.round(req.duration) + ' ms</td>';
                html += '<td style="padding: 4px; text-align: right;">' + (isError ? 'N/A' : formatBytes(req.size)) + '</td>';
                html += '</tr>';
            });

            html += '</tbody></table>';
            container.innerHTML = html;
        }

        function updateTLSDisplay() {
            const container = document.getElementById('tls-content');
            if (!urlInsightsData.tlsInfo) {
                container.innerHTML = '<em style="color: #666;">No TLS information available...</em>';
                return;
            }

            let html = '<div style="font-size: 12px;">';
            html += '<p><strong>Protocol:</strong> ' + urlInsightsData.tlsInfo.protocol + '</p>';
            html += '<p><strong>Encryption:</strong> ' + (urlInsightsData.tlsInfo.enabled ?
                '<span style="color: #28a745;">‚úì Enabled</span>' :
                '<span style="color: #dc3545;">‚úó Disabled</span>') + '</p>';

            if (urlInsightsData.tlsInfo.enabled) {
                html += '<p style="margin-top: 10px;"><strong>Note:</strong> Browser security restrictions prevent detailed certificate inspection. The connection uses HTTPS with TLS encryption.</p>';
            } else {
                html += '<p style="margin-top: 10px; color: #dc3545;"><strong>Warning:</strong> This connection is not encrypted. Data is transmitted in plain text.</p>';
            }

            html += '</div>';
            container.innerHTML = html;
        }

        function updateTimelineDisplay() {
            const container = document.getElementById('timeline-content');
            if (urlInsightsData.timeline.length === 0) {
                container.innerHTML = '<em style="color: #666;">No timeline events yet...</em>';
                return;
            }

            let html = '<div style="font-size: 11px;">';
            urlInsightsData.timeline.forEach(event => {
                let color = '#666';
                if (event.type === 'success') color = '#28a745';
                if (event.type === 'error') color = '#dc3545';
                if (event.type === 'warning') color = '#ffc107';

                html += '<div style="padding: 4px 0; border-bottom: 1px solid #eee;">';
                html += '<span style="color: ' + color + '; margin-right: 8px;">‚óè</span>';
                html += '<span style="color: #999; margin-right: 8px;">[' + event.timestamp + ']</span>';
                html += '<span>' + event.message + '</span>';
                html += '</div>';
            });
            html += '</div>';
            container.innerHTML = html;
        }

        function addTimelineEntry(message, type) {
            const timestamp = new Date().toLocaleTimeString();
            urlInsightsData.timeline.push({ timestamp, message, type });
            updateTimelineDisplay();
        }

        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        }

        // Initialize insights tab on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Set default active tab to Overview
            const overviewTab = document.querySelector('.insights-tab');
            if (overviewTab) {
                overviewTab.classList.add('active');
                document.getElementById('overview-content').classList.add('active');
            }

            // Load WhoAmI data
            loadWhoAmIData();
        });

        // WhoAmI Functions
        function loadWhoAmIData() {
            const ipAddressElement = document.getElementById('userIpAddress');
            const ipDetailsElement = document.getElementById('ipDetails');
            const ipVersionElement = document.getElementById('ipVersion');
            const ipTypeElement = document.getElementById('ipType');
            const reverseDnsElement = document.getElementById('reverseDns');
            const reverseDnsValueElement = document.getElementById('reverseDnsValue');

            if (!ipAddressElement) return; // Tab not visible

            // Fetch IP address from server
            fetch('/api/whoami')
                .then(response => response.json())
                .then(data => {
                    if (data.ip) {
                        ipAddressElement.innerHTML = data.ip;

                        // Determine IP version
                        const isIPv6 = data.ip.includes(':');
                        ipVersionElement.textContent = isIPv6 ? 'IPv6' : 'IPv4';

                        // Determine IP type (private vs public)
                        const isPrivate = isPrivateIP(data.ip);
                        ipTypeElement.textContent = isPrivate ? 'Private' : 'Public';

                        // Show details
                        ipDetailsElement.style.display = 'block';

                        // Show reverse DNS if available
                        if (data.reverse_dns) {
                            reverseDnsValueElement.textContent = data.reverse_dns;
                            reverseDnsElement.style.display = 'block';
                        }
                    } else {
                        ipAddressElement.innerHTML = '<span style="opacity: 0.6;">Unable to detect</span>';
                    }
                })
                .catch(error => {
                    console.error('Error fetching IP:', error);
                    ipAddressElement.innerHTML = '<span style="opacity: 0.6;">Error loading</span>';
                });
        }

        function isPrivateIP(ip) {
            // Check for IPv4 private ranges
            if (ip.includes('.')) {
                const parts = ip.split('.');
                if (parts.length === 4) {
                    const first = parseInt(parts[0]);
                    const second = parseInt(parts[1]);

                    // 10.0.0.0/8
                    if (first === 10) return true;

                    // 172.16.0.0/12
                    if (first === 172 && second >= 16 && second <= 31) return true;

                    // 192.168.0.0/16
                    if (first === 192 && second === 168) return true;

                    // 127.0.0.0/8 (localhost)
                    if (first === 127) return true;
                }
            }

            // Check for IPv6 private ranges
            if (ip.includes(':')) {
                // Link-local (fe80::/10)
                if (ip.toLowerCase().startsWith('fe80:')) return true;

                // Unique local (fc00::/7)
                if (ip.toLowerCase().startsWith('fc') || ip.toLowerCase().startsWith('fd')) return true;

                // Loopback (::1)
                if (ip === '::1') return true;
            }

            return false;
        }
    </script>
</body>
</html>